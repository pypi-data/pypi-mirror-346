# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CLICopti
else:
    import _CLICopti

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class size_t_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _CLICopti.size_t_array_swiginit(self, _CLICopti.new_size_t_array(nelements))
    __swig_destroy__ = _CLICopti.delete_size_t_array

    def __getitem__(self, index):
        return _CLICopti.size_t_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _CLICopti.size_t_array___setitem__(self, index, value)

    def cast(self):
        return _CLICopti.size_t_array_cast(self)

    @staticmethod
    def frompointer(t):
        return _CLICopti.size_t_array_frompointer(t)

# Register size_t_array in _CLICopti:
_CLICopti.size_t_array_swigregister(size_t_array)
class double_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _CLICopti.double_array_swiginit(self, _CLICopti.new_double_array(nelements))
    __swig_destroy__ = _CLICopti.delete_double_array

    def __getitem__(self, index):
        return _CLICopti.double_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _CLICopti.double_array___setitem__(self, index, value)

    def cast(self):
        return _CLICopti.double_array_cast(self)

    @staticmethod
    def frompointer(t):
        return _CLICopti.double_array_frompointer(t)

# Register double_array in _CLICopti:
_CLICopti.double_array_swigregister(double_array)
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CLICopti.delete_SwigPyIterator

    def value(self):
        return _CLICopti.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CLICopti.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CLICopti.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CLICopti.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CLICopti.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CLICopti.SwigPyIterator_copy(self)

    def next(self):
        return _CLICopti.SwigPyIterator_next(self)

    def __next__(self):
        return _CLICopti.SwigPyIterator___next__(self)

    def previous(self):
        return _CLICopti.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CLICopti.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CLICopti.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CLICopti.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CLICopti.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CLICopti.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CLICopti.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CLICopti.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CLICopti:
_CLICopti.SwigPyIterator_swigregister(SwigPyIterator)
class size_t_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _CLICopti.size_t_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _CLICopti.size_t_vector___nonzero__(self)

    def __bool__(self):
        return _CLICopti.size_t_vector___bool__(self)

    def __len__(self):
        return _CLICopti.size_t_vector___len__(self)

    def __getslice__(self, i, j):
        return _CLICopti.size_t_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _CLICopti.size_t_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _CLICopti.size_t_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _CLICopti.size_t_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _CLICopti.size_t_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _CLICopti.size_t_vector___setitem__(self, *args)

    def pop(self):
        return _CLICopti.size_t_vector_pop(self)

    def append(self, x):
        return _CLICopti.size_t_vector_append(self, x)

    def empty(self):
        return _CLICopti.size_t_vector_empty(self)

    def size(self):
        return _CLICopti.size_t_vector_size(self)

    def swap(self, v):
        return _CLICopti.size_t_vector_swap(self, v)

    def begin(self):
        return _CLICopti.size_t_vector_begin(self)

    def end(self):
        return _CLICopti.size_t_vector_end(self)

    def rbegin(self):
        return _CLICopti.size_t_vector_rbegin(self)

    def rend(self):
        return _CLICopti.size_t_vector_rend(self)

    def clear(self):
        return _CLICopti.size_t_vector_clear(self)

    def get_allocator(self):
        return _CLICopti.size_t_vector_get_allocator(self)

    def pop_back(self):
        return _CLICopti.size_t_vector_pop_back(self)

    def erase(self, *args):
        return _CLICopti.size_t_vector_erase(self, *args)

    def __init__(self, *args):
        _CLICopti.size_t_vector_swiginit(self, _CLICopti.new_size_t_vector(*args))

    def push_back(self, x):
        return _CLICopti.size_t_vector_push_back(self, x)

    def front(self):
        return _CLICopti.size_t_vector_front(self)

    def back(self):
        return _CLICopti.size_t_vector_back(self)

    def assign(self, n, x):
        return _CLICopti.size_t_vector_assign(self, n, x)

    def resize(self, *args):
        return _CLICopti.size_t_vector_resize(self, *args)

    def insert(self, *args):
        return _CLICopti.size_t_vector_insert(self, *args)

    def reserve(self, n):
        return _CLICopti.size_t_vector_reserve(self, n)

    def capacity(self):
        return _CLICopti.size_t_vector_capacity(self)
    __swig_destroy__ = _CLICopti.delete_size_t_vector

# Register size_t_vector in _CLICopti:
_CLICopti.size_t_vector_swigregister(size_t_vector)
class double_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _CLICopti.double_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _CLICopti.double_vector___nonzero__(self)

    def __bool__(self):
        return _CLICopti.double_vector___bool__(self)

    def __len__(self):
        return _CLICopti.double_vector___len__(self)

    def __getslice__(self, i, j):
        return _CLICopti.double_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _CLICopti.double_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _CLICopti.double_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _CLICopti.double_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _CLICopti.double_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _CLICopti.double_vector___setitem__(self, *args)

    def pop(self):
        return _CLICopti.double_vector_pop(self)

    def append(self, x):
        return _CLICopti.double_vector_append(self, x)

    def empty(self):
        return _CLICopti.double_vector_empty(self)

    def size(self):
        return _CLICopti.double_vector_size(self)

    def swap(self, v):
        return _CLICopti.double_vector_swap(self, v)

    def begin(self):
        return _CLICopti.double_vector_begin(self)

    def end(self):
        return _CLICopti.double_vector_end(self)

    def rbegin(self):
        return _CLICopti.double_vector_rbegin(self)

    def rend(self):
        return _CLICopti.double_vector_rend(self)

    def clear(self):
        return _CLICopti.double_vector_clear(self)

    def get_allocator(self):
        return _CLICopti.double_vector_get_allocator(self)

    def pop_back(self):
        return _CLICopti.double_vector_pop_back(self)

    def erase(self, *args):
        return _CLICopti.double_vector_erase(self, *args)

    def __init__(self, *args):
        _CLICopti.double_vector_swiginit(self, _CLICopti.new_double_vector(*args))

    def push_back(self, x):
        return _CLICopti.double_vector_push_back(self, x)

    def front(self):
        return _CLICopti.double_vector_front(self)

    def back(self):
        return _CLICopti.double_vector_back(self)

    def assign(self, n, x):
        return _CLICopti.double_vector_assign(self, n, x)

    def resize(self, *args):
        return _CLICopti.double_vector_resize(self, *args)

    def insert(self, *args):
        return _CLICopti.double_vector_insert(self, *args)

    def reserve(self, n):
        return _CLICopti.double_vector_reserve(self, n)

    def capacity(self):
        return _CLICopti.double_vector_capacity(self)
    __swig_destroy__ = _CLICopti.delete_double_vector

# Register double_vector in _CLICopti:
_CLICopti.double_vector_swigregister(double_vector)
class CellParams(object):
    r"""
    Description of the parameters of a given cell or point along the z axis.
    All parameters are doubles, note that some of the parameters
    may be set to NaN if not valid for the given cell
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    h = property(_CLICopti.CellParams_h_get, _CLICopti.CellParams_h_set, doc=r""" Cell length [m]""")
    a = property(_CLICopti.CellParams_a_get, _CLICopti.CellParams_a_set, doc=r""" Iris aperture [m]""")
    d_n = property(_CLICopti.CellParams_d_n_get, _CLICopti.CellParams_d_n_set, doc=r""" Normalized iris thickness / h""")
    a_n = property(_CLICopti.CellParams_a_n_get, _CLICopti.CellParams_a_n_set, doc=r""" Normalized iris aperture a/lambda""")
    f0 = property(_CLICopti.CellParams_f0_get, _CLICopti.CellParams_f0_set, doc=r""" Frequency [GHz] of main mode""")
    psi = property(_CLICopti.CellParams_psi_get, _CLICopti.CellParams_psi_set, doc=r""" Phase advance [deg] of main mode""")
    Q = property(_CLICopti.CellParams_Q_get, _CLICopti.CellParams_Q_set, doc=r""" Q-factor of main mode""")
    vg = property(_CLICopti.CellParams_vg_get, _CLICopti.CellParams_vg_set, doc=r""" Group velocity [%c] of main mode""")
    rQ = property(_CLICopti.CellParams_rQ_get, _CLICopti.CellParams_rQ_set, doc=r""" r/Q [linacOhm / m] of main mode""")
    Es = property(_CLICopti.CellParams_Es_get, _CLICopti.CellParams_Es_set, doc=r""" Esurf/Eacc of main mode""")
    Hs = property(_CLICopti.CellParams_Hs_get, _CLICopti.CellParams_Hs_set, doc=r""" Hsurf/Eacc [mA/V] of main mode""")
    Sc = property(_CLICopti.CellParams_Sc_get, _CLICopti.CellParams_Sc_set, doc=r""" Sc/Eacc^2 [mA/V] of main mode""")
    f1mn = property(_CLICopti.CellParams_f1mn_get, _CLICopti.CellParams_f1mn_set, doc=r""" Frequency [GHz] of wakefield 1st transverse mode""")
    Q1mn = property(_CLICopti.CellParams_Q1mn_get, _CLICopti.CellParams_Q1mn_set, doc=r""" Q-factor of wakefield 1st transverse mode""")
    A1mn = property(_CLICopti.CellParams_A1mn_get, _CLICopti.CellParams_A1mn_set, doc=r""" Amplitude [V/pC/mm/m] of wakefield 1st transverse mode""")

    def __repr__(self):
        return _CLICopti.CellParams___repr__(self)

    def __mul__(self, rhs):
        return _CLICopti.CellParams___mul__(self, rhs)

    def __rmul__(self, lhs):
        return _CLICopti.CellParams___rmul__(self, lhs)

    def __truediv__(self, rhs):
        return _CLICopti.CellParams___truediv__(self, rhs)

    def __add__(self, rhs):
        return _CLICopti.CellParams___add__(self, rhs)

    def __sub__(self, rhs):
        return _CLICopti.CellParams___sub__(self, rhs)

    def __init__(self):
        _CLICopti.CellParams_swiginit(self, _CLICopti.new_CellParams())
    __swig_destroy__ = _CLICopti.delete_CellParams

# Register CellParams in _CLICopti:
_CLICopti.CellParams_swigregister(CellParams)

def Cell_TD_30GHz_v1_fileParse(line):
    return _CLICopti.Cell_TD_30GHz_v1_fileParse(line)

def Cell_TD_12GHz_v1_fileParse(line):
    return _CLICopti.Cell_TD_12GHz_v1_fileParse(line)

def scaleCell(c, f0, scalingLevel=3):
    return _CLICopti.scaleCell(c, f0, scalingLevel)

def CellParams_copy(c):
    return _CLICopti.CellParams_copy(c)
class CellParamsError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor (C strings).
        :type message: string
        :param message: C-style string error message.
                           The string contents are copied upon construction.
                           Hence, responsibility for deleting the char* lies
                           with the caller.

        |

        *Overload 2:*
        Constructor (C++ STL strings).
        :type message: string
        :param message: The error message.
        """
        _CLICopti.CellParamsError_swiginit(self, _CLICopti.new_CellParamsError(*args))
    __swig_destroy__ = _CLICopti.delete_CellParamsError

# Register CellParamsError in _CLICopti:
_CLICopti.CellParamsError_swigregister(CellParamsError)
cvar = _CLICopti.cvar
off_h = cvar.off_h
off_a = cvar.off_a
off_d_n = cvar.off_d_n
off_a_n = cvar.off_a_n
off_f0 = cvar.off_f0
off_psi = cvar.off_psi
off_Q = cvar.off_Q
off_vg = cvar.off_vg
off_rQ = cvar.off_rQ
off_Es = cvar.off_Es
off_Hs = cvar.off_Hs
off_Sc = cvar.off_Sc
off_f1mn = cvar.off_f1mn
off_Q1mn = cvar.off_Q1mn
off_A1mn = cvar.off_A1mn

class CellBase(object):
    r"""
    This class loads the cell database file and handles data for individual cells.
     It is meant to be instanciated once via one of its daughter classes,
     and then used to create several cells via interpolation.
     The interpolation algorithms are implemented in the daughter classes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CLICopti.delete_CellBase
    UNDEFINED = _CLICopti.CellBase_UNDEFINED
    r""" CellParams type not set *default value)"""
    TD_30GHz_v1 = _CLICopti.CellBase_TD_30GHz_v1
    r""" CellParams loaded by `Cell_TD_30GHz_v1_fileParse()`"""
    TD_12GHz_v1 = _CLICopti.CellBase_TD_12GHz_v1
    r""" CallParams loaded by `Cell_TD_12GHz_v1_fileParse()`"""
    cellType = property(_CLICopti.CellBase_cellType_get, _CLICopti.CellBase_cellType_set, doc=r""" Use TD_30GHz_v1 or TD_12GHz_v1?""")
    GRID = _CLICopti.CellBase_GRID
    r""" Cell database has points on a regular rectangular grid"""
    FREE = _CLICopti.CellBase_FREE
    r""" Free-form cell database (default value)"""
    cellSorting = property(_CLICopti.CellBase_cellSorting_get, _CLICopti.CellBase_cellSorting_set, doc=r""" Use GRID or FREE?""")

    def getCellInterpolated(self, point):
        r"""
         Get an interpolated cell (method implementation dependent).

        :type point: std::vector< double,std::allocator< double > >
        :param point: The point at which to evaluate the interpolation.
            The passed array should have length numIndices,
            and the meaning of each element is specified by `offsets`,
            which is passed to the class constructor
        """
        return _CLICopti.CellBase_getCellInterpolated(self, point)
    numIndices = property(_CLICopti.CellBase_numIndices_get, doc=r''' Number of "index fields"''')
    offsets = property(_CLICopti.CellBase_offsets_get, _CLICopti.CellBase_offsets_set, doc=r"""
    Byte-offsets into cells specifying the indexFields
    Should have length numIndices
    """)

# Register CellBase in _CLICopti:
_CLICopti.CellBase_swigregister(CellBase)
class CellBase_grid(CellBase):
    r"""
    Builds a grid of cells, any depth.
    How it works: In the input file, CELLSORTING must be ``GRID``.
    Also needs the CHILDKEY ``GRIDSORT``,
    with "d" positive integers describing the number of entries in every dimension,
    d being the number of dimensions.
    This is sorted such that the first integer corresponds to the outer sorting,
    second integer one step "below" etc.

    Internally, the ``gridsort`` array stores the data from GRIDSORT,
    and the 2D-array gridlabels stores the values on the axis if you where to plot is as d-cube,
    first index being which dimension, second index being the number along this dimension.
    It is checked that the data is increasing monotonically along every dimension.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CLICopti.delete_CellBase_grid

    def getCellGrid(self, gridIdx):
        return _CLICopti.CellBase_grid_getCellGrid(self, gridIdx)

    def printGrid(self):
        return _CLICopti.CellBase_grid_printGrid(self)

    def getMinLabel(self, dimension):
        r""" Get the min and max allowable label for a given dimension"""
        return _CLICopti.CellBase_grid_getMinLabel(self, dimension)

    def getMaxLabel(self, dimension):
        return _CLICopti.CellBase_grid_getMaxLabel(self, dimension)

    def getGridsort(self, dimension):
        r""" Get number of points in a given direction"""
        return _CLICopti.CellBase_grid_getGridsort(self, dimension)

    def getGridlabels(self, dimension):
        r""" Get the points in a given direction"""
        return _CLICopti.CellBase_grid_getGridlabels(self, dimension)

# Register CellBase_grid in _CLICopti:
_CLICopti.CellBase_grid_swigregister(CellBase_grid)
class CellBase_linearInterpolation(CellBase_grid):
    r"""On top of ``CellBase_gridSort``, do linear interpolation between the points."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _CLICopti.CellBase_linearInterpolation_swiginit(self, _CLICopti.new_CellBase_linearInterpolation(*args))

    def getCellInterpolated(self, point):
        return _CLICopti.CellBase_linearInterpolation_getCellInterpolated(self, point)
    __swig_destroy__ = _CLICopti.delete_CellBase_linearInterpolation

# Register CellBase_linearInterpolation in _CLICopti:
_CLICopti.CellBase_linearInterpolation_swigregister(CellBase_linearInterpolation)
class CellBase_linearInterpolation_freqScaling(CellBase_linearInterpolation):
    r"""
    This is a wrapper of ``CellBase_linearInterpolation``,
    which also scales the cells to a given frequency ``f0`` [GHz].

    Note: The output is scaled, however if ``offsets`` include frequency-dependent data,
    the input has to be in the original scaling.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _CLICopti.CellBase_linearInterpolation_freqScaling_swiginit(self, _CLICopti.new_CellBase_linearInterpolation_freqScaling(*args))

    def getCellInterpolated(self, point):
        return _CLICopti.CellBase_linearInterpolation_freqScaling_getCellInterpolated(self, point)

    def scaleCell(self, c):
        return _CLICopti.CellBase_linearInterpolation_freqScaling_scaleCell(self, c)

    def getF0(self):
        return _CLICopti.CellBase_linearInterpolation_freqScaling_getF0(self)
    __swig_destroy__ = _CLICopti.delete_CellBase_linearInterpolation_freqScaling

# Register CellBase_linearInterpolation_freqScaling in _CLICopti:
_CLICopti.CellBase_linearInterpolation_freqScaling_swigregister(CellBase_linearInterpolation_freqScaling)
class CellBase_compat(CellBase_grid):
    r"""
    Implements Alexej's old algorithm for generating cells:

    1. Quad-interpolate cell parameters for ``a_n``, ``d_n``
    2. If neccessary, quad-interpolate for the phase advance
       (EXCEPT we don't have the data for this -- need 3 phase advances,
       have only 120 and 150 degrees, not 90/110/130 as seems to have been used --
       Thus I'm only implementing linear interpolation here.)
       ALSO, if ``havePhaseAdvance`` = false, then assume there are no phase advance information.
    3. Scale to frequency f0[GHz] according to ``scalingLevel`` setting:

       ``scalingLevel`` = -1
         Ignore `f0`, no scaling.
       ``scalingLevel`` = 0
         Set the cell's frequency to `f0` without changing anything else.
       ``scalingLevel`` = 1
         Scale RF parameters and wakefield, but not geometry.
       ``scalingLevel`` = 2
         Scale RF parameters, wakefield, and geometry EXCEPT ``h``.
       ``scalingLevel`` = 3
         Scale everything.

    Note that this class is mostly assuming the file ``TD_30GHz.dat`` to be used as input.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fname, f0=29.985, havePhaseAdvance=True, scalingLevel=3):
        _CLICopti.CellBase_compat_swiginit(self, _CLICopti.new_CellBase_compat(fname, f0, havePhaseAdvance, scalingLevel))
    __swig_destroy__ = _CLICopti.delete_CellBase_compat

    def getCellInterpolated(self, point):
        return _CLICopti.CellBase_compat_getCellInterpolated(self, point)

    def scaleCell(self, c):
        return _CLICopti.CellBase_compat_scaleCell(self, c)

    def getF0(self):
        return _CLICopti.CellBase_compat_getF0(self)

    def getScalingLevel(self):
        return _CLICopti.CellBase_compat_getScalingLevel(self)

# Register CellBase_compat in _CLICopti:
_CLICopti.CellBase_compat_swigregister(CellBase_compat)
class CellBaseError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor (C strings).
        :type message: string
        :param message: C-style string error message.
                           The string contents are copied upon construction.
                           Hence, responsibility for deleting the char* lies
                           with the caller.

        |

        *Overload 2:*
        Constructor (C++ STL strings).
        :type message: string
        :param message: The error message.
        """
        _CLICopti.CellBaseError_swiginit(self, _CLICopti.new_CellBaseError(*args))
    __swig_destroy__ = _CLICopti.delete_CellBaseError

# Register CellBaseError in _CLICopti:
_CLICopti.CellBaseError_swigregister(CellBaseError)
M_PI = _CLICopti.M_PI
class return_AccelStructure_getMaxFields(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    maxEs = property(_CLICopti.return_AccelStructure_getMaxFields_maxEs_get, _CLICopti.return_AccelStructure_getMaxFields_maxEs_set)
    maxHs = property(_CLICopti.return_AccelStructure_getMaxFields_maxHs_get, _CLICopti.return_AccelStructure_getMaxFields_maxHs_set)
    maxSc = property(_CLICopti.return_AccelStructure_getMaxFields_maxSc_get, _CLICopti.return_AccelStructure_getMaxFields_maxSc_set)
    maxPC = property(_CLICopti.return_AccelStructure_getMaxFields_maxPC_get, _CLICopti.return_AccelStructure_getMaxFields_maxPC_set)
    maxEs_idx = property(_CLICopti.return_AccelStructure_getMaxFields_maxEs_idx_get, _CLICopti.return_AccelStructure_getMaxFields_maxEs_idx_set)
    maxHs_idx = property(_CLICopti.return_AccelStructure_getMaxFields_maxHs_idx_get, _CLICopti.return_AccelStructure_getMaxFields_maxHs_idx_set)
    maxSc_idx = property(_CLICopti.return_AccelStructure_getMaxFields_maxSc_idx_get, _CLICopti.return_AccelStructure_getMaxFields_maxSc_idx_set)
    maxPC_idx = property(_CLICopti.return_AccelStructure_getMaxFields_maxPC_idx_get, _CLICopti.return_AccelStructure_getMaxFields_maxPC_idx_set)

    def __repr__(self):
        return _CLICopti.return_AccelStructure_getMaxFields___repr__(self)

    def __init__(self):
        _CLICopti.return_AccelStructure_getMaxFields_swiginit(self, _CLICopti.new_return_AccelStructure_getMaxFields())
    __swig_destroy__ = _CLICopti.delete_return_AccelStructure_getMaxFields

# Register return_AccelStructure_getMaxFields in _CLICopti:
_CLICopti.return_AccelStructure_getMaxFields_swigregister(return_AccelStructure_getMaxFields)
speed_of_light = cvar.speed_of_light
mu0 = cvar.mu0
electron_charge = cvar.electron_charge

class return_AccelStructure_getMaxDeltaT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    maxDeltaT = property(_CLICopti.return_AccelStructure_getMaxDeltaT_maxDeltaT_get, _CLICopti.return_AccelStructure_getMaxDeltaT_maxDeltaT_set)
    maxDeltaT_idx = property(_CLICopti.return_AccelStructure_getMaxDeltaT_maxDeltaT_idx_get, _CLICopti.return_AccelStructure_getMaxDeltaT_maxDeltaT_idx_set)

    def __repr__(self):
        return _CLICopti.return_AccelStructure_getMaxDeltaT___repr__(self)

    def __init__(self):
        _CLICopti.return_AccelStructure_getMaxDeltaT_swiginit(self, _CLICopti.new_return_AccelStructure_getMaxDeltaT())
    __swig_destroy__ = _CLICopti.delete_return_AccelStructure_getMaxDeltaT

# Register return_AccelStructure_getMaxDeltaT in _CLICopti:
_CLICopti.return_AccelStructure_getMaxDeltaT_swigregister(return_AccelStructure_getMaxDeltaT)
class return_AccelStructure_getMaxAllowableBeamTime_detailed(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    power = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_power_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_power_set)
    beamCurrent_pulseShape = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_beamCurrent_pulseShape_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_beamCurrent_pulseShape_set)
    beamCurrent_loading = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_beamCurrent_loading_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_beamCurrent_loading_set)
    powerFraction = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_powerFraction_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_powerFraction_set)
    maxFields = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_maxFields_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_maxFields_set)
    wastedTime = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_wastedTime_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_wastedTime_set)
    time_E = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_E_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_E_set)
    time_Sc = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_Sc_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_Sc_set)
    time_dT = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_dT_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_dT_set)
    time_PC = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_PC_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_PC_set)
    time = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_time_set)
    which = property(_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_which_get, _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_which_set)

    def __repr__(self):
        return _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed___repr__(self)

    def __init__(self):
        _CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_swiginit(self, _CLICopti.new_return_AccelStructure_getMaxAllowableBeamTime_detailed())
    __swig_destroy__ = _CLICopti.delete_return_AccelStructure_getMaxAllowableBeamTime_detailed

# Register return_AccelStructure_getMaxAllowableBeamTime_detailed in _CLICopti:
_CLICopti.return_AccelStructure_getMaxAllowableBeamTime_detailed_swigregister(return_AccelStructure_getMaxAllowableBeamTime_detailed)
class AccelStructureUninitialized(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor (C strings).
        :type message: string
        :param message: C-style string error message.
                           The string contents are copied upon construction.
                           Hence, responsibility for deleting the char* lies
                           with the caller.

        |

        *Overload 2:*
        Constructor (C++ STL strings).
        :type message: string
        :param message: The error message.
        """
        _CLICopti.AccelStructureUninitialized_swiginit(self, _CLICopti.new_AccelStructureUninitialized(*args))
    __swig_destroy__ = _CLICopti.delete_AccelStructureUninitialized

# Register AccelStructureUninitialized in _CLICopti:
_CLICopti.AccelStructureUninitialized_swigregister(AccelStructureUninitialized)
class AccelStructureInternalError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor (C strings).
        :type message: string
        :param message: C-style string error message.
                           The string contents are copied upon construction.
                           Hence, responsibility for deleting the char* lies
                           with the caller.

        |

        *Overload 2:*
        Constructor (C++ STL strings).
        :type message: string
        :param message: The error message.
        """
        _CLICopti.AccelStructureInternalError_swiginit(self, _CLICopti.new_AccelStructureInternalError(*args))
    __swig_destroy__ = _CLICopti.delete_AccelStructureInternalError

# Register AccelStructureInternalError in _CLICopti:
_CLICopti.AccelStructureInternalError_swigregister(AccelStructureInternalError)
class AccelStructure(object):
    r"""
    This class calculates represents a single main beam accelerating structure,
    and calculates its parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CLICopti.delete_AccelStructure

    def calc_g_integrals(self, numPoints=200):
        r""" Steady-state power flow calculations *"""
        return _CLICopti.AccelStructure_calc_g_integrals(self, numPoints)

    def prune_integrals(self):
        return _CLICopti.AccelStructure_prune_integrals(self)

    def getZNumpoints(self):
        return _CLICopti.AccelStructure_getZNumpoints(self)

    def getZ(self, idx):
        return _CLICopti.AccelStructure_getZ(self, idx)

    def getEz_unloaded(self, idx, peakPower):
        return _CLICopti.AccelStructure_getEz_unloaded(self, idx, peakPower)

    def getEz_loaded(self, idx, peakPower, current):
        return _CLICopti.AccelStructure_getEz_loaded(self, idx, peakPower, current)

    def getPowerUnloaded(self, voltageUnloaded):
        return _CLICopti.AccelStructure_getPowerUnloaded(self, voltageUnloaded)

    def getVoltageUnloaded(self, power):
        return _CLICopti.AccelStructure_getVoltageUnloaded(self, power)

    def getPowerLoaded(self, voltageLoaded, beamCurrent):
        return _CLICopti.AccelStructure_getPowerLoaded(self, voltageLoaded, beamCurrent)

    def getVoltageLoaded(self, power, beamCurrent):
        return _CLICopti.AccelStructure_getVoltageLoaded(self, power, beamCurrent)

    def getLoadingVoltage(self, beamCurrent):
        return _CLICopti.AccelStructure_getLoadingVoltage(self, beamCurrent)

    def getTfill(self):
        return _CLICopti.AccelStructure_getTfill(self)

    def getTrise(self):
        return _CLICopti.AccelStructure_getTrise(self)

    def getOmega(self):
        return _CLICopti.AccelStructure_getOmega(self)

    def getF0(self):
        return _CLICopti.AccelStructure_getF0(self)

    def getPsi(self):
        return _CLICopti.AccelStructure_getPsi(self)

    def getMaxFields(self, power, beamCurrent=0.0):
        return _CLICopti.AccelStructure_getMaxFields(self, power, beamCurrent)

    def writeProfileFile(self, fname, power, beamCurrent=0.0):
        return _CLICopti.AccelStructure_writeProfileFile(self, fname, power, beamCurrent)

    def writeParameterProfileFile(self, fname):
        return _CLICopti.AccelStructure_writeParameterProfileFile(self, fname)

    def getMaxAllowablePower(self, beamCurrent, max_Es, max_Sc):
        return _CLICopti.AccelStructure_getMaxAllowablePower(self, beamCurrent, max_Es, max_Sc)

    def getMaxAllowablePower_beamTimeFixed(self, beamCurrent, beamTime):
        return _CLICopti.AccelStructure_getMaxAllowablePower_beamTimeFixed(self, beamCurrent, beamTime)

    def getMaxAllowableBeamTime_E(self, power, beamCurrent):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_E(self, power, beamCurrent)

    def getMaxAllowableBeamTime_E_hasPeak(self, maxEs, wastedTime):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_E_hasPeak(self, maxEs, wastedTime)

    def getMaxAllowableBeamTime_Sc(self, power, beamCurrent):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_Sc(self, power, beamCurrent)

    def getMaxAllowableBeamTime_Sc_hasPeak(self, maxSc, wastedTime):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_Sc_hasPeak(self, maxSc, wastedTime)

    def getMaxAllowableBeamTime_PC(self, power, beamCurrent):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_PC(self, power, beamCurrent)

    def getMaxAllowableBeamTime_PC_hasPeak(self, maxPC, wastedTime):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_PC_hasPeak(self, maxPC, wastedTime)

    def getMaxAllowableBeamTime(self, power, beamCurrent):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime(self, power, beamCurrent)

    def getMaxAllowableBeamTime_detailed(self, power, beamCurrent_pulseShape, beamCurrent_loading=-1.0, powerFraction=-1.0, BDR=-1.0):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_detailed(self, power, beamCurrent_pulseShape, beamCurrent_loading, powerFraction, BDR)
    uselimit_E = property(_CLICopti.AccelStructure_uselimit_E_get, _CLICopti.AccelStructure_uselimit_E_set)
    uselimit_Sc = property(_CLICopti.AccelStructure_uselimit_Sc_get, _CLICopti.AccelStructure_uselimit_Sc_set)
    uselimit_PC = property(_CLICopti.AccelStructure_uselimit_PC_get, _CLICopti.AccelStructure_uselimit_PC_set)
    uselimit_dT = property(_CLICopti.AccelStructure_uselimit_dT_get, _CLICopti.AccelStructure_uselimit_dT_set)

    def scaleBeamtimeBDR(self, beamtime, BDR):
        return _CLICopti.AccelStructure_scaleBeamtimeBDR(self, beamtime, BDR)

    def getFlattopEfficiency(self, peakPower, beamCurrent):
        r""" Efficiency calculations *"""
        return _CLICopti.AccelStructure_getFlattopEfficiency(self, peakPower, beamCurrent)

    def getTotalEfficiency(self, peakPower, beamCurrent, t_beam):
        return _CLICopti.AccelStructure_getTotalEfficiency(self, peakPower, beamCurrent, t_beam)

    def getBreakoverPower(self, peakPower, beamCurrent):
        r""" Pulse shape *"""
        return _CLICopti.AccelStructure_getBreakoverPower(self, peakPower, beamCurrent)

    def getExtraTimePowerAboveFraction(self, peakPower, beamCurrent, powerFraction=-1.0):
        return _CLICopti.AccelStructure_getExtraTimePowerAboveFraction(self, peakPower, beamCurrent, powerFraction)

    def getDeltaTconst(self, peakPower, t_beam, beamCurrent):
        return _CLICopti.AccelStructure_getDeltaTconst(self, peakPower, t_beam, beamCurrent)

    def getDeltaT(self, peakPower, t_beam, beamCurrent, zIdx, loaded=False, deltaTconst=-1.0):
        return _CLICopti.AccelStructure_getDeltaT(self, peakPower, t_beam, beamCurrent, zIdx, loaded, deltaTconst)

    def getMaxDeltaT(self, peakPower, t_beam, beamCurrent, loaded=True):
        return _CLICopti.AccelStructure_getMaxDeltaT(self, peakPower, t_beam, beamCurrent, loaded)

    def getMaxDeltaT_hasPeak(self, maxHs, deltaTconst):
        return _CLICopti.AccelStructure_getMaxDeltaT_hasPeak(self, maxHs, deltaTconst)

    def writeDeltaTprofileFile(self, fname, peakPower, t_beam, beamCurrent, loaded=False):
        return _CLICopti.AccelStructure_writeDeltaTprofileFile(self, fname, peakPower, t_beam, beamCurrent, loaded)

    def writeTimeDeltaTprofileFile(self, fname, peakPower, t_beam_max, beamCurrent, loaded=False, numPoints=200):
        return _CLICopti.AccelStructure_writeTimeDeltaTprofileFile(self, fname, peakPower, t_beam_max, beamCurrent, loaded, numPoints)

    def writeTimePowerProfileFile(self, fname, peakPower, t_beam, beamCurrent, numPoints=200):
        return _CLICopti.AccelStructure_writeTimePowerProfileFile(self, fname, peakPower, t_beam, beamCurrent, numPoints)

    def getMaxAllowableBeamTime_dT(self, peakPower, beamCurrent, useLoadedField=False):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_dT(self, peakPower, beamCurrent, useLoadedField)

    def getMaxAllowableBeamTime_dT_hasPeak(self, peakPower, beamCurrent, maxHs):
        return _CLICopti.AccelStructure_getMaxAllowableBeamTime_dT_hasPeak(self, peakPower, beamCurrent, maxHs)

    def getP_t(self, t, peakPower, t_beam, beamCurrent, breakoverPower=-1.0):
        return _CLICopti.AccelStructure_getP_t(self, t, peakPower, t_beam, beamCurrent, breakoverPower)

    def getTransverseWakePotential(self, z):
        r"""Wake parameters ** *"""
        return _CLICopti.AccelStructure_getTransverseWakePotential(self, z)

    def getTransverseWakePotentialEnvelope(self, z):
        return _CLICopti.AccelStructure_getTransverseWakePotentialEnvelope(self, z)

    def getTransverseWakePotentialEnvelope_detuning(self, z):
        return _CLICopti.AccelStructure_getTransverseWakePotentialEnvelope_detuning(self, z)

    def getMinBunchSpacing(self, maxKick, detuning=True):
        return _CLICopti.AccelStructure_getMinBunchSpacing(self, maxKick, detuning)

    def writeWakeFile(self, fname, max_z, delta_z):
        return _CLICopti.AccelStructure_writeWakeFile(self, fname, max_z, delta_z)
    N = property(_CLICopti.AccelStructure_N_get)

    def getL(self):
        return _CLICopti.AccelStructure_getL(self)

    def getCellFirstPtr(self):
        r"""
        Return pointers to copy's of the first/mid/last cell.
        If cells has been pruned, return NULL
        """
        return _CLICopti.AccelStructure_getCellFirstPtr(self)

    def getCellMidPtr(self):
        return _CLICopti.AccelStructure_getCellMidPtr(self)

    def getCellLastPtr(self):
        return _CLICopti.AccelStructure_getCellLastPtr(self)

    def getCellFirst(self):
        r"""
        Return read-only references to the first/mid/last cell
        (usefull for printing!)
        """
        return _CLICopti.AccelStructure_getCellFirst(self)

    def getCellMid(self):
        return _CLICopti.AccelStructure_getCellMid(self)

    def getCellLast(self):
        return _CLICopti.AccelStructure_getCellLast(self)

    def pruneCells(self):
        return _CLICopti.AccelStructure_pruneCells(self)

    def createCells(self):
        return _CLICopti.AccelStructure_createCells(self)

    def integral_helper(self, intVar, step, numPoints):
        return _CLICopti.AccelStructure_integral_helper(self, intVar, step, numPoints)

    def getInterpolated(self, z, field_offset, midEnds=False):
        r"""
        Get the interpolated value of a given field at position z.
        if midEnds=true, use middle of end cells as first/last interpolation "anchors".
        """
        return _CLICopti.AccelStructure_getInterpolated(self, z, field_offset, midEnds)

    def getInterpolated_zidx(self, z_idx, field_offset):
        return _CLICopti.AccelStructure_getInterpolated_zidx(self, z_idx, field_offset)

    def getInterpolatedZero(self, field_offset):
        return _CLICopti.AccelStructure_getInterpolatedZero(self, field_offset)

    def interpolate3(self, first, mid, last, z, midEnds=False):
        return _CLICopti.AccelStructure_interpolate3(self, first, mid, last, z, midEnds)

    def needWakePrecalc(self):
        return _CLICopti.AccelStructure_needWakePrecalc(self)

    def populateWakePrecalc(self):
        return _CLICopti.AccelStructure_populateWakePrecalc(self)

# Register AccelStructure in _CLICopti:
_CLICopti.AccelStructure_swigregister(AccelStructure)
AccelStructure.constBDR0 = _CLICopti.cvar.AccelStructure_constBDR0
AccelStructure.constTau0 = _CLICopti.cvar.AccelStructure_constTau0
AccelStructure.maxConstE = _CLICopti.cvar.AccelStructure_maxConstE
AccelStructure.maxConstSc = _CLICopti.cvar.AccelStructure_maxConstSc
AccelStructure.maxConstPC = _CLICopti.cvar.AccelStructure_maxConstPC
AccelStructure.constPulsePowerFraction = _CLICopti.cvar.AccelStructure_constPulsePowerFraction
AccelStructure.max_deltaT = _CLICopti.cvar.AccelStructure_max_deltaT

class AccelStructure_paramSet1(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, cellBase, N, psi, a_n, a_n_delta, d_n, f0_scaleto=-1.0):
        _CLICopti.AccelStructure_paramSet1_swiginit(self, _CLICopti.new_AccelStructure_paramSet1(cellBase, N, psi, a_n, a_n_delta, d_n, f0_scaleto))
    psi_in = property(_CLICopti.AccelStructure_paramSet1_psi_in_get)
    a_n = property(_CLICopti.AccelStructure_paramSet1_a_n_get)
    a_n_delta = property(_CLICopti.AccelStructure_paramSet1_a_n_delta_get)
    d_n = property(_CLICopti.AccelStructure_paramSet1_d_n_get)
    f0_scaleto = property(_CLICopti.AccelStructure_paramSet1_f0_scaleto_get)

    def createCells(self):
        return _CLICopti.AccelStructure_paramSet1_createCells(self)
    __swig_destroy__ = _CLICopti.delete_AccelStructure_paramSet1

# Register AccelStructure_paramSet1 in _CLICopti:
_CLICopti.AccelStructure_paramSet1_swigregister(AccelStructure_paramSet1)
class AccelStructure_paramSet2(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, cellBase, N, psi, a_n, a_n_delta, d_n, d_n_delta, f0_scaleto=-1.0):
        _CLICopti.AccelStructure_paramSet2_swiginit(self, _CLICopti.new_AccelStructure_paramSet2(cellBase, N, psi, a_n, a_n_delta, d_n, d_n_delta, f0_scaleto))
    psi_in = property(_CLICopti.AccelStructure_paramSet2_psi_in_get)
    a_n = property(_CLICopti.AccelStructure_paramSet2_a_n_get)
    a_n_delta = property(_CLICopti.AccelStructure_paramSet2_a_n_delta_get)
    d_n = property(_CLICopti.AccelStructure_paramSet2_d_n_get)
    d_n_delta = property(_CLICopti.AccelStructure_paramSet2_d_n_delta_get)
    f0_scaleto = property(_CLICopti.AccelStructure_paramSet2_f0_scaleto_get)

    def createCells(self):
        return _CLICopti.AccelStructure_paramSet2_createCells(self)
    __swig_destroy__ = _CLICopti.delete_AccelStructure_paramSet2

# Register AccelStructure_paramSet2 in _CLICopti:
_CLICopti.AccelStructure_paramSet2_swigregister(AccelStructure_paramSet2)
class AccelStructure_paramSet2_noPsi(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, cellBase, N, a_n, a_n_delta, d_n, d_n_delta, f0_scaleto=-1.0):
        _CLICopti.AccelStructure_paramSet2_noPsi_swiginit(self, _CLICopti.new_AccelStructure_paramSet2_noPsi(cellBase, N, a_n, a_n_delta, d_n, d_n_delta, f0_scaleto))
    a_n = property(_CLICopti.AccelStructure_paramSet2_noPsi_a_n_get)
    a_n_delta = property(_CLICopti.AccelStructure_paramSet2_noPsi_a_n_delta_get)
    d_n = property(_CLICopti.AccelStructure_paramSet2_noPsi_d_n_get)
    d_n_delta = property(_CLICopti.AccelStructure_paramSet2_noPsi_d_n_delta_get)
    f0_scaleto = property(_CLICopti.AccelStructure_paramSet2_noPsi_f0_scaleto_get)

    def createCells(self):
        return _CLICopti.AccelStructure_paramSet2_noPsi_createCells(self)
    __swig_destroy__ = _CLICopti.delete_AccelStructure_paramSet2_noPsi

# Register AccelStructure_paramSet2_noPsi in _CLICopti:
_CLICopti.AccelStructure_paramSet2_noPsi_swigregister(AccelStructure_paramSet2_noPsi)
class AccelStructure_CLIC502(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, N, f0_scaleto=11.9942):
        _CLICopti.AccelStructure_CLIC502_swiginit(self, _CLICopti.new_AccelStructure_CLIC502(N, f0_scaleto))

    def createCells(self):
        return _CLICopti.AccelStructure_CLIC502_createCells(self)
    f0_scaleto = property(_CLICopti.AccelStructure_CLIC502_f0_scaleto_get)
    __swig_destroy__ = _CLICopti.delete_AccelStructure_CLIC502

# Register AccelStructure_CLIC502 in _CLICopti:
_CLICopti.AccelStructure_CLIC502_swigregister(AccelStructure_CLIC502)
class AccelStructure_CLICG(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, N, isR05=True, f0_scaleto=11.9942):
        _CLICopti.AccelStructure_CLICG_swiginit(self, _CLICopti.new_AccelStructure_CLICG(N, isR05, f0_scaleto))

    def createCells(self):
        return _CLICopti.AccelStructure_CLICG_createCells(self)
    isR05 = property(_CLICopti.AccelStructure_CLICG_isR05_get)
    f0_scaleto = property(_CLICopti.AccelStructure_CLICG_f0_scaleto_get)
    __swig_destroy__ = _CLICopti.delete_AccelStructure_CLICG

# Register AccelStructure_CLICG in _CLICopti:
_CLICopti.AccelStructure_CLICG_swigregister(AccelStructure_CLICG)
class AccelStructure_general(AccelStructure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def createCells(self):
        return _CLICopti.AccelStructure_general_createCells(self)

    @staticmethod
    def copy_structure(*args):
        return _CLICopti.AccelStructure_general_copy_structure(*args)

    def __init__(self, *args):
        _CLICopti.AccelStructure_general_swiginit(self, _CLICopti.new_AccelStructure_general(*args))
    __swig_destroy__ = _CLICopti.delete_AccelStructure_general

# Register AccelStructure_general in _CLICopti:
_CLICopti.AccelStructure_general_swigregister(AccelStructure_general)

