#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This file is part of CLICopti.
#
# Authors: Kyrre Sjobak, Daniel Schulte, Alexej Grudiev, Andrea Latina, Jim Ã–gren
#
# We have invested a lot of time and effort in creating the CLICopti library,
# please cite it when using it; see the CITATION file for more information.
#
# CLICopti is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CLICopti is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with CLICopti.  If not, see <https://www.gnu.org/licenses/>.

#This file imports the members defined in cellBase.h into a separated python module
# (from the "flat" module CLICopti.CLICopti generated by SWIG)

#The base class
from CLICopti.CLICopti import CellBase
#The various interpolators
from CLICopti.CLICopti import \
    CellBase_grid, \
    CellBase_compat, \
    CellBase_linearInterpolation, \
    CellBase_linearInterpolation_freqScaling
#Special data types
from CLICopti.CLICopti import \
    double_array, double_vector,\
    size_t_array, size_t_vector

#Database paths
import os
celldatabase_TD_12GHz_v1 = os.path.join(os.path.dirname(__file__),\
                                        "TD_12GHz_v1.dat")
celldatabase_TD_12GHz_v2 = os.path.join(os.path.dirname(__file__),\
                                        "TD_12GHz_v2.dat")
celldatabase_TD_30GHz    = os.path.join(os.path.dirname(__file__),\
                                        "TD_30GHz.dat")

import numpy as np
import warnings

#Patch the constructors to be Pythonesque
# https://stackoverflow.com/a/19546169

_CellBase_linearInterpolation_CPPconstructor = CellBase_linearInterpolation.__init__
def _CellBase_linearInterpolation_PYconstructor(self,fname,interpolateVariables):
    import CLICopti.CellParams
    offsets = CLICopti.CellParams.getOffsetVector_byString(interpolateVariables)

    _CellBase_linearInterpolation_CPPconstructor(self, fname, offsets)

    #Save the proxy in the created object so that it doesn't go out of scope before the object dies
    self._offsets_proxy = offsets
CellBase_linearInterpolation.__init__ = _CellBase_linearInterpolation_PYconstructor

_CellBase_linearInterpolation_freqScaling_CPPconstructor = CellBase_linearInterpolation_freqScaling.__init__
def _CellBase_linearInterpolation_freqScaling_PYconstructor(self,fname,interpolateVariables,f0):
    import CLICopti.CellParams
    offsets = CLICopti.CellParams.getOffsetVector_byString(interpolateVariables)

    _CellBase_linearInterpolation_freqScaling_CPPconstructor(self, fname, offsets, f0)

    #Save the proxy in the created object so that it doesn't go out of scope before the object dies
    self._offsets_proxy = offsets
CellBase_linearInterpolation_freqScaling.__init__ = _CellBase_linearInterpolation_freqScaling_PYconstructor

_CellBase_compat_CPPconstructor = CellBase_compat.__init__
def _CellBase_compat_PYconstructor(self, fname, f0=29.985, havePhaseAdvance=True, scalingLevel=3):
    #Catch a few errors before calling the real constructor
    if (fname == celldatabase_TD_30GHz) and (havePhaseAdvance != True):
        warnings.warn("For this database file should normally set havePhaseAdvance=True")
    elif (fname == celldatabase_TD_12GHz_v1) and (havePhaseAdvance != False):
        warnings.warn("For this database file should normally set havePhaseAdvance=False")
    elif (fname == celldatabase_TD_12GHz_v2) and (havePhaseAdvance != False):
        warnings.warn("For this database file should normally set havePhaseAdvance=False")
    _CellBase_compat_CPPconstructor(self, fname, f0, havePhaseAdvance, scalingLevel)
CellBase_compat.__init__ = _CellBase_compat_PYconstructor


#Patch the grid idx or coords -> cell loaders
# This is actually generated automatically, but the error messages are
# difficult to understand, and it doesn't handle numpy correctly.
_CellBase_grid_getCellGrid_CPP = CellBase_grid.getCellGrid
def _CellBase_grid_getCellGrid_PY(self,gridIdx):

    numIndices = len(gridIdx)
    if self.numIndices != numIndices:
        raise TypeError(f"CellBase expected {self.numIndices} indices, got {numIndices}")

    from CLICopti.CLICopti import size_t_vector
    offsets = size_t_vector(numIndices)
    for i, idx in enumerate(gridIdx):
        if not isinstance(idx,np.integer) and not isinstance(idx,int):
            raise TypeError(f"gridIdx array must be only ints, got a {type(idx)} in position {i} of array {gridIdx}.")
        offsets[i] = int(idx) #In case of numpy types

    cell = _CellBase_grid_getCellGrid_CPP(self,offsets)
    return cell
CellBase_grid.getCellGrid = _CellBase_grid_getCellGrid_PY

def _doubleArrayConvertTo(iterable):
    "Convert an iterable python object to a SWIG double_array which can be passed to the C++ library"
    array = double_array(len(iterable))
    for i,p in enumerate(iterable):
        if not (np.isscalar(p) and np.isreal(p)):
            raise TypeError(f'gridCoords must consist of an array of real numbers, got:"{p}", typeof:{type(p)}')
        array[i] = p
    return array

def _doubleArrayConvertFrom(array,len):
    """
    Convert a SWIG double_array to a numpy array, given the array and it's length.
    If length is specified wrong, we may access out of bounds and segfault!
    """
    #Can't trust __sizeof__()
    #if array.__sizeof__() != len*8:
    #    raise ValueError("Assuming 8-byte doubles, the len is wrong")
    arr = double_array.frompointer(array)
    r = np.empty(len)
    for i in range(len):
        r[i] = arr[i]
    return r

def _doubleVectorConvertTo(iterable):
    "Convert an iterable python object to a SWIG double_vector"
    vector = double_vector(len(iterable))
    for i, p in enumerate(iterable):
        if not (np.isscalar(p) and np.isreal(p)):
            raise TypeError(f"iterable must be only real numbers, got a {type(p)} in position {i} of array {iterable}.")
        vector[i] = float(p) #In case of numpy types
    return vector

_CellBase_grid_getGridlabels_CPP = CellBase_grid.getGridlabels
def _CellBase_grid_getGridlabels_PY(self,dimension):
    "Return the gridlabels for the given dimension"
    rp = _CellBase_grid_getGridlabels_CPP(self,dimension)
    return np.asarray(rp,float)
CellBase_grid.getGridlabels = _CellBase_grid_getGridlabels_PY

def _CellBase_grid_getGrid_meshgrid_PY(self):
    "Creates a meshgrid corresponding to the underlying grid in the CellBase_grid class"
    ndims = self.numIndices
    labels = []
    for di in range(ndims):
        label=self.getGridlabels(di)
        labels.append(label)
    mg = np.meshgrid(*labels)
    return mg,labels
CellBase_grid.getGrid_meshgrid= _CellBase_grid_getGrid_meshgrid_PY

_CellBase_linearInterpolation_getCellInterpolated_CPP = CellBase_linearInterpolation.getCellInterpolated
def _CellBase_linearInterpolation_getCellInterpolated_PY(self, gridCoords):
    return _CellBase_linearInterpolation_getCellInterpolated_CPP(self, _doubleVectorConvertTo(gridCoords))
CellBase_linearInterpolation.getCellInterpolated = _CellBase_linearInterpolation_getCellInterpolated_PY

_CellBase_linearInterpolation_freqScaling_getCellInterpolated_CPP = CellBase_linearInterpolation_freqScaling.getCellInterpolated
def _CellBase_linearInterpolation_freqScaling_getCellInterpolated_PY(self, gridCoords):
    return _CellBase_linearInterpolation_freqScaling_getCellInterpolated_CPP(self, _doubleVectorConvertTo(gridCoords))
CellBase_linearInterpolation_freqScaling.getCellInterpolated = _CellBase_linearInterpolation_freqScaling_getCellInterpolated_PY

_CellBase_compat_getCellInterpolated_CPP = CellBase_compat.getCellInterpolated
def _CellBase_compat_getCellInterpolated_PY(self, gridCoords):
    return _CellBase_compat_getCellInterpolated_CPP(self, _doubleVectorConvertTo(gridCoords))
CellBase_compat.getCellInterpolated = _CellBase_compat_getCellInterpolated_PY
