"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

import compas_lcmtypes.stdlcm

class image_sync_t(object):
    """
     From the bot_core description:
    image_sync_t is used by libcam plugins to synchronize playback of a libcam
    log file with playback of an LCM log file.
    The expected usage scenario is when an image stream is recorded to a libcam
    log file, and a lcm-syncpub unit is in the libcam chain that publishes
    image_sync_t messages to an LCM network, where they may be logged to the
    an LCM logfile.
    Later, when playing back an LCM log file, the image_sync_t messages can be
    used by a libcam log playback unit to synchronize its playback of the
    libcam log file with the LCM log file.
    The existence of this message type is largely predicated on the notion that
    we may not always want full resolution image data in an LCM log file, and
    may instead store it in a dedicated libcam log file.
    
    """

    __slots__ = ["header", "utime"]

    __typenames__ = ["compas_lcmtypes.stdlcm.header_t", "int64_t"]

    __dimensions__ = [None, None]

    def __init__(self):
        self.header = compas_lcmtypes.stdlcm.header_t()
        """
        Standard header.
        LCM Type: compas_lcmtypes.stdlcm.header_t
        """

        self.utime = 0
        """
        Time since the epoch in microseconds.
        LCM Type: int64_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(image_sync_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        assert self.header._get_packed_fingerprint() == compas_lcmtypes.stdlcm.header_t._get_packed_fingerprint()
        self.header._encode_one(buf)
        buf.write(struct.pack(">q", self.utime))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != image_sync_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return image_sync_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = image_sync_t()
        self.header = compas_lcmtypes.stdlcm.header_t._decode_one(buf)
        self.utime = struct.unpack(">q", buf.read(8))[0]
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if image_sync_t in parents: return 0
        newparents = parents + [image_sync_t]
        tmphash = (0x48b5ff4b7260fb91+ compas_lcmtypes.stdlcm.header_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if image_sync_t._packed_fingerprint is None:
            image_sync_t._packed_fingerprint = struct.pack(">Q", image_sync_t._get_hash_recursive([]))
        return image_sync_t._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", image_sync_t._get_packed_fingerprint())[0]

