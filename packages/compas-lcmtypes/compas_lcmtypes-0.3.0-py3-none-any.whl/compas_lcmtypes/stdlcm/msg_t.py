"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

import compas_lcmtypes.stdlcm

class msg_t(object):

    __slots__ = ["header", "n_bools", "l_bool", "n_ints", "l_int", "n_reals", "l_real", "n_strings", "l_string", "n_bytes", "l_bytes"]

    __typenames__ = ["compas_lcmtypes.stdlcm.header_t", "int16_t", "compas_lcmtypes.stdlcm.bool_entry_t", "int16_t", "compas_lcmtypes.stdlcm.integer_entry_t", "int16_t", "compas_lcmtypes.stdlcm.real_entry_t", "int16_t", "compas_lcmtypes.stdlcm.string_entry_t", "int16_t", "compas_lcmtypes.stdlcm.byte_array_entry_t"]

    __dimensions__ = [None, None, ["n_bools"], None, ["n_ints"], None, ["n_reals"], None, ["n_strings"], None, ["n_bytes"]]

    def __init__(self):
        self.header = compas_lcmtypes.stdlcm.header_t()
        """
        Standard header.
        LCM Type: compas_lcmtypes.stdlcm.header_t
        """

        self.n_bools = 0
        """
        bool type
        LCM Type: int16_t
        """

        self.l_bool = []
        """ LCM Type: compas_lcmtypes.stdlcm.bool_entry_t[n_bools] """
        self.n_ints = 0
        """
        integer type
        LCM Type: int16_t
        """

        self.l_int = []
        """ LCM Type: compas_lcmtypes.stdlcm.integer_entry_t[n_ints] """
        self.n_reals = 0
        """
        double type
        LCM Type: int16_t
        """

        self.l_real = []
        """ LCM Type: compas_lcmtypes.stdlcm.real_entry_t[n_reals] """
        self.n_strings = 0
        """
        string type
        LCM Type: int16_t
        """

        self.l_string = []
        """ LCM Type: compas_lcmtypes.stdlcm.string_entry_t[n_strings] """
        self.n_bytes = 0
        """
        byte array type
        LCM Type: int16_t
        """

        self.l_bytes = []
        """ LCM Type: compas_lcmtypes.stdlcm.byte_array_entry_t[n_bytes] """

    def encode(self):
        buf = BytesIO()
        buf.write(msg_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        assert self.header._get_packed_fingerprint() == compas_lcmtypes.stdlcm.header_t._get_packed_fingerprint()
        self.header._encode_one(buf)
        buf.write(struct.pack(">h", self.n_bools))
        for i0 in range(self.n_bools):
            assert self.l_bool[i0]._get_packed_fingerprint() == compas_lcmtypes.stdlcm.bool_entry_t._get_packed_fingerprint()
            self.l_bool[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.n_ints))
        for i0 in range(self.n_ints):
            assert self.l_int[i0]._get_packed_fingerprint() == compas_lcmtypes.stdlcm.integer_entry_t._get_packed_fingerprint()
            self.l_int[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.n_reals))
        for i0 in range(self.n_reals):
            assert self.l_real[i0]._get_packed_fingerprint() == compas_lcmtypes.stdlcm.real_entry_t._get_packed_fingerprint()
            self.l_real[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.n_strings))
        for i0 in range(self.n_strings):
            assert self.l_string[i0]._get_packed_fingerprint() == compas_lcmtypes.stdlcm.string_entry_t._get_packed_fingerprint()
            self.l_string[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.n_bytes))
        for i0 in range(self.n_bytes):
            assert self.l_bytes[i0]._get_packed_fingerprint() == compas_lcmtypes.stdlcm.byte_array_entry_t._get_packed_fingerprint()
            self.l_bytes[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != msg_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return msg_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = msg_t()
        self.header = compas_lcmtypes.stdlcm.header_t._decode_one(buf)
        self.n_bools = struct.unpack(">h", buf.read(2))[0]
        self.l_bool = []
        for i0 in range(self.n_bools):
            self.l_bool.append(compas_lcmtypes.stdlcm.bool_entry_t._decode_one(buf))
        self.n_ints = struct.unpack(">h", buf.read(2))[0]
        self.l_int = []
        for i0 in range(self.n_ints):
            self.l_int.append(compas_lcmtypes.stdlcm.integer_entry_t._decode_one(buf))
        self.n_reals = struct.unpack(">h", buf.read(2))[0]
        self.l_real = []
        for i0 in range(self.n_reals):
            self.l_real.append(compas_lcmtypes.stdlcm.real_entry_t._decode_one(buf))
        self.n_strings = struct.unpack(">h", buf.read(2))[0]
        self.l_string = []
        for i0 in range(self.n_strings):
            self.l_string.append(compas_lcmtypes.stdlcm.string_entry_t._decode_one(buf))
        self.n_bytes = struct.unpack(">h", buf.read(2))[0]
        self.l_bytes = []
        for i0 in range(self.n_bytes):
            self.l_bytes.append(compas_lcmtypes.stdlcm.byte_array_entry_t._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if msg_t in parents: return 0
        newparents = parents + [msg_t]
        tmphash = (0x4c8a8b3617ce65f5+ compas_lcmtypes.stdlcm.header_t._get_hash_recursive(newparents)+ compas_lcmtypes.stdlcm.bool_entry_t._get_hash_recursive(newparents)+ compas_lcmtypes.stdlcm.integer_entry_t._get_hash_recursive(newparents)+ compas_lcmtypes.stdlcm.real_entry_t._get_hash_recursive(newparents)+ compas_lcmtypes.stdlcm.string_entry_t._get_hash_recursive(newparents)+ compas_lcmtypes.stdlcm.byte_array_entry_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if msg_t._packed_fingerprint is None:
            msg_t._packed_fingerprint = struct.pack(">Q", msg_t._get_hash_recursive([]))
        return msg_t._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", msg_t._get_packed_fingerprint())[0]

