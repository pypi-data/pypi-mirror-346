{"version":3,"file":"487.index.js","mappings":"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","sources":["webpack://lexcube/./src/lexcube-client/src/client/fast-line-segment-map.ts","webpack://lexcube/./node_modules/comlink/dist/esm/comlink.mjs","webpack://lexcube/./src/lexcube-client/src/client/geojson-loader.worker.ts"],"sourcesContent":["\r\nclass FastLineSegmentMap {\r\n    private minValue: number;\r\n    private maxValue: number;\r\n    private binCount: number;\r\n    private binSize: number;\r\n    private tree: number[][];\r\n\r\n    constructor(component: number, bins: number, positions: number[], indices: number[]) {\r\n        // component == 1: Y, component == 2: Z\r\n        this.binCount = bins;\r\n        this.minValue = positions.reduce((prev, curr, i) => i % 3 == component ? Math.min(prev, curr) : prev, Infinity);\r\n        this.maxValue = positions.reduce((prev, curr, i) => i % 3 == component ? Math.max(prev, curr) : prev, -Infinity) + 0.0001;\r\n\r\n        this.binSize = (this.maxValue - this.minValue) / this.binCount;\r\n        this.tree = new Array(this.binCount).fill(0).map(() => []);\r\n\r\n        this.construct(component, indices, positions);\r\n    }\r\n\r\n    static fromObject(obj: any): FastLineSegmentMap {\r\n        const instance = Object.create(FastLineSegmentMap.prototype);\r\n        return Object.assign(instance, obj);\r\n    }\r\n\r\n    private construct(component: number, indices: number[], positions: number[]) {\r\n        for (let p = 0; p < indices.length; p += 2) {\r\n            const p1Index = indices[p] * 3;\r\n            const p2Index = indices[p + 1] * 3;\r\n            const p1BinIndex = Math.floor((positions[p1Index + component] - this.minValue) / this.binSize);\r\n            const p2BinIndex = Math.floor((positions[p2Index + component] - this.minValue) / this.binSize);\r\n            const lowerBinIndex = Math.min(p1BinIndex, p2BinIndex);\r\n            const upperBinIndex = Math.max(p1BinIndex, p2BinIndex);\r\n \r\n            for (let binIndex = lowerBinIndex; binIndex <= upperBinIndex; binIndex++) {\r\n                this.tree[binIndex].push(p1Index / 3, p2Index / 3);\r\n            }\r\n        }\r\n    }\r\n\r\n    getAllIndicesAtValue(value: number) {\r\n        const binIndex = Math.floor((value - this.minValue) / this.binSize);\r\n        return this.tree[binIndex] || [];\r\n    }\r\n}\r\n\r\nexport default FastLineSegmentMap;\r\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import FastLineSegmentMap from \"./fast-line-segment-map\";\r\nimport { expose } from 'comlink';\r\n\r\n\r\nconst parseGeoJSON = async (geoJsonOrUrl: any, segmentMapBins: number) => {\r\n    if (geoJsonOrUrl == null) {\r\n        throw new Error(\"GeoJSON or URL is required\");\r\n    }\r\n    if (geoJsonOrUrl instanceof String || typeof geoJsonOrUrl == \"string\") {\r\n        if (geoJsonOrUrl.startsWith(\"http\") || geoJsonOrUrl.startsWith(\"/\")) {\r\n            const loadedBorders = await fetch(geoJsonOrUrl as string);\r\n            geoJsonOrUrl = await loadedBorders.json();\r\n        } else {\r\n            geoJsonOrUrl = JSON.parse(geoJsonOrUrl as string);\r\n        }\r\n    }\r\n    \r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n\r\n    let polygonsParsed = 0;\r\n    let featuresSkipped = 0;\r\n\r\n    const positionDictionary: { [key: string]: number } = {};\r\n    const lineDictionary: { [key: string]: number } = {};\r\n\r\n    const getPositionIndex = (pixelX: number, pixelY: number): number => {\r\n        const newKey = `${pixelX}-${pixelY}`;\r\n        const readPositionNew = positionDictionary[newKey];\r\n        if (readPositionNew !== undefined) {\r\n            return readPositionNew;\r\n        }\r\n        positionDictionary[newKey] = positions.length / 3;\r\n        positions.push(0, pixelY, -pixelX);\r\n        return positions.length / 3 - 1;\r\n    }\r\n\r\n    // Creates a line between two points if it doesn't already exist, i.e., merge identical lines in the GeoJSON and represent them as a single line\r\n    const makeLine = (index1: number, index2: number) => {\r\n        const newKey = `${Math.min(index1, index2)}-${Math.max(index1, index2)}`;\r\n        const readlineNew = lineDictionary[newKey];\r\n        if (readlineNew !== undefined) {\r\n            return readlineNew;\r\n        }\r\n        lineDictionary[newKey] = indices.length / 2;\r\n        indices.push(index1, index2);\r\n    }\r\n\r\n    const parsePolygon = (polygonCoords: number[][]) => {\r\n        let lastPositionIndex = 0;\r\n        for (let i = 0; i <= polygonCoords.length; i++) {\r\n            const nextPoint = polygonCoords[i % polygonCoords.length];\r\n            const pixelX = nextPoint[0] as number;\r\n            const pixelY = nextPoint[1] as number;\r\n            const thisPositionIndex = getPositionIndex(pixelX, pixelY);\r\n            if (i > 0) {\r\n                makeLine(thisPositionIndex, lastPositionIndex);\r\n            }\r\n            lastPositionIndex = thisPositionIndex;\r\n        }\r\n        polygonsParsed += 1;\r\n    }\r\n\r\n    const parsePoint = (pointCoords: number[]) => {\r\n        // make a little diamond\r\n        const pixelX = pointCoords[0] as number;\r\n        const pixelY = pointCoords[1] as number;\r\n        const p = 0.001;\r\n        positions.push(0, pixelY, -pixelX + p);\r\n        positions.push(0, pixelY + p, -pixelX);\r\n        positions.push(0, pixelY, -pixelX - p);\r\n        positions.push(0, pixelY - p, -pixelX);\r\n\r\n        const startIndex = indices.length / 2;\r\n        indices.push(startIndex, startIndex + 1);\r\n        indices.push(startIndex + 1, startIndex + 2);\r\n        indices.push(startIndex + 2, startIndex + 3);\r\n        indices.push(startIndex + 3, startIndex);\r\n    }\r\n\r\n    const parseLine = (lineCoords: number[][]) => {\r\n        for (let i = 0; i < lineCoords.length - 1; i++) {\r\n            const startCoords = lineCoords[i];\r\n            const endCoords = lineCoords[i + 1];\r\n            const pixelX1 = startCoords[0] as number;\r\n            const pixelY1 = startCoords[1] as number;\r\n            const pixelX2 = endCoords[0] as number;\r\n            const pixelY2 = endCoords[1] as number;\r\n            positions.push(0, pixelY1, -pixelX1);\r\n            positions.push(0, pixelY2, -pixelX2);\r\n            const startIndex = indices.length / 2;\r\n            indices.push(startIndex, startIndex + 1);\r\n        }\r\n    }\r\n\r\n\r\n    for (let feature of geoJsonOrUrl.features) {\r\n        if (feature.geometry.type == \"MultiPolygon\") {\r\n            for (let shape of feature.geometry.coordinates) {\r\n                for (let coords of shape) {\r\n                    parsePolygon(coords as number[][]);\r\n                }\r\n            }\r\n        } else if (feature.geometry.type == \"Polygon\") {\r\n            const coords = feature.geometry.coordinates[0];\r\n            parsePolygon(coords as number[][]);\r\n        } else if (feature.geometry.type == \"Point\") {\r\n            parsePoint(feature.geometry.coordinates as number[]);\r\n        } else if (feature.geometry.type == \"MultiPoint\") {\r\n            for (let point of feature.geometry.coordinates) {\r\n                parsePoint(point as number[]);\r\n            }\r\n        } else if (feature.geometry.type == \"MultiLineString\") {\r\n            for (let line of feature.geometry.coordinates) {\r\n                parseLine(line as number[][]);\r\n            }\r\n        } else if (feature.geometry.type == \"LineString\") {\r\n            parseLine(feature.geometry.coordinates as number[][]);\r\n        } else {\r\n            featuresSkipped += 1;\r\n        }\r\n    }\r\n    \r\n    const lineSegmentMapZ = new FastLineSegmentMap(2, segmentMapBins, positions, indices);\r\n    const lineSegmentMapY = new FastLineSegmentMap(1, segmentMapBins, positions, indices);\r\n\r\n    return { indices: indices, positions: positions, lineSegmentMapY, lineSegmentMapZ };\r\n}\r\n\r\nconst geoJSONWorkerApi = {\r\n    parseGeoJSON\r\n};\r\n\r\nexport type GeoJSONWorkerApi = typeof geoJSONWorkerApi;\r\n\r\nexpose(geoJSONWorkerApi);\r\n\r\n"],"names":["FastLineSegmentMap","constructor","component","bins","positions","indices","this","binCount","minValue","reduce","prev","curr","i","Math","min","Infinity","maxValue","max","binSize","tree","Array","fill","map","construct","fromObject","obj","instance","Object","create","prototype","assign","p","length","p1Index","p2Index","p1BinIndex","floor","p2BinIndex","lowerBinIndex","upperBinIndex","binIndex","push","getAllIndicesAtValue","value","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","proxyTransferHandler","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","start","ep","target","pendingListeners","Map","addEventListener","ev","data","id","resolver","get","delete","createProxy","wrap","transferHandlers","serialized","Error","isError","message","name","stack","globalThis","allowedOrigins","callback","origin","allowedOrigin","RegExp","test","isAllowedOrigin","console","warn","type","path","argumentList","fromWireValue","returnValue","parent","slice","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","r","toString","bind","_thisArg","rawArgumentList","last","processArguments","register","registerProxy","processed","v","arr","concat","handler","serializedValue","msg","random","Number","MAX_SAFE_INTEGER","join","parseGeoJSON","geoJsonOrUrl","segmentMapBins","String","startsWith","loadedBorders","fetch","json","JSON","parse","polygonsParsed","featuresSkipped","positionDictionary","lineDictionary","getPositionIndex","pixelX","pixelY","newKey","readPositionNew","makeLine","index1","index2","readlineNew","parsePolygon","polygonCoords","lastPositionIndex","nextPoint","thisPositionIndex","parsePoint","pointCoords","startIndex","parseLine","lineCoords","startCoords","endCoords","pixelX1","pixelY1","pixelX2","pixelY2","feature","features","geometry","shape","coordinates","coords","point","line","lineSegmentMapZ","lineSegmentMapY"],"sourceRoot":""}