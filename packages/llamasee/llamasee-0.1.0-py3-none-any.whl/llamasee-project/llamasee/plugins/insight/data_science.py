from typing import Dict, Any, List, Optional
from .base_insight_plugin import BaseInsightPlugin as InsightPlugin
from ...utils.trace import TraceManager
from ...core.insight import Insight
from ...schema.comparison import ComparisonResultRow
import uuid
from datetime import datetime
import logging

class DataScienceInsightPlugin(InsightPlugin):
    """
    Base class for data science insight plugins.
    
    This class provides common functionality for data science insights,
    including statistical analysis, trends, anomalies, and differences.
    """
    
    def __init__(self):
        """Initialize the plugin."""
        self.name = "DataScienceInsightPlugin"
        self.version = "1.0.0"
        self.insight_type = "data_science"
        self.trace_manager = TraceManager()
        self.config = {}
        self.description = "Base class for data science insight plugins"
    
    def initialize(self, config: Dict[str, Any]) -> None:
        """
        Initialize the plugin with configuration.
        
        Args:
            config: Configuration dictionary for the plugin
        """
        self.config = config
        if "name" in config:
            self.name = config["name"]
        if "version" in config:
            self.version = config["version"]
        if "description" in config:
            self.description = config["description"]
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """
        Validate the configuration for this plugin.
        
        Args:
            config: Configuration to validate
            
        Returns:
            True if configuration is valid
        """
        # Basic validation - check for required fields
        required_fields = ["name", "version", "description", "insight_type"]
        for field in required_fields:
            if field not in config:
                return False
        return True
    
    def get_name(self) -> str:
        """
        Get the name of the plugin.
        
        Returns:
            Plugin name
        """
        return self.name
    
    def get_description(self) -> str:
        """
        Get the description of the plugin.
        
        Returns:
            Plugin description
        """
        return self.description
    
    def get_version(self) -> str:
        """
        Get the version of the plugin.
        
        Returns:
            Plugin version
        """
        return self.version
    
    def get_capabilities(self) -> Dict[str, Any]:
        """
        Get the capabilities of the plugin.
        
        Returns:
            Dictionary of plugin capabilities
        """
        return {
            "insight_type": self.insight_type,
            "traceability": True,
            "scoring": True,
            "categorization": True
        }
    
    def get_insight_type(self) -> str:
        """
        Get the type of insights generated by this plugin.
        
        Returns:
            Insight type
        """
        return self.insight_type
    
    def create_trace(self, data_indices=None, columns=None, values=None, context=None):
        """
        Create a trace object for this insight.
        
        Args:
            data_indices: Row indices in the original datasets
            columns: Column names
            values: Key-value pairs
            context: Additional context
            
        Returns:
            Dict: Trace object
        """
        return self.trace_manager.create_trace(data_indices, columns, values, context)
    
    def add_dataset_trace(self, trace, dataset, indices=None, columns=None, values=None):
        """
        Add dataset-specific trace information.
        
        Args:
            trace: Trace object
            dataset: Dataset identifier ('dataset_a' or 'dataset_b')
            indices: Row indices
            columns: Column names
            values: Key-value pairs
            
        Returns:
            Dict: Updated trace object
        """
        return self.trace_manager.add_dataset_trace(trace, dataset, indices, columns, values)
    
    def add_dimension_trace(self, trace, dimension_id, dimension_value):
        """
        Add dimension-specific trace information.
        
        Args:
            trace: Trace object
            dimension_id: Dimension identifier
            dimension_value: Dimension value
            
        Returns:
            Dict: Updated trace object
        """
        return self.trace_manager.add_dimension_trace(trace, dimension_id, dimension_value)
    
    def add_comparison_trace(self, trace, comparison_type, comparison_value):
        """
        Add comparison-specific trace information.
        
        Args:
            trace: Trace object
            comparison_type: Comparison type
            comparison_value: Comparison value
            
        Returns:
            Dict: Updated trace object
        """
        return self.trace_manager.add_comparison_trace(trace, comparison_type, comparison_value)
    
    # Implement abstract methods from InsightPlugin
    def generate_insights(
        self, 
        comparison_results: Dict[str, Any], 
        context: Optional[Dict[str, Any]] = None,
        top_n: Optional[int] = None,
        fact_type: Optional[str] = None
    ) -> List[Insight]:
        """
        Generate insights from comparison results using data science techniques.
        
        Args:
            comparison_results: Results from a comparison operation
            context: Optional context information for insight generation
            top_n: Optional limit on the number of insights to return
            fact_type: Optional fact type to filter insights by (e.g., "forecast_value_p50")
            
        Returns:
            List of generated insights
        """
        insights = []
        
        # Filter comparison results by fact type if provided
        if fact_type:
            comparison_results = {
                k: v for k, v in comparison_results.items() 
                if isinstance(v, ComparisonResultRow) and v.fact_type == fact_type
            }
        
        # Check if comparison_results is valid
        if not comparison_results or not isinstance(comparison_results, dict):
            return insights
        
        # Create a basic insight about the comparison
        insight_id = str(uuid.uuid4())
        insight_description = "This is a basic data science insight generated by the DataScienceInsightPlugin."
        insight_score = 0.5
        source_data = comparison_results
        
        # Create an Insight object
        insight = Insight(
            id=insight_id,
            description=insight_description,
            importance_score=insight_score,
            source_data=source_data
        )
        
        # Set type attributes - ensure both type and insight_type are set for compatibility
        insight.type = "data_science"  # Set type attribute
        insight.insight_type = "data_science"  # Keep insight_type for backward compatibility
        insight.insight_subtype = "statistical"
        
        # Set scope attributes - ensure both scope and scope_level are set for compatibility
        insight.scope = "aggregate"  # Set scope attribute
        insight.scope_level = "aggregate"  # Keep scope_level for backward compatibility
        
        insight.trace = self.create_trace()
        insight.metadata = {
            "source": "DataScienceInsightPlugin",
            "generation_time": datetime.now().isoformat()
        }
        
        insights.append(insight)
        
        # Apply limit if specified
        if top_n is not None and top_n > 0:
            insights = insights[:top_n]
        
        return insights
    
    def enhance_insights(self, insights, context=None):
        """
        Enhance existing insights with additional information.
        
        Args:
            insights: List of insights to enhance
            context: Optional context information for enhancement
            
        Returns:
            List of enhanced insights
        """
        enhanced_insights = []
        
        for insight in insights:
            # Check if insight has a trace
            if not hasattr(insight, 'trace') or insight.trace is None:
                insight.trace = self.create_trace()
            
            # Add additional metadata
            if not hasattr(insight, 'metadata'):
                insight.metadata = {}
            
            insight.metadata.update({
                "enhanced_by": "DataScienceInsightPlugin",
                "enhancement_time": datetime.now().isoformat()
            })
            
            enhanced_insights.append(insight)
        
        return enhanced_insights
    
    def categorize_insights(self, insights):
        """
        Categorize insights into different types.
        
        Args:
            insights: List of insights to categorize
            
        Returns:
            Dictionary mapping categories to lists of insights
        """
        categories = {
            "data_quality": [],
            "data_patterns": [],
            "statistical": [],
            "other": []
        }
        
        for insight in insights:
            # Check if insight has a category
            if hasattr(insight, 'category') and insight.category in categories:
                categories[insight.category].append(insight)
            else:
                # Try to determine category from insight type
                if hasattr(insight, 'insight_type'):
                    if 'quality' in insight.insight_type.lower():
                        categories['data_quality'].append(insight)
                    elif 'pattern' in insight.insight_type.lower():
                        categories['data_patterns'].append(insight)
                    elif 'statistical' in insight.insight_type.lower():
                        categories['statistical'].append(insight)
                    else:
                        categories['other'].append(insight)
                else:
                    categories['other'].append(insight)
        
        return categories
    
    def score_insights(self, insights):
        """
        Score insights based on various factors.
        
        Args:
            insights: List of insights to score
            
        Returns:
            List of insights with scores added to metadata
        """
        scored_insights = []
        
        for insight in insights:
            # Initialize score components
            relevance_score = 0.0
            confidence_score = 0.0
            impact_score = 0.0
            
            # Score based on insight type
            if hasattr(insight, 'insight_type'):
                if 'quality' in insight.insight_type.lower():
                    relevance_score += 0.8
                elif 'pattern' in insight.insight_type.lower():
                    relevance_score += 0.9
                elif 'statistical' in insight.insight_type.lower():
                    relevance_score += 0.7
            
            # Score based on traceability
            if hasattr(insight, 'trace') and insight.trace:
                confidence_score += 0.5
            
            # Score based on metadata
            if hasattr(insight, 'metadata'):
                if 'confidence' in insight.metadata:
                    confidence_score += float(insight.metadata['confidence'])
                if 'impact' in insight.metadata:
                    impact_score += float(insight.metadata['impact'])
            
            # Calculate final score
            final_score = (relevance_score + confidence_score + impact_score) / 3.0
            
            # Ensure metadata exists
            if not hasattr(insight, 'metadata'):
                insight.metadata = {}
            
            # Add scores to metadata
            insight.metadata['relevance_score'] = relevance_score
            insight.metadata['confidence_score'] = confidence_score
            insight.metadata['impact_score'] = impact_score
            insight.metadata['final_score'] = final_score
            
            scored_insights.append(insight)
        
        return scored_insights
    
    def get_insight_types(self):
        """
        Get the types of insights supported by this plugin.
        
        Returns:
            List of supported insight types
        """
        return [self.insight_type]
    
    def get_insight_categories(self):
        """
        Get the categories of insights supported by this plugin.
        
        Returns:
            List of supported insight categories
        """
        return ["statistical", "trend", "anomaly", "difference"]
    
    def get_scoring_factors(self):
        """
        Get the factors used for scoring insights by this plugin.
        
        Returns:
            List of scoring factors
        """
        return ["importance_score", "scope_level", "statistical_significance"]
