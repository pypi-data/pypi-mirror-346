# src/core/package_management.py
import os
import subprocess
from .exceptions import (
    RequirementsFileError, PackageInstallationError, ScriptExecutionError
)
from .config import DEFAULT_REQUIREMENTS_FILE

def append_requirement(module_name, save_reqs_flag=True, requirements_file_name=DEFAULT_REQUIREMENTS_FILE):
    """
    Appends a module name to the requirements file if it's not already present.
    Raises:
        RequirementsFileError: If there are issues reading or writing the requirements file.
    """
    if not save_reqs_flag:
        return

    if not os.path.exists(requirements_file_name):
        try:
            with open(requirements_file_name, "w") as f:
                f.write("# Auto-generated by pyenvrunner\n") # Add a header
            print(f"Created {requirements_file_name}.")
        except IOError as e:
            raise RequirementsFileError(f"Error creating {requirements_file_name}: {e}")

    try:
        with open(requirements_file_name, "r") as f:
            # More robust parsing for module names (handles versions, comments, etc.)
            existing_modules = set()
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                # Basic parsing: take content before '==', '>=', '<=', '>', '<', '~=', ' @'
                for specifier in ['==', '>=', '<=', '>', '<', '~=', ' @']:
                    if specifier in line:
                        line = line.split(specifier)[0]
                        break
                existing_modules.add(line.strip())

    except IOError as e:
        raise RequirementsFileError(f"Error reading {requirements_file_name}: {e}")

    # Normalize module name for comparison (e.g., if module_name might have version specifier)
    normalized_module_name = module_name.split('==')[0].split('>=')[0].split('<=')[0].split('>')[0].split('<')[0].split('~=')[0].split(' @')[0].strip()

    if normalized_module_name not in existing_modules:
        try:
            with open(requirements_file_name, "a") as f:
                f.write(f"{module_name}\n")
            print(f"Added {module_name} to {requirements_file_name}.")
        except IOError as e:
            raise RequirementsFileError(f"Error writing to {requirements_file_name}: {e}")

def install_missing_packages(
    script_path,
    import_to_package_map,
    venv_python_executable,
    venv_pip_command_list,
    save_requirements_flag,
    requirements_file_name=DEFAULT_REQUIREMENTS_FILE
):
    """
    Runs the target script, detects ModuleNotFoundError, installs missing packages, and retries.
    Raises:
        ScriptExecutionError: If the script fails for reasons other than ModuleNotFoundError or if parsing fails.
        PackageInstallationError: If pip install fails.
        FileNotFoundError: If script_path or venv_python_executable is not found (should be caught by caller).
    """
    while True:
        print(f"\n--- Running script: {script_path} using {venv_python_executable} ---")
        try:
            script_result = subprocess.run(
                [venv_python_executable, script_path],
                capture_output=True, text=True, check=False
            )
        except FileNotFoundError:
            raise ScriptExecutionError(
                f"Script not found: {script_path} or Python executable not found: {venv_python_executable}"
            )


        if script_result.stdout:
            print("--- Script STDOUT ---")
            print(script_result.stdout.strip())
            print("---------------------")
        if script_result.stderr:
            print("--- Script STDERR ---")
            print(script_result.stderr.strip())
            print("---------------------")

        if script_result.returncode != 0 and "ModuleNotFoundError: No module named" in script_result.stderr:
            try:
                missing_module_token = "ModuleNotFoundError: No module named"
                # Find the part after "No module named" and strip quotes/spaces
                missing_module_part = script_result.stderr.split(missing_module_token)[-1]
                missing_module = missing_module_part.strip().split()[0].strip("'\"") # Get first word after token
            except IndexError:
                raise ScriptExecutionError("Could not parse missing module name from stderr.")

            install_module = import_to_package_map.get(missing_module, missing_module)
            print(f"\n>>> Detected missing module: '{missing_module}'. Attempting to install '{install_module}'...")

            try:
                pip_command_to_run = venv_pip_command_list + ["install", install_module]
                install_result = subprocess.run(
                    pip_command_to_run, check=True, capture_output=True, text=True
                )
                print(f"--- pip install STDOUT for {install_module} ---")
                print(install_result.stdout.strip())
                print("-------------------------------------")
                if install_result.stderr:
                    print(f"--- pip install STDERR for {install_module} ---")
                    print(install_result.stderr.strip())
                    print("-------------------------------------")

                append_requirement(install_module, save_requirements_flag, requirements_file_name)
                print(f">>> Installation of {install_module} successful. Retrying script...")

            except subprocess.CalledProcessError as e:
                pip_cmd_str = ' '.join(venv_pip_command_list)
                stderr_msg = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
                raise PackageInstallationError(
                    f"Error installing module {install_module} using '{pip_cmd_str}': {e}{stderr_msg}"
                )
            except FileNotFoundError:
                pip_cmd_str = ' '.join(venv_pip_command_list)
                raise PackageInstallationError(
                    f"pip command '{pip_cmd_str}' or its components not found."
                )

        elif script_result.returncode != 0:
            print(f"\n--- Script {script_path} failed with return code {script_result.returncode} (Not a ModuleNotFoundError) ---")
            # Optionally, raise an exception here if any non-zero exit is an error
            # raise ScriptExecutionError(f"Script failed with code {script_result.returncode}")
            break
        else:
            print(f"\n--- Script {script_path} completed successfully ---")
            break


def clear_environment_packages(pip_command_list, no_confirm=False):
    """
    Removes all non-editable installed packages from the environment.
    Raises:
        PackageInstallationError: If pip commands fail.
    """
    pip_cmd_str = ' '.join(pip_command_list)
    print(f"Attempting to clear packages from environment using pip: {pip_cmd_str}")
    try:
        freeze_command = pip_command_list + ["freeze"]
        freeze_result = subprocess.run(
            freeze_command,
            capture_output=True, text=True, check=True
        )

        installed_packages_lines = freeze_result.stdout.strip().splitlines()
        installed_packages = []
        for line in installed_packages_lines:
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('-e '): # Skip comments, empty lines, editable installs
                continue
            # Get package name before '==' or ' @ '
            if '==' in line:
                pkg_name = line.split('==')[0]
                installed_packages.append(pkg_name)
            elif ' @ ' in line: # For file path installs
                pkg_name = line.split(' @ ')[0]
                installed_packages.append(pkg_name)
            # else: could be a direct URL or other format, decide if you want to handle

        if not installed_packages:
            print("No packages to remove from this environment (or only editable installs found).")
            return

        print(f"Found packages to remove: {', '.join(installed_packages)}")

        if not no_confirm:
            try:
                user_confirmation = input("Are you sure you want to uninstall these packages? (y/N): ")
            except EOFError: # Non-interactive environment
                print("Non-interactive environment detected, cannot confirm. Aborting package clearing.")
                print("Use the appropriate flag for non-interactive clearing if available.")
                return # Or raise an error
            if user_confirmation.lower() != 'y':
                print("Package clearing cancelled by user.")
                return

        uninstall_command = pip_command_list + ["uninstall", "-y"] + installed_packages

        print(f"Running: {' '.join(uninstall_command)}")
        uninstall_result = subprocess.run(
            uninstall_command,
            capture_output=True, text=True, check=False # Check False to see output even on error
        )
        print("--- pip uninstall STDOUT ---")
        print(uninstall_result.stdout.strip())
        print("----------------------------")
        if uninstall_result.stderr:
            print("--- pip uninstall STDERR ---")
            print(uninstall_result.stderr.strip())
            print("----------------------------")

        if uninstall_result.returncode == 0:
            print("Environment packages cleared successfully.")
        else:
            # Don't raise an error here, as pip uninstall might partially succeed
            print("Error or partial success during package clearing. Check output above.")

    except subprocess.CalledProcessError as e:
        stderr_msg = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
        stdout_msg = f"\nStdout: {e.stdout.strip()}" if e.stdout else ""
        raise PackageInstallationError(
            f"Error during environment clearing: {e}. Command: {' '.join(e.cmd)}{stdout_msg}{stderr_msg}"
        )
    except FileNotFoundError:
        raise PackageInstallationError(
            f"pip command '{pip_cmd_str}' or its components not found for clearing environment."
        )