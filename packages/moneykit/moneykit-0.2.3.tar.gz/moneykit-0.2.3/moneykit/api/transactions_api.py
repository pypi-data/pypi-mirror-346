# coding: utf-8

"""
MoneyKit API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 2023-02-18
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from typing_extensions import Annotated
from datetime import date


from moneykit.models.api_public_transactions_get_transactions_response import (
    ApiPublicTransactionsGetTransactionsResponse,
)
from moneykit.models.api_public_transactions_legacy_get_transactions_response import (
    ApiPublicTransactionsLegacyGetTransactionsResponse,
)
from moneykit.models.bud_category import BudCategory
from moneykit.models.get_user_transactions_response import GetUserTransactionsResponse
from moneykit.models.transaction_sync_response import TransactionSyncResponse
from moneykit.models.transaction_type_filter import TransactionTypeFilter

from moneykit.api_client import ApiClient
from moneykit.api_response import ApiResponse
from moneykit.rest import RESTResponseType


class TransactionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def correct_enrichment(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        txn_id: StrictStr,
        bud_category: BudCategory,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiPublicTransactionsGetTransactionsResponse:
        """/links/{id}/transactions/{txn_id}/enrichment

        Manually update the enrichment categories for a specific transaction.     The transaction will be updated with your corrections, which are then used to refine future categorizations.     This endpoint returns the updated transaction, along with similar past transactions, using the same format as when retrieving transactions for a link.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param txn_id: (required)
        :type txn_id: str
        :param bud_category: (required)
        :type bud_category: BudCategory
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._correct_enrichment_serialize(
            id=id,
            txn_id=txn_id,
            bud_category=bud_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsGetTransactionsResponse",
            "401": "Response401CorrectEnrichmentLinksIdTransactionsTxnIdEnrichmentPost",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def correct_enrichment_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        txn_id: StrictStr,
        bud_category: BudCategory,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiPublicTransactionsGetTransactionsResponse]:
        """/links/{id}/transactions/{txn_id}/enrichment

        Manually update the enrichment categories for a specific transaction.     The transaction will be updated with your corrections, which are then used to refine future categorizations.     This endpoint returns the updated transaction, along with similar past transactions, using the same format as when retrieving transactions for a link.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param txn_id: (required)
        :type txn_id: str
        :param bud_category: (required)
        :type bud_category: BudCategory
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._correct_enrichment_serialize(
            id=id,
            txn_id=txn_id,
            bud_category=bud_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsGetTransactionsResponse",
            "401": "Response401CorrectEnrichmentLinksIdTransactionsTxnIdEnrichmentPost",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def correct_enrichment_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        txn_id: StrictStr,
        bud_category: BudCategory,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """/links/{id}/transactions/{txn_id}/enrichment

        Manually update the enrichment categories for a specific transaction.     The transaction will be updated with your corrections, which are then used to refine future categorizations.     This endpoint returns the updated transaction, along with similar past transactions, using the same format as when retrieving transactions for a link.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param txn_id: (required)
        :type txn_id: str
        :param bud_category: (required)
        :type bud_category: BudCategory
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._correct_enrichment_serialize(
            id=id,
            txn_id=txn_id,
            bud_category=bud_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsGetTransactionsResponse",
            "401": "Response401CorrectEnrichmentLinksIdTransactionsTxnIdEnrichmentPost",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _correct_enrichment_serialize(
        self,
        id,
        txn_id,
        bud_category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        if txn_id is not None:
            _path_params["txn_id"] = txn_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bud_category is not None:
            _body_params = bud_category

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["OAuth2ClientCredentials"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/links/{id}/transactions/{txn_id}/enrichment",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_transactions(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        account_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="An optional list of account IDs to filter the results."),
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiPublicTransactionsLegacyGetTransactionsResponse:
        """/links/{id}/transactions

        Returns transactions for the accounts associated with a <a href=#tag/Links>link</a>.  Results are     paginated, and returned in reverse chronological order.     <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns     transactions that have already been fetched, either because `prefetch` was requested when the link was created,     or because of scheduled or on-demand updates.     <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the     update frequency can vary, depending on the downstream data provider, the institution, and whether one or both     provide webhook-based updates.  **To force a check for updated transactions, you can use the     <a href=#operation/refresh_products>/products</a> endpoint.**     <p>If you have requested prefetch or an on-demand update, you should check the `refreshed_at` date     for this product in the returned response, and compare that against the previous `refreshed_at` date, which you can     get from any previous response for this or any other account or link request.  If the refreshed_at date has not     increased, then updated data is not yet available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param account_ids: An optional list of account IDs to filter the results.
        :type account_ids: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_serialize(
            id=id,
            account_ids=account_ids,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsLegacyGetTransactionsResponse",
            "401": "Response401GetTransactions",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_transactions_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        account_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="An optional list of account IDs to filter the results."),
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiPublicTransactionsLegacyGetTransactionsResponse]:
        """/links/{id}/transactions

        Returns transactions for the accounts associated with a <a href=#tag/Links>link</a>.  Results are     paginated, and returned in reverse chronological order.     <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns     transactions that have already been fetched, either because `prefetch` was requested when the link was created,     or because of scheduled or on-demand updates.     <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the     update frequency can vary, depending on the downstream data provider, the institution, and whether one or both     provide webhook-based updates.  **To force a check for updated transactions, you can use the     <a href=#operation/refresh_products>/products</a> endpoint.**     <p>If you have requested prefetch or an on-demand update, you should check the `refreshed_at` date     for this product in the returned response, and compare that against the previous `refreshed_at` date, which you can     get from any previous response for this or any other account or link request.  If the refreshed_at date has not     increased, then updated data is not yet available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param account_ids: An optional list of account IDs to filter the results.
        :type account_ids: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_serialize(
            id=id,
            account_ids=account_ids,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsLegacyGetTransactionsResponse",
            "401": "Response401GetTransactions",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_transactions_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        account_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="An optional list of account IDs to filter the results."),
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """/links/{id}/transactions

        Returns transactions for the accounts associated with a <a href=#tag/Links>link</a>.  Results are     paginated, and returned in reverse chronological order.     <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns     transactions that have already been fetched, either because `prefetch` was requested when the link was created,     or because of scheduled or on-demand updates.     <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the     update frequency can vary, depending on the downstream data provider, the institution, and whether one or both     provide webhook-based updates.  **To force a check for updated transactions, you can use the     <a href=#operation/refresh_products>/products</a> endpoint.**     <p>If you have requested prefetch or an on-demand update, you should check the `refreshed_at` date     for this product in the returned response, and compare that against the previous `refreshed_at` date, which you can     get from any previous response for this or any other account or link request.  If the refreshed_at date has not     increased, then updated data is not yet available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param account_ids: An optional list of account IDs to filter the results.
        :type account_ids: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_serialize(
            id=id,
            account_ids=account_ids,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApiPublicTransactionsLegacyGetTransactionsResponse",
            "401": "Response401GetTransactions",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_transactions_serialize(
        self,
        id,
        account_ids,
        page,
        size,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "account_ids": "multi",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if account_ids is not None:
            _query_params.append(("account_ids", account_ids))

        if page is not None:
            _query_params.append(("page", page))

        if size is not None:
            _query_params.append(("size", size))

        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2ClientCredentials"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/links/{id}/transactions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_transactions_sync(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        cursor: Annotated[
            Optional[StrictStr],
            Field(
                description="A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors."
            ),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=500, strict=True, ge=1)]],
            Field(description="The number of items to return."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TransactionSyncResponse:
        """/links/{id}/transactions/sync

        Provides a paginated feed of transactions, grouped into `created`, `updated`, and `removed` lists.         <p>Each call will also return a `cursor.next` value.  In subsequent calls, include that value to receive         only changes that have occurred since the previous call.  **Note** that these lists are **unordered**,         so it is possible to get transactions with dates that precede those you've fetched in previous calls to this         endpoint.  Older transactions can be added, for example, when historical data becomes accessible later.         <p>**Pending** transactions will only be reported as `created`.  Pending transactions are completely         removed and replaced with each transaction refresh or update; no attempt is made to track their removal or         modification.  Pending transactions will **not** be reported in the `removed` list.  If you store         pending transactions, you should remove and replace them entirely each time you fetch new transactions.         <p>Large numbers of transactions will be paginated, and the `has_more` field will be true.  You should         continue calling this endpoint with each new `cursor.next` value until `has_more` is false.         <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns         transactions that have already been fetched, either because `prefetch` was requested when the link was created,         or because of scheduled or on-demand updates.         <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the         update frequency can vary, depending on the downstream data provider, the institution, and whether one or both         provide webhook-based updates.         **To force a check for updated transactions, you can use the <a href=#operation/refresh_products>/products</a> endpoint.**         <p>Note also that the `transactions.updates_available` webhook will alert you when new data is available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param cursor: A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors.
        :type cursor: str
        :param size: The number of items to return.
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_sync_serialize(
            id=id,
            cursor=cursor,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "TransactionSyncResponse",
            "401": "Response401GetTransactionsSyncLinksIdTransactionsSyncGet",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_transactions_sync_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        cursor: Annotated[
            Optional[StrictStr],
            Field(
                description="A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors."
            ),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=500, strict=True, ge=1)]],
            Field(description="The number of items to return."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TransactionSyncResponse]:
        """/links/{id}/transactions/sync

        Provides a paginated feed of transactions, grouped into `created`, `updated`, and `removed` lists.         <p>Each call will also return a `cursor.next` value.  In subsequent calls, include that value to receive         only changes that have occurred since the previous call.  **Note** that these lists are **unordered**,         so it is possible to get transactions with dates that precede those you've fetched in previous calls to this         endpoint.  Older transactions can be added, for example, when historical data becomes accessible later.         <p>**Pending** transactions will only be reported as `created`.  Pending transactions are completely         removed and replaced with each transaction refresh or update; no attempt is made to track their removal or         modification.  Pending transactions will **not** be reported in the `removed` list.  If you store         pending transactions, you should remove and replace them entirely each time you fetch new transactions.         <p>Large numbers of transactions will be paginated, and the `has_more` field will be true.  You should         continue calling this endpoint with each new `cursor.next` value until `has_more` is false.         <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns         transactions that have already been fetched, either because `prefetch` was requested when the link was created,         or because of scheduled or on-demand updates.         <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the         update frequency can vary, depending on the downstream data provider, the institution, and whether one or both         provide webhook-based updates.         **To force a check for updated transactions, you can use the <a href=#operation/refresh_products>/products</a> endpoint.**         <p>Note also that the `transactions.updates_available` webhook will alert you when new data is available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param cursor: A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors.
        :type cursor: str
        :param size: The number of items to return.
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_sync_serialize(
            id=id,
            cursor=cursor,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "TransactionSyncResponse",
            "401": "Response401GetTransactionsSyncLinksIdTransactionsSyncGet",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_transactions_sync_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The unique ID for this link.")],
        cursor: Annotated[
            Optional[StrictStr],
            Field(
                description="A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors."
            ),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=500, strict=True, ge=1)]],
            Field(description="The number of items to return."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """/links/{id}/transactions/sync

        Provides a paginated feed of transactions, grouped into `created`, `updated`, and `removed` lists.         <p>Each call will also return a `cursor.next` value.  In subsequent calls, include that value to receive         only changes that have occurred since the previous call.  **Note** that these lists are **unordered**,         so it is possible to get transactions with dates that precede those you've fetched in previous calls to this         endpoint.  Older transactions can be added, for example, when historical data becomes accessible later.         <p>**Pending** transactions will only be reported as `created`.  Pending transactions are completely         removed and replaced with each transaction refresh or update; no attempt is made to track their removal or         modification.  Pending transactions will **not** be reported in the `removed` list.  If you store         pending transactions, you should remove and replace them entirely each time you fetch new transactions.         <p>Large numbers of transactions will be paginated, and the `has_more` field will be true.  You should         continue calling this endpoint with each new `cursor.next` value until `has_more` is false.         <p>**Note** that this endpoint does **not** trigger a fetch of transactions from the institution; it merely returns         transactions that have already been fetched, either because `prefetch` was requested when the link was created,         or because of scheduled or on-demand updates.         <p>MoneyKit checks for updated account data, including transactions, periodically throughout the day, but the         update frequency can vary, depending on the downstream data provider, the institution, and whether one or both         provide webhook-based updates.         **To force a check for updated transactions, you can use the <a href=#operation/refresh_products>/products</a> endpoint.**         <p>Note also that the `transactions.updates_available` webhook will alert you when new data is available.

        :param id: The unique ID for this link. (required)
        :type id: str
        :param cursor: A cursor value representing the last update requested. If included, the response will only return         changes after this update. If omitted, a complete history of updates will be returned. This value must be stored         by the client as we do not keep track of app cursors.
        :type cursor: str
        :param size: The number of items to return.
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_transactions_sync_serialize(
            id=id,
            cursor=cursor,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "TransactionSyncResponse",
            "401": "Response401GetTransactionsSyncLinksIdTransactionsSyncGet",
            "429": "APIErrorRateLimitExceededResponse",
            "404": "LinkErrorNotFoundResponse",
            "403": "LinkErrorForbiddenActionResponse",
            "410": "LinkErrorDeletedResponse",
            "422": "LinkErrorBadStateResponse",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_transactions_sync_serialize(
        self,
        id,
        cursor,
        size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if cursor is not None:
            _query_params.append(("cursor", cursor))

        if size is not None:
            _query_params.append(("size", size))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2ClientCredentials"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/links/{id}/transactions/sync",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_user_transactions(
        self,
        id: Annotated[
            StrictStr,
            Field(
                description="The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user."
            ),
        ],
        transaction_type: Annotated[
            Optional[List[TransactionTypeFilter]],
            Field(description="DEPRECATED; ignored"),
        ] = None,
        category: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        account_id: Annotated[
            Optional[List[Annotated[str, Field(min_length=1, strict=True)]]],
            Field(
                description="If present, filters results to transactions in accounts matching the given IDs."
            ),
        ] = None,
        institution_id: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetUserTransactionsResponse:
        """/users/{id}/transactions

        Fetches transactions for a <a href=#operation/get_user_accounts>user</a>.     <p>This endpoint fetches all transactions for a user across all of their links.  You can use it to retrieve     transactions from any or all accounts at once, regardless of which institution they belong to.

        :param id: The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user. (required)
        :type id: str
        :param transaction_type: DEPRECATED; ignored
        :type transaction_type: List[TransactionTypeFilter]
        :param category: DEPRECATED; ignored
        :type category: List[str]
        :param account_id: If present, filters results to transactions in accounts matching the given IDs.
        :type account_id: List[str]
        :param institution_id: DEPRECATED; ignored
        :type institution_id: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_user_transactions_serialize(
            id=id,
            transaction_type=transaction_type,
            category=category,
            account_id=account_id,
            institution_id=institution_id,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetUserTransactionsResponse",
            "401": "Response401GetUserTransactions",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_user_transactions_with_http_info(
        self,
        id: Annotated[
            StrictStr,
            Field(
                description="The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user."
            ),
        ],
        transaction_type: Annotated[
            Optional[List[TransactionTypeFilter]],
            Field(description="DEPRECATED; ignored"),
        ] = None,
        category: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        account_id: Annotated[
            Optional[List[Annotated[str, Field(min_length=1, strict=True)]]],
            Field(
                description="If present, filters results to transactions in accounts matching the given IDs."
            ),
        ] = None,
        institution_id: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetUserTransactionsResponse]:
        """/users/{id}/transactions

        Fetches transactions for a <a href=#operation/get_user_accounts>user</a>.     <p>This endpoint fetches all transactions for a user across all of their links.  You can use it to retrieve     transactions from any or all accounts at once, regardless of which institution they belong to.

        :param id: The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user. (required)
        :type id: str
        :param transaction_type: DEPRECATED; ignored
        :type transaction_type: List[TransactionTypeFilter]
        :param category: DEPRECATED; ignored
        :type category: List[str]
        :param account_id: If present, filters results to transactions in accounts matching the given IDs.
        :type account_id: List[str]
        :param institution_id: DEPRECATED; ignored
        :type institution_id: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_user_transactions_serialize(
            id=id,
            transaction_type=transaction_type,
            category=category,
            account_id=account_id,
            institution_id=institution_id,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetUserTransactionsResponse",
            "401": "Response401GetUserTransactions",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_user_transactions_without_preload_content(
        self,
        id: Annotated[
            StrictStr,
            Field(
                description="The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user."
            ),
        ],
        transaction_type: Annotated[
            Optional[List[TransactionTypeFilter]],
            Field(description="DEPRECATED; ignored"),
        ] = None,
        category: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        account_id: Annotated[
            Optional[List[Annotated[str, Field(min_length=1, strict=True)]]],
            Field(
                description="If present, filters results to transactions in accounts matching the given IDs."
            ),
        ] = None,
        institution_id: Annotated[
            Optional[List[StrictStr]], Field(description="DEPRECATED; ignored")
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=1)]],
            Field(description="The page number to return."),
        ] = None,
        size: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="The number of items to return per page."),
        ] = None,
        start_date: Annotated[
            Optional[date],
            Field(
                description="The earliest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        end_date: Annotated[
            Optional[date],
            Field(
                description="The latest date for which data should be returned, formatted as YYYY-MM-DD."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """/users/{id}/transactions

        Fetches transactions for a <a href=#operation/get_user_accounts>user</a>.     <p>This endpoint fetches all transactions for a user across all of their links.  You can use it to retrieve     transactions from any or all accounts at once, regardless of which institution they belong to.

        :param id: The unique ID for this user.  This is the same ID provided         in the call to <a href=/api/operation/create_link_session#customer_user-id>link-session</a> to create a link for this user. (required)
        :type id: str
        :param transaction_type: DEPRECATED; ignored
        :type transaction_type: List[TransactionTypeFilter]
        :param category: DEPRECATED; ignored
        :type category: List[str]
        :param account_id: If present, filters results to transactions in accounts matching the given IDs.
        :type account_id: List[str]
        :param institution_id: DEPRECATED; ignored
        :type institution_id: List[str]
        :param page: The page number to return.
        :type page: int
        :param size: The number of items to return per page.
        :type size: int
        :param start_date: The earliest date for which data should be returned, formatted as YYYY-MM-DD.
        :type start_date: date
        :param end_date: The latest date for which data should be returned, formatted as YYYY-MM-DD.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_user_transactions_serialize(
            id=id,
            transaction_type=transaction_type,
            category=category,
            account_id=account_id,
            institution_id=institution_id,
            page=page,
            size=size,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetUserTransactionsResponse",
            "401": "Response401GetUserTransactions",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_user_transactions_serialize(
        self,
        id,
        transaction_type,
        category,
        account_id,
        institution_id,
        page,
        size,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "transaction_type": "multi",
            "category": "multi",
            "account_id": "multi",
            "institution_id": "multi",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if transaction_type is not None:
            _query_params.append(("transaction_type", transaction_type))

        if category is not None:
            _query_params.append(("category", category))

        if account_id is not None:
            _query_params.append(("account_id", account_id))

        if institution_id is not None:
            _query_params.append(("institution_id", institution_id))

        if page is not None:
            _query_params.append(("page", page))

        if size is not None:
            _query_params.append(("size", size))

        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2ClientCredentials"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/users/{id}/transactions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
