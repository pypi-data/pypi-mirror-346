import warnings

from rootfilespec import bootstrap
from rootfilespec.bootstrap.TStreamerInfo import (
    ClassDef,
    TStreamerInfo,
)
from rootfilespec.dispatch import normalize

# TODO: make a generated/__init__.py file out of this
PREAMBLE = """# Generated by streamerinfo_to_classes

from typing import Annotated, Optional

import numpy as np

from rootfilespec.bootstrap import *
from rootfilespec.container import (
    BasicArray,
    FixedSizeArray,
    ObjectArray,
    StdVector,
    StdSet,
    StdDeque,
    StdMap,
    StdPair,
)
from rootfilespec.dispatch import DICTIONARY
from rootfilespec.serializable import serializable
from rootfilespec.structutil import Fmt, StdBitset

"""

BOOTSTRAP_TYPES: set[str] = set(bootstrap.__all__)


def streamerinfo_to_classes(streamerinfo: bootstrap.TList) -> str:
    lines: list[str] = list(PREAMBLE.split("\n"))

    classes: dict[str, ClassDef] = {}
    declared: set[str] = set(BOOTSTRAP_TYPES)

    for item in streamerinfo.items:
        if not isinstance(item, TStreamerInfo):
            continue
        clsname = normalize(item.fName.fString)
        if clsname in declared:
            lines.append(f"# Class {clsname} already declared, skipping")
            lines.append(f"# Definition: {item}\n")
            continue
        classdef = item.class_definition()
        classes[classdef.name] = classdef

    # Collect all warnings for users here since the stack level
    # is not predictable in the recursive write function
    warning_log: list[str] = []

    # Write out in dependency order
    def write(classdef: ClassDef):
        for dep in classdef.dependencies:
            depdef = classes.pop(dep, None)
            if depdef is not None:
                write(depdef)
            elif dep not in declared:
                if dep == classdef.name:
                    msg = f"Class {classdef.name} depends on itself, which is not allowed (likely an unimplemented container type)"
                else:
                    msg = f"Class {classdef.name} depends on {dep} which is missing"
                warning_log.append("    " + msg)
                lines.append(
                    f"class {dep}(Uninterpreted):\n    pass\nDICTIONARY['{dep}'] = {dep}\n"
                )
                declared.add(dep)
        lines.append(classdef.code)
        declared.add(classdef.name)

    while classes:
        _, classdef = classes.popitem()
        write(classdef)

    # Write out the warnings
    if warning_log:
        msg = "Errors were found in the StreamerInfo:\n"
        msg += "\n".join(warning_log)
        msg += "\nThese members will be uninterpreted and skipped."
        warnings.warn(msg, UserWarning, stacklevel=2)

    return "\n".join(lines)
