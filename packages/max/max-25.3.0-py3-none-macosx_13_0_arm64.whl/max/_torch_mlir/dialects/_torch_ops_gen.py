
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "torch"

@_ods_cext.register_operation(_Dialect)
class AtenAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_abs(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAbsOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAbs_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.abs_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_abs_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAbs_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveAvgPool1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_avg_pool1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_adaptive_avg_pool1d(result, self_, output_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAdaptiveAvgPool1dOp(result=result, self_=self_, output_size=output_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveAvgPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_avg_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_adaptive_avg_pool2d(result, self_, output_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAdaptiveAvgPool2dOp(result=result, self_=self_, output_size=output_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveAvgPool3dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_avg_pool3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_adaptive_avg_pool3d(result, self_, output_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAdaptiveAvgPool3dOp(result=result, self_=self_, output_size=output_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveMaxPool1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_max_pool1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_adaptive_max_pool1d(result0, result1, self_, output_size, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenAdaptiveMaxPool1dOp(result0=result0, result1=result1, self_=self_, output_size=output_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveMaxPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_max_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_adaptive_max_pool2d(result0, result1, self_, output_size, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenAdaptiveMaxPool2dOp(result0=result0, result1=result1, self_=self_, output_size=output_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenAdaptiveMaxPool3dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.adaptive_max_pool3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_adaptive_max_pool3d(result0, result1, self_, output_size, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenAdaptiveMaxPool3dOp(result0=result0, result1=result1, self_=self_, output_size=output_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenAddFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add(result, a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddOp(result=result, a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_Scalar(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddScalarOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_str(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddStrOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_t(result, a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddTOp(result=result, a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add_Tensor(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddTensorOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdd_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add__Scalar(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAdd_ScalarOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAdd_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.add_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_add__Tensor(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAdd_TensorOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddcdivOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.addcdiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, tensor1, tensor2, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(tensor1)
    operands.append(tensor2)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def tensor1(self):
    return self.operation.operands[1]

  @builtins.property
  def tensor2(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_addcdiv(result, self_, tensor1, tensor2, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddcdivOp(result=result, self_=self_, tensor1=tensor1, tensor2=tensor2, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddcdiv_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.addcdiv_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, tensor1, tensor2, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(tensor1)
    operands.append(tensor2)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def tensor1(self):
    return self.operation.operands[1]

  @builtins.property
  def tensor2(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_addcdiv_(result, self_, tensor1, tensor2, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddcdiv_Op(result=result, self_=self_, tensor1=tensor1, tensor2=tensor2, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddcmulOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.addcmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, tensor1, tensor2, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(tensor1)
    operands.append(tensor2)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def tensor1(self):
    return self.operation.operands[1]

  @builtins.property
  def tensor2(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_addcmul(result, self_, tensor1, tensor2, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddcmulOp(result=result, self_=self_, tensor1=tensor1, tensor2=tensor2, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddcmul_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.addcmul_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, tensor1, tensor2, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(tensor1)
    operands.append(tensor2)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def tensor1(self):
    return self.operation.operands[1]

  @builtins.property
  def tensor2(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_addcmul_(result, self_, tensor1, tensor2, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddcmul_Op(result=result, self_=self_, tensor1=tensor1, tensor2=tensor2, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAddmmOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.addmm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mat1, mat2, beta, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mat1)
    operands.append(mat2)
    operands.append(beta)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mat1(self):
    return self.operation.operands[1]

  @builtins.property
  def mat2(self):
    return self.operation.operands[2]

  @builtins.property
  def beta(self):
    return self.operation.operands[3]

  @builtins.property
  def alpha(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_addmm(result, self_, mat1, mat2, beta, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAddmmOp(result=result, self_=self_, mat1=mat1, mat2=mat2, beta=beta, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAliasCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.alias_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_alias_copy(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAliasCopyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAllBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.all.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_all_bool(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAllBoolOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAllDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.all.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_all_dim(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAllDimOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAllOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.all"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_all(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAllOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.amax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_amax(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAmaxOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAnyBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.any.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_any_bool(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAnyBoolOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAnyDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.any.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_any_dim(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAnyDimOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAnyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.any"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_any(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAnyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAppendTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.append.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, el, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(el)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def el(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_append_t(result, self_, el, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAppendTOp(result=result, self_=self_, el=el, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenArangeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.arange"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, end, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(end)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def end(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_arange(result, end, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenArangeOp(result=result, end=end, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenArangeStartOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.arange.start"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, end, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(end)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_arange_start(result, start, end, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenArangeStartOp(result=result, start=start, end=end, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenArangeStartOutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.arange.start_out"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, end, step, out, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(end)
    operands.append(step)
    operands.append(out)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def out(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_arange_start_out(result, start, end, step, out, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenArangeStartOutOp(result=result, start=start, end=end, step=step, out=out, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenArangeStartStepOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.arange.start_step"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, end, step, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(end)
    operands.append(step)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def layout(self):
    return self.operation.operands[4]

  @builtins.property
  def device(self):
    return self.operation.operands[5]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_arange_start_step(result, start, end, step, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenArangeStartStepOp(result=result, start=start, end=end, step=step, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenArgmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.argmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_argmax(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenArgmaxOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAsStridedCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.as_strided_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, stride, storage_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(stride)
    operands.append(storage_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def storage_offset(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_as_strided_copy(result, self_, size, stride, storage_offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAsStridedCopyOp(result=result, self_=self_, size=size, stride=stride, storage_offset=storage_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAsStridedScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.as_strided_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, size, stride, storage_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(size)
    operands.append(stride)
    operands.append(storage_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def size(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def storage_offset(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_as_strided_scatter(result, self_, src, size, stride, storage_offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAsStridedScatterOp(result=result, self_=self_, src=src, size=size, stride=stride, storage_offset=storage_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAtan2Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_atan2(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAtan2Op(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAtan2_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.atan2_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_atan2_(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAtan2_Op(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAtanOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_atan(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAtanOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAtan_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.atan_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_atan_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAtan_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAvgPool1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.avg_pool1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(ceil_mode)
    operands.append(count_include_pad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[4]

  @builtins.property
  def count_include_pad(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_avg_pool1d(result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAvgPool1dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, ceil_mode=ceil_mode, count_include_pad=count_include_pad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAvgPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.avg_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(ceil_mode)
    operands.append(count_include_pad)
    operands.append(divisor_override)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[4]

  @builtins.property
  def count_include_pad(self):
    return self.operation.operands[5]

  @builtins.property
  def divisor_override(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_avg_pool2d(result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAvgPool2dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, ceil_mode=ceil_mode, count_include_pad=count_include_pad, divisor_override=divisor_override, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenAvgPool3dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.avg_pool3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(ceil_mode)
    operands.append(count_include_pad)
    operands.append(divisor_override)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[4]

  @builtins.property
  def count_include_pad(self):
    return self.operation.operands[5]

  @builtins.property
  def divisor_override(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_avg_pool3d(result, self_, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenAvgPool3dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, ceil_mode=ceil_mode, count_include_pad=count_include_pad, divisor_override=divisor_override, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBaddbmmOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.baddbmm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, batch1, batch2, beta, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(batch1)
    operands.append(batch2)
    operands.append(beta)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def batch1(self):
    return self.operation.operands[1]

  @builtins.property
  def batch2(self):
    return self.operation.operands[2]

  @builtins.property
  def beta(self):
    return self.operation.operands[3]

  @builtins.property
  def alpha(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_baddbmm(result, self_, batch1, batch2, beta, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBaddbmmOp(result=result, self_=self_, batch1=batch1, batch2=batch2, beta=beta, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBaddbmm_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.baddbmm_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, batch1, batch2, beta, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(batch1)
    operands.append(batch2)
    operands.append(beta)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def batch1(self):
    return self.operation.operands[1]

  @builtins.property
  def batch2(self):
    return self.operation.operands[2]

  @builtins.property
  def beta(self):
    return self.operation.operands[3]

  @builtins.property
  def alpha(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_baddbmm_(result, self_, batch1, batch2, beta, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBaddbmm_Op(result=result, self_=self_, batch1=batch1, batch2=batch2, beta=beta, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBatchNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.batch_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(running_mean)
    operands.append(running_var)
    operands.append(training)
    operands.append(momentum)
    operands.append(eps)
    operands.append(cudnn_enabled)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def running_var(self):
    return self.operation.operands[4]

  @builtins.property
  def training(self):
    return self.operation.operands[5]

  @builtins.property
  def momentum(self):
    return self.operation.operands[6]

  @builtins.property
  def eps(self):
    return self.operation.operands[7]

  @builtins.property
  def cudnn_enabled(self):
    return self.operation.operands[8]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_batch_norm(result, input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBatchNormOp(result=result, input=input, weight=weight, bias=bias, running_mean=running_mean, running_var=running_var, training=training, momentum=momentum, eps=eps, cudnn_enabled=cudnn_enabled, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBernoulliOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bernoulli"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def generator(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bernoulli(result, self_, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBernoulliOp(result=result, self_=self_, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBernoulliPOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bernoulli.p"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def generator(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bernoulli_p(result, self_, p, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBernoulliPOp(result=result, self_=self_, p=p, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBernoulliTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bernoulli.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def generator(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bernoulli_Tensor(result, self_, p, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBernoulliTensorOp(result=result, self_=self_, p=p, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBernoulli_FloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bernoulli_.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def generator(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bernoulli__float(result, self_, p, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBernoulli_FloatOp(result=result, self_=self_, p=p, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBernoulli_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bernoulli_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def generator(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bernoulli__Tensor(result, self_, p, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBernoulli_TensorOp(result=result, self_=self_, p=p, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBincountOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bincount"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, weights, minlength, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(weights)
    operands.append(minlength)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def weights(self):
    return self.operation.operands[1]

  @builtins.property
  def minlength(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bincount(result, self_, weights, minlength, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBincountOp(result=result, self_=self_, weights=weights, minlength=minlength, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseAndTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_and.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_and_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseAndTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseAnd_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_and_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_and__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseAnd_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseNotOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_not(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseNotOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseNot_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_not_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_not_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseNot_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseOrTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_or.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_or_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseOrTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseOr_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_or_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_or__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseOr_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseXorTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_xor.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_xor_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseXorTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBitwiseXor_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bitwise_xor_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bitwise_xor__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBitwiseXor_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBmmOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bmm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mat2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mat2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mat2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bmm(result, self_, mat2, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBmmOp(result=result, self_=self_, mat2=mat2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBoolFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Bool.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Bool_float(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBoolFloatOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBoolIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Bool.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Bool_int(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBoolIntOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBoolTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Bool.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Bool_Tensor(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBoolTensorOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBroadcastToOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_broadcast_to(result, self_, size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBroadcastToOp(result=result, self_=self_, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenBucketizeTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.bucketize.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, boundaries, out_int32, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(boundaries)
    operands.append(out_int32)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def boundaries(self):
    return self.operation.operands[1]

  @builtins.property
  def out_int32(self):
    return self.operation.operands[2]

  @builtins.property
  def right(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_bucketize_Tensor(result, self_, boundaries, out_int32, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenBucketizeTensorOp(result=result, self_=self_, boundaries=boundaries, out_int32=out_int32, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tensors, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(tensors)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tensors(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cat(result, tensors, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCatOp(result=result, tensors=tensors, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCeilFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ceil.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ceil_float(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCeilFloatOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ceil(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCeilOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCeilScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ceil.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ceil_Scalar(result, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCeilScalarOp(result=result, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCeil_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ceil_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ceil_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCeil_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenChunkOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.chunk"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, chunks, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(chunks)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def chunks(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_chunk(result, self_, chunks, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenChunkOp(result=result, self_=self_, chunks=chunks, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def max(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_max(result, self_, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampMaxOp(result=result, self_=self_, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampMax_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_max_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def max(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_max_(result, self_, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampMax_Op(result=result, self_=self_, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampMinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_min(result, self_, min, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampMinOp(result=result, self_=self_, min=min, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampMin_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_min_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_min_(result, self_, min, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampMin_Op(result=result, self_=self_, min=min, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp(result, self_, min, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampOp(result=result, self_=self_, min=min, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClampTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_Tensor(result, self_, min, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClampTensorOp(result=result, self_=self_, min=min, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClamp_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp_(result, self_, min, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClamp_Op(result=result, self_=self_, min=min, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenClamp_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clamp_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min)
    operands.append(max)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clamp__Tensor(result, self_, min, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenClamp_TensorOp(result=result, self_=self_, min=min, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCloneOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_clone(result, self_, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCloneOp(result=result, self_=self_, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConstantPadNdOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.constant_pad_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, pad, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(pad)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def pad(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_constant_pad_nd(result, self_, pad, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConstantPadNdOp(result=result, self_=self_, pad=pad, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenContiguousOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.contiguous"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_contiguous(result, self_, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenContiguousOp(result=result, self_=self_, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConv1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(groups)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv1d(result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConv1dOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, groups=groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(groups)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv2d(result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConv2dOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, groups=groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConv3dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(groups)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv3d(result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConv3dOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, groups=groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConvTranspose1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv_transpose1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(dilation)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def dilation(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv_transpose1d(result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConvTranspose1dOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, output_padding=output_padding, groups=groups, dilation=dilation, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConvTranspose2dInputOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv_transpose2d.input"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(dilation)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def dilation(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv_transpose2d_input(result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConvTranspose2dInputOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, output_padding=output_padding, groups=groups, dilation=dilation, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConvTranspose3dInputOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.conv_transpose3d.input"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(dilation)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def dilation(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_conv_transpose3d_input(result, input, weight, bias, stride, padding, output_padding, groups, dilation, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConvTranspose3dInputOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, output_padding=output_padding, groups=groups, dilation=dilation, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenConvolutionBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.convolution_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(input)
    operands.append(weight)
    operands.append(bias_sizes)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(transposed)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(output_mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def bias_sizes(self):
    return self.operation.operands[3]

  @builtins.property
  def stride(self):
    return self.operation.operands[4]

  @builtins.property
  def padding(self):
    return self.operation.operands[5]

  @builtins.property
  def dilation(self):
    return self.operation.operands[6]

  @builtins.property
  def transposed(self):
    return self.operation.operands[7]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[8]

  @builtins.property
  def groups(self):
    return self.operation.operands[9]

  @builtins.property
  def output_mask(self):
    return self.operation.operands[10]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_convolution_backward(result0, result1, result2, grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenConvolutionBackwardOp(result0=result0, result1=result1, result2=result2, grad_output=grad_output, input=input, weight=weight, bias_sizes=bias_sizes, stride=stride, padding=padding, dilation=dilation, transposed=transposed, output_padding=output_padding, groups=groups, output_mask=output_mask, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenConvolutionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.convolution"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(transposed)
    operands.append(output_padding)
    operands.append(groups)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def transposed(self):
    return self.operation.operands[6]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[7]

  @builtins.property
  def groups(self):
    return self.operation.operands[8]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_convolution(result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenConvolutionOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, transposed=transposed, output_padding=output_padding, groups=groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, non_blocking, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(non_blocking)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_copy(result, self_, src, non_blocking, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCopyOp(result=result, self_=self_, src=src, non_blocking=non_blocking, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCopy_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.copy_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, non_blocking, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(non_blocking)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_copy_(result, self_, src, non_blocking, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCopy_Op(result=result, self_=self_, src=src, non_blocking=non_blocking, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCosOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cos(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCosOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCos_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cos_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cos_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCos_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCpuOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cpu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cpu(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCpuOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCrossEntropyLossOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cross_entropy_loss"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, target, weight, reduction, ignore_index, label_smoothing, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(target)
    operands.append(weight)
    operands.append(reduction)
    operands.append(ignore_index)
    operands.append(label_smoothing)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return self.operation.operands[3]

  @builtins.property
  def ignore_index(self):
    return self.operation.operands[4]

  @builtins.property
  def label_smoothing(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cross_entropy_loss(result, self_, target, weight, reduction, ignore_index, label_smoothing, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCrossEntropyLossOp(result=result, self_=self_, target=target, weight=weight, reduction=reduction, ignore_index=ignore_index, label_smoothing=label_smoothing, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenCumsumOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_cumsum(result, self_, dim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenCumsumOp(result=result, self_=self_, dim=dim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDeleteDictStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Delete.Dict_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    if result is not None: results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def aten_Delete_Dict_str(result, self_, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AtenDeleteDictStrOp(result=result, self_=self_, key=key, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AtenDetachCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.detach_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_detach_copy(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDetachCopyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDetachOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.detach"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_detach(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDetachOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDiagonalCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.diagonal_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, offset, dim1, dim2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(offset)
    operands.append(dim1)
    operands.append(dim2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def dim1(self):
    return self.operation.operands[2]

  @builtins.property
  def dim2(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_diagonal_copy(result, self_, offset, dim1, dim2, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDiagonalCopyOp(result=result, self_=self_, offset=offset, dim1=dim1, dim2=dim2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDiagonalScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.diagonal_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, offset, dim1, dim2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(offset)
    operands.append(dim1)
    operands.append(dim2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def dim1(self):
    return self.operation.operands[3]

  @builtins.property
  def dim2(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_diagonal_scatter(result, self_, src, offset, dim1, dim2, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDiagonalScatterOp(result=result, self_=self_, src=src, offset=offset, dim1=dim1, dim2=dim2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_dim(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDimOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivTensorModeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div.Tensor_mode"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, rounding_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(rounding_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def rounding_mode(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div_Tensor_mode(result, self_, other, rounding_mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivTensorModeOp(result=result, self_=self_, other=other, rounding_mode=rounding_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDivTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDivTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDiv_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDiv_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDiv_TensorModeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div_.Tensor_mode"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, rounding_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(rounding_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def rounding_mode(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div__Tensor_mode(result, self_, other, rounding_mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDiv_TensorModeOp(result=result, self_=self_, other=other, rounding_mode=rounding_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDiv_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.div_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_div__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDiv_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDropoutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.dropout"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, p, train, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(p)
    operands.append(train)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def train(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_dropout(result, input, p, train, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDropoutOp(result=result, input=input, p=p, train=train, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenDropout_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.dropout_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, train, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(train)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def train(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_dropout_(result, self_, p, train, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenDropout_Op(result=result, self_=self_, p=p, train=train, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEmbeddingBagPaddingIdxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.embedding_bag.padding_idx"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, result3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(weight)
    operands.append(indices)
    operands.append(offsets)
    operands.append(scale_grad_by_freq)
    operands.append(mode)
    operands.append(sparse)
    operands.append(per_sample_weights)
    operands.append(include_last_offset)
    operands.append(padding_idx)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    results.append(result3)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def offsets(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_grad_by_freq(self):
    return self.operation.operands[3]

  @builtins.property
  def mode(self):
    return self.operation.operands[4]

  @builtins.property
  def sparse(self):
    return self.operation.operands[5]

  @builtins.property
  def per_sample_weights(self):
    return self.operation.operands[6]

  @builtins.property
  def include_last_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def padding_idx(self):
    return self.operation.operands[8]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

  @builtins.property
  def result3(self):
    return self.operation.results[3]

def aten_embedding_bag_padding_idx(result0, result1, result2, result3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenEmbeddingBagPaddingIdxOp(result0=result0, result1=result1, result2=result2, result3=result3, weight=weight, indices=indices, offsets=offsets, scale_grad_by_freq=scale_grad_by_freq, mode=mode, sparse=sparse, per_sample_weights=per_sample_weights, include_last_offset=include_last_offset, padding_idx=padding_idx, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenEmbeddingDenseBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.embedding_dense_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(indices)
    operands.append(num_weights)
    operands.append(padding_idx)
    operands.append(scale_grad_by_freq)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def num_weights(self):
    return self.operation.operands[2]

  @builtins.property
  def padding_idx(self):
    return self.operation.operands[3]

  @builtins.property
  def scale_grad_by_freq(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_embedding_dense_backward(result, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEmbeddingDenseBackwardOp(result=result, grad_output=grad_output, indices=indices, num_weights=num_weights, padding_idx=padding_idx, scale_grad_by_freq=scale_grad_by_freq, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEmbeddingOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.embedding"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, weight, indices, padding_idx, scale_grad_by_freq, sparse, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(weight)
    operands.append(indices)
    operands.append(padding_idx)
    operands.append(scale_grad_by_freq)
    operands.append(sparse)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def padding_idx(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_grad_by_freq(self):
    return self.operation.operands[3]

  @builtins.property
  def sparse(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_embedding(result, weight, indices, padding_idx, scale_grad_by_freq, sparse, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEmbeddingOp(result=result, weight=weight, indices=indices, padding_idx=padding_idx, scale_grad_by_freq=scale_grad_by_freq, sparse=sparse, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEmptyLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.empty_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_empty_like(result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEmptyLikeOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEmptyMemoryFormatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.empty.memory_format"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_empty_memory_format(result, size, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEmptyMemoryFormatOp(result=result, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEmptyStridedOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.empty_strided"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, stride, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(stride)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def stride(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_empty_strided(result, size, stride, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEmptyStridedOp(result=result, size=size, stride=stride, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_device(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqDeviceOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqIntListOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.int_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_int_list(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqIntListOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_str(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqStrOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEqTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEqTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEq_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEq_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEq_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eq_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eq__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEq_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenErfOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_erf(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenErfOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenErf_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.erf_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_erf_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenErf_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_exp(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExp_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.exp_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_exp_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExp_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpandAsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.expand_as"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_expand_as(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpandAsOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpandCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.expand_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, implicit, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(implicit)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def implicit(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_expand_copy(result, self_, size, implicit, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpandCopyOp(result=result, self_=self_, size=size, implicit=implicit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpandOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.expand"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, implicit, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(implicit)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def implicit(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_expand(result, self_, size, implicit, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpandOp(result=result, self_=self_, size=size, implicit=implicit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpm1Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.expm1"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_expm1(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpm1Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenExpm1_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.expm1_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_expm1_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenExpm1_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEyeMOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eye.m"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, n, m, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(n)
    operands.append(m)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def n(self):
    return self.operation.operands[0]

  @builtins.property
  def m(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eye_m(result, n, m, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEyeMOp(result=result, n=n, m=m, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenEyeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.eye"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, n, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(n)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def n(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_eye(result, n, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenEyeOp(result=result, n=n, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFftFftOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fft_fft"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, n, dim, norm, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(n)
    operands.append(dim)
    operands.append(norm)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def n(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def norm(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fft_fft(result, self_, n, dim, norm, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFftFftOp(result=result, self_=self_, n=n, dim=dim, norm=norm, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFillScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fill.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fill_Scalar(result, self_, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFillScalarOp(result=result, self_=self_, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFillTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fill.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fill_Tensor(result, self_, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFillTensorOp(result=result, self_=self_, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFill_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fill_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fill__Scalar(result, self_, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFill_ScalarOp(result=result, self_=self_, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFill_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fill_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fill__Tensor(result, self_, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFill_TensorOp(result=result, self_=self_, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFlattenUsingIntsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.flatten.using_ints"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, start_dim, end_dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(start_dim)
    operands.append(end_dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def start_dim(self):
    return self.operation.operands[1]

  @builtins.property
  def end_dim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_flatten_using_ints(result, self_, start_dim, end_dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFlattenUsingIntsOp(result=result, self_=self_, start_dim=start_dim, end_dim=end_dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFlipOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.flip"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dims)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_flip(result, self_, dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFlipOp(result=result, self_=self_, dims=dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloatImplicitOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.FloatImplicit"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_FloatImplicit(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloatImplicitOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloatScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Float.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Float_Scalar(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloatScalarOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloatStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Float.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Float_str(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloatStrOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloatTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Float.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Float_Tensor(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloatTensorOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloorDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floor_divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floor_divide(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloorDivideOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloorDivideScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floor_divide.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floor_divide_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloorDivideScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloorFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floor.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floor_float(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloorFloatOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floor(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloorOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloor_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floor_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floor_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloor_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFloordivIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.floordiv.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_floordiv_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFloordivIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFmodScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fmod.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fmod_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFmodScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFmod_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.fmod_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_fmod__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFmod_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFormatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.format"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_format(operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFormatOp(operands_=operands_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFrobeniusNormDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.frobenius_norm.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_frobenius_norm_dim(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFrobeniusNormDimOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFullLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.full_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, fill_value, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(fill_value)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def fill_value(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_full_like(result, self_, fill_value, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFullLikeOp(result=result, self_=self_, fill_value=fill_value, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenFullOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.full"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, fill_value, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(fill_value)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def fill_value(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_full(result, size, fill_value, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenFullOp(result=result, size=size, fill_value=fill_value, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, sparse_grad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(sparse_grad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def sparse_grad(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gather(result, self_, dim, index, sparse_grad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGatherOp(result=result, self_=self_, dim=dim, index=index, sparse_grad=sparse_grad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGe_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGe_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGe_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ge_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ge__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGe_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeluBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gelu_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, approximate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(approximate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def approximate(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gelu_backward(result, grad_output, self_, approximate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeluBackwardOp(result=result, grad_output=grad_output, self_=self_, approximate=approximate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGeluOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, approximate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(approximate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def approximate(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gelu(result, self_, approximate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGeluOp(result=result, self_=self_, approximate=approximate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGetDefaultStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.get.default_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, default_value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    operands.append(default_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def default_value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_get_default_str(result, self_, key, default_value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGetDefaultStrOp(result=result, self_=self_, key=key, default_value=default_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGroupNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.group_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, num_groups, weight, bias, eps, cudnn_enabled, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(num_groups)
    operands.append(weight)
    operands.append(bias)
    operands.append(eps)
    operands.append(cudnn_enabled)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def num_groups(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def eps(self):
    return self.operation.operands[4]

  @builtins.property
  def cudnn_enabled(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_group_norm(result, input, num_groups, weight, bias, eps, cudnn_enabled, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGroupNormOp(result=result, input=input, num_groups=num_groups, weight=weight, bias=bias, eps=eps, cudnn_enabled=cudnn_enabled, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGtFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGtFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGtFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGtFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGtIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGtIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGtScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGtScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGtTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGtTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGt_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGt_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenGt_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.gt_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_gt__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenGt_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardsigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardsigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardsigmoid(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardsigmoidOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardsigmoid_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardsigmoid_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardsigmoid_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardsigmoid_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardswishOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardswish"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardswish(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardswishOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardswish_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardswish_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardswish_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardswish_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardtanhBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardtanh_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, min_val, max_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(min_val)
    operands.append(max_val)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def min_val(self):
    return self.operation.operands[2]

  @builtins.property
  def max_val(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardtanh_backward(result, grad_output, self_, min_val, max_val, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardtanhBackwardOp(result=result, grad_output=grad_output, self_=self_, min_val=min_val, max_val=max_val, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardtanhOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardtanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min_val, max_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min_val)
    operands.append(max_val)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min_val(self):
    return self.operation.operands[1]

  @builtins.property
  def max_val(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardtanh(result, self_, min_val, max_val, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardtanhOp(result=result, self_=self_, min_val=min_val, max_val=max_val, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenHardtanh_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.hardtanh_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, min_val, max_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(min_val)
    operands.append(max_val)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def min_val(self):
    return self.operation.operands[1]

  @builtins.property
  def max_val(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_hardtanh_(result, self_, min_val, max_val, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenHardtanh_Op(result=result, self_=self_, min_val=min_val, max_val=max_val, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenImagOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.imag"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_imag(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenImagOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def source(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_copy(result, self_, dim, index, source, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexCopyOp(result=result, self_=self_, dim=dim, index=index, source=source, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexPutHackedTwinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_put.hacked_twin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_put_hacked_twin(result, self_, indices, values, accumulate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexPutHackedTwinOp(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexPutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_put"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_put(result, self_, indices, values, accumulate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexPutOp(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexPut_HackedTwinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_put_.hacked_twin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_put__hacked_twin(result, self_, indices, values, accumulate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexPut_HackedTwinOp(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexPut_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_put_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_put_(result, self_, indices, values, accumulate, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexPut_Op(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index_select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_select(result, self_, dim, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexSelectOp(result=result, self_=self_, dim=dim, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexTensorHackedTwinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index.Tensor_hacked_twin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_Tensor_hacked_twin(result, self_, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexTensorHackedTwinOp(result=result, self_=self_, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIndexTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.index.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_index_Tensor(result, self_, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIndexTensorOp(result=result, self_=self_, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenInsertTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.insert.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, idx, el, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(idx)
    operands.append(el)
    _ods_context = _ods_get_default_loc_context(loc)
    if result is not None: results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def el(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def aten_insert_t(result, self_, idx, el, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AtenInsertTOp(result=result, self_=self_, idx=idx, el=el, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AtenInstanceNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.instance_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(running_mean)
    operands.append(running_var)
    operands.append(use_input_stats)
    operands.append(momentum)
    operands.append(eps)
    operands.append(cudnn_enabled)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def running_var(self):
    return self.operation.operands[4]

  @builtins.property
  def use_input_stats(self):
    return self.operation.operands[5]

  @builtins.property
  def momentum(self):
    return self.operation.operands[6]

  @builtins.property
  def eps(self):
    return self.operation.operands[7]

  @builtins.property
  def cudnn_enabled(self):
    return self.operation.operands[8]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_instance_norm(result, input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenInstanceNormOp(result=result, input=input, weight=weight, bias=bias, running_mean=running_mean, running_var=running_var, use_input_stats=use_input_stats, momentum=momentum, eps=eps, cudnn_enabled=cudnn_enabled, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIntBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Int.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Int_bool(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIntBoolOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIntFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Int.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Int_float(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIntFloatOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIntImplicitOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.IntImplicit"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_IntImplicit(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIntImplicitOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIntScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Int.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Int_Scalar(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIntScalarOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIntTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.Int.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_Int_Tensor(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIntTensorOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenIsFloatingPointOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.is_floating_point"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_is_floating_point(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenIsFloatingPointOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenItemOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.item"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_item(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenItemOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(values)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def values(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_join(self_, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenJoinOp(self_=self_, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenKeysStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.keys.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_keys_str(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenKeysStrOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.layer_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, normalized_shape, weight, bias, eps, cudnn_enable, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(normalized_shape)
    operands.append(weight)
    operands.append(bias)
    operands.append(eps)
    operands.append(cudnn_enable)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def normalized_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def eps(self):
    return self.operation.operands[4]

  @builtins.property
  def cudnn_enable(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_layer_norm(result, input, normalized_shape, weight, bias, eps, cudnn_enable, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLayerNormOp(result=result, input=input, normalized_shape=normalized_shape, weight=weight, bias=bias, eps=eps, cudnn_enable=cudnn_enable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.le.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_le_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.le.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_le_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.le.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_le_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLe_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.le_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_le__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLe_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLe_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.le_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_le__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLe_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeakyReluBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.leaky_relu_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, negative_slope, self_is_result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(negative_slope)
    operands.append(self_is_result)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def negative_slope(self):
    return self.operation.operands[2]

  @builtins.property
  def self_is_result(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_leaky_relu_backward(result, grad_output, self_, negative_slope, self_is_result, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeakyReluBackwardOp(result=result, grad_output=grad_output, self_=self_, negative_slope=negative_slope, self_is_result=self_is_result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeakyReluOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.leaky_relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, negative_slope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(negative_slope)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def negative_slope(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_leaky_relu(result, self_, negative_slope, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeakyReluOp(result=result, self_=self_, negative_slope=negative_slope, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLeakyRelu_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.leaky_relu_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, negative_slope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(negative_slope)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def negative_slope(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_leaky_relu_(result, self_, negative_slope, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLeakyRelu_Op(result=result, self_=self_, negative_slope=negative_slope, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLenStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.len.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, s, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(s)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def s(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_len_str(s, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLenStrOp(s=s, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLenTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.len.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_len_t(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLenTOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLenTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.len.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, t, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(t)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def t(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_len_Tensor(t, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLenTensorOp(t=t, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLerpTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lerp.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, end, weight, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(end)
    operands.append(weight)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lerp_Tensor(result, self_, end, weight, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLerpTensorOp(result=result, self_=self_, end=end, weight=weight, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLerp_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lerp_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, end, weight, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(end)
    operands.append(weight)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lerp__Tensor(result, self_, end, weight, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLerp_TensorOp(result=result, self_=self_, end=end, weight=weight, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLiftFreshCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lift_fresh_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lift_fresh_copy(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLiftFreshCopyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLinalgVectorNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.linalg_vector_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, ord, dim, keepdim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(ord)
    operands.append(dim)
    operands.append(keepdim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def ord(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def dtype(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_linalg_vector_norm(result, self_, ord, dim, keepdim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLinalgVectorNormOp(result=result, self_=self_, ord=ord, dim=dim, keepdim=keepdim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_linear(result, input, weight, bias, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLinearOp(result=result, input=input, weight=weight, bias=bias, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenListTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.list.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, l, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_list_t(result, l, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenListTOp(result=result, l=l, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLog1pOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log1p(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLog1pOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLog1p_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log1p_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log1p_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLog1p_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLog2Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log2"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log2(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLog2Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLog2_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log2_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log2_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLog2_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log_int(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogIntOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogSoftmaxIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log_softmax.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log_softmax_int(result, self_, dim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogSoftmaxIntOp(result=result, self_=self_, dim=dim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLog_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.log_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_log_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLog_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_and(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalAndOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalAnd_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_and_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_and_(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalAnd_Op(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalNotOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_not(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalNotOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalNot_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_not_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_not_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalNot_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalOrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_or(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalOrOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalOr_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_or_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_or_(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalOr_Op(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalXorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_xor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalXorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogicalXor_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logical_xor_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logical_xor_(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogicalXor_Op(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLogsumexpOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.logsumexp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_logsumexp(result, self_, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLogsumexpOp(result=result, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLtFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLtFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLtFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLtFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLtIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLtIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLtScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLtScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLtTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLtTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLt_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLt_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenLt_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.lt_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_lt__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenLt_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaskedFillScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.masked_fill.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mask, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mask)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_masked_fill_Scalar(result, self_, mask, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaskedFillScalarOp(result=result, self_=self_, mask=mask, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaskedFillTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.masked_fill.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mask, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mask)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_masked_fill_Tensor(result, self_, mask, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaskedFillTensorOp(result=result, self_=self_, mask=mask, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaskedFill_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.masked_fill_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mask, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mask)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_masked_fill__Scalar(result, self_, mask, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaskedFill_ScalarOp(result=result, self_=self_, mask=mask, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaskedFill_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.masked_fill_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mask, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mask)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_masked_fill__Tensor(result, self_, mask, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaskedFill_TensorOp(result=result, self_=self_, mask=mask, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaskedSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.masked_select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_masked_select(result, self_, mask, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaskedSelectOp(result=result, self_=self_, mask=mask, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_matmul(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMatmulOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, self_, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def aten_max_dim(values, indices, self_, dim, keepdim, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenMaxDimOp(values=values, indices=indices, self_=self_, dim=dim, keepdim=keepdim, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxOtherOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max.other"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max_other(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxOtherOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool1dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool1d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max_pool1d(result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxPool1dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool1dWithIndicesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool1d_with_indices"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_max_pool1d_with_indices(result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenMaxPool1dWithIndicesOp(result0=result0, result1=result1, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max_pool2d(result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxPool2dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool2dWithIndicesBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool2d_with_indices_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, kernel_size, stride, padding, dilation, ceil_mode, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[6]

  @builtins.property
  def indices(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max_pool2d_with_indices_backward(result, grad_output, self_, kernel_size, stride, padding, dilation, ceil_mode, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxPool2dWithIndicesBackwardOp(result=result, grad_output=grad_output, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool2dWithIndicesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool2d_with_indices"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_max_pool2d_with_indices(result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenMaxPool2dWithIndicesOp(result0=result0, result1=result1, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool3dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_max_pool3d(result, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaxPool3dOp(result=result, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMaxPool3dWithIndicesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.max_pool3d_with_indices"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(kernel_size)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(ceil_mode)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def padding(self):
    return self.operation.operands[3]

  @builtins.property
  def dilation(self):
    return self.operation.operands[4]

  @builtins.property
  def ceil_mode(self):
    return self.operation.operands[5]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_max_pool3d_with_indices(result0, result1, self_, kernel_size, stride, padding, dilation, ceil_mode, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenMaxPool3dWithIndicesOp(result0=result0, result1=result1, self_=self_, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, ceil_mode=ceil_mode, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenMaximumOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.maximum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_maximum(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMaximumOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMeanDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mean.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mean_dim(result, self_, dim, keepdim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMeanDimOp(result=result, self_=self_, dim=dim, keepdim=keepdim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMeanOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mean(result, self_, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMeanOp(result=result, self_=self_, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_min(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMinOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMinOtherOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.min.other"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_min_other(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMinOtherOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMinimumOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.minimum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_minimum(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMinimumOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMishOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mish"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mish(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMishOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMmOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, mat2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(mat2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def mat2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mm(result, self_, mat2, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMmOp(result=result, self_=self_, mat2=mat2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMovedimIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.movedim.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, source, destination, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(source)
    operands.append(destination)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def source(self):
    return self.operation.operands[1]

  @builtins.property
  def destination(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_movedim_int(result, self_, source, destination, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMovedimIntOp(result=result, self_=self_, source=source, destination=destination, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMseLossBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mse_loss_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, target, reduction, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(target)
    operands.append(reduction)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def target(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mse_loss_backward(result, grad_output, self_, target, reduction, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMseLossBackwardOp(result=result, grad_output=grad_output, self_=self_, target=target, reduction=reduction, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMseLossOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mse_loss"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, target, reduction, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(target)
    operands.append(reduction)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def reduction(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mse_loss(result, self_, target, reduction, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMseLossOp(result=result, self_=self_, target=target, reduction=reduction, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulIntFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.int_float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_int_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulIntFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMulTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMulTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMul_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMul_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMul_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mul_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mul__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMul_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenMvOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.mv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, vec, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(vec)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def vec(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_mv(result, self_, vec, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenMvOp(result=result, self_=self_, vec=vec, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNarrowOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.narrow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, start, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(start)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def length(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_narrow(result, self_, dim, start, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNarrowOp(result=result, self_=self_, dim=dim, start=start, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNativeBatchNormBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_batch_norm_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_out)
    operands.append(input)
    operands.append(weight)
    operands.append(running_mean)
    operands.append(running_var)
    operands.append(save_mean)
    operands.append(save_invstd)
    operands.append(train)
    operands.append(eps)
    operands.append(output_mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def running_var(self):
    return self.operation.operands[4]

  @builtins.property
  def save_mean(self):
    return self.operation.operands[5]

  @builtins.property
  def save_invstd(self):
    return self.operation.operands[6]

  @builtins.property
  def train(self):
    return self.operation.operands[7]

  @builtins.property
  def eps(self):
    return self.operation.operands[8]

  @builtins.property
  def output_mask(self):
    return self.operation.operands[9]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_batch_norm_backward(result0, result1, result2, grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeBatchNormBackwardOp(result0=result0, result1=result1, result2=result2, grad_out=grad_out, input=input, weight=weight, running_mean=running_mean, running_var=running_var, save_mean=save_mean, save_invstd=save_invstd, train=train, eps=eps, output_mask=output_mask, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeBatchNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_batch_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, input, weight, bias, running_mean, running_var, training, momentum, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(running_mean)
    operands.append(running_var)
    operands.append(training)
    operands.append(momentum)
    operands.append(eps)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def running_var(self):
    return self.operation.operands[4]

  @builtins.property
  def training(self):
    return self.operation.operands[5]

  @builtins.property
  def momentum(self):
    return self.operation.operands[6]

  @builtins.property
  def eps(self):
    return self.operation.operands[7]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_batch_norm(result0, result1, result2, input, weight, bias, running_mean, running_var, training, momentum, eps, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeBatchNormOp(result0=result0, result1=result1, result2=result2, input=input, weight=weight, bias=bias, running_mean=running_mean, running_var=running_var, training=training, momentum=momentum, eps=eps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeDropoutBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_dropout_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, mask, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(mask)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_native_dropout_backward(result, grad_output, mask, scale, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNativeDropoutBackwardOp(result=result, grad_output=grad_output, mask=mask, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNativeDropoutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_dropout"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, input, p, train, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(p)
    operands.append(train)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def train(self):
    return self.operation.operands[2]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_native_dropout(result0, result1, input, p, train, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeDropoutOp(result0=result0, result1=result1, input=input, p=p, train=train, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeGroupNormBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_group_norm_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_out)
    operands.append(input)
    operands.append(mean)
    operands.append(rstd)
    operands.append(weight)
    operands.append(N)
    operands.append(C)
    operands.append(HxW)
    operands.append(group)
    operands.append(output_mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def mean(self):
    return self.operation.operands[2]

  @builtins.property
  def rstd(self):
    return self.operation.operands[3]

  @builtins.property
  def weight(self):
    return self.operation.operands[4]

  @builtins.property
  def N(self):
    return self.operation.operands[5]

  @builtins.property
  def C(self):
    return self.operation.operands[6]

  @builtins.property
  def HxW(self):
    return self.operation.operands[7]

  @builtins.property
  def group(self):
    return self.operation.operands[8]

  @builtins.property
  def output_mask(self):
    return self.operation.operands[9]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_group_norm_backward(result0, result1, result2, grad_out, input, mean, rstd, weight, n, c, hx_w, group, output_mask, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeGroupNormBackwardOp(result0=result0, result1=result1, result2=result2, grad_out=grad_out, input=input, mean=mean, rstd=rstd, weight=weight, N=n, C=c, HxW=hx_w, group=group, output_mask=output_mask, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeGroupNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_group_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, input, weight, bias, N, C, HxW, group, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(N)
    operands.append(C)
    operands.append(HxW)
    operands.append(group)
    operands.append(eps)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def N(self):
    return self.operation.operands[3]

  @builtins.property
  def C(self):
    return self.operation.operands[4]

  @builtins.property
  def HxW(self):
    return self.operation.operands[5]

  @builtins.property
  def group(self):
    return self.operation.operands[6]

  @builtins.property
  def eps(self):
    return self.operation.operands[7]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_group_norm(result0, result1, result2, input, weight, bias, n, c, hx_w, group, eps, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeGroupNormOp(result0=result0, result1=result1, result2=result2, input=input, weight=weight, bias=bias, N=n, C=c, HxW=hx_w, group=group, eps=eps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeLayerNormBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_layer_norm_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_out)
    operands.append(input)
    operands.append(normalized_shape)
    operands.append(mean)
    operands.append(rstd)
    operands.append(weight)
    operands.append(bias)
    operands.append(output_mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def normalized_shape(self):
    return self.operation.operands[2]

  @builtins.property
  def mean(self):
    return self.operation.operands[3]

  @builtins.property
  def rstd(self):
    return self.operation.operands[4]

  @builtins.property
  def weight(self):
    return self.operation.operands[5]

  @builtins.property
  def bias(self):
    return self.operation.operands[6]

  @builtins.property
  def output_mask(self):
    return self.operation.operands[7]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_layer_norm_backward(result0, result1, result2, grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeLayerNormBackwardOp(result0=result0, result1=result1, result2=result2, grad_out=grad_out, input=input, normalized_shape=normalized_shape, mean=mean, rstd=rstd, weight=weight, bias=bias, output_mask=output_mask, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNativeLayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.native_layer_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, input, normalized_shape, weight, bias, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(normalized_shape)
    operands.append(weight)
    operands.append(bias)
    operands.append(eps)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def normalized_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def eps(self):
    return self.operation.operands[4]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten_native_layer_norm(result0, result1, result2, input, normalized_shape, weight, bias, eps, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNativeLayerNormOp(result0=result0, result1=result1, result2=result2, input=input, normalized_shape=normalized_shape, weight=weight, bias=bias, eps=eps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNeBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_bool(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeBoolOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeIntListOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.int_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_int_list(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeIntListOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne_Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeTensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNe_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne__Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNe_ScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNe_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ne_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ne__Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNe_TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNegFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.neg.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_neg_float(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNegFloatOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNegIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.neg.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_neg_int(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNegIntOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNegOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.neg"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_neg(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNegOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNeg_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.neg_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_neg_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNeg_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNewEmptyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.new_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_new_empty(result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNewEmptyOp(result=result, self_=self_, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNewEmptyStridedOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.new_empty_strided"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, stride, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(stride)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def layout(self):
    return self.operation.operands[4]

  @builtins.property
  def device(self):
    return self.operation.operands[5]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_new_empty_strided(result, self_, size, stride, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNewEmptyStridedOp(result=result, self_=self_, size=size, stride=stride, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNewFullOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.new_full"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, fill_value, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(fill_value)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def fill_value(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def layout(self):
    return self.operation.operands[4]

  @builtins.property
  def device(self):
    return self.operation.operands[5]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_new_full(result, self_, size, fill_value, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNewFullOp(result=result, self_=self_, size=size, fill_value=fill_value, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNewOnesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.new_ones"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_new_ones(result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNewOnesOp(result=result, self_=self_, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNewZerosOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.new_zeros"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_new_zeros(result, self_, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNewZerosOp(result=result, self_=self_, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNllLoss2dBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.nll_loss2d_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, target, weight, reduction, ignore_index, total_weight, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(target)
    operands.append(weight)
    operands.append(reduction)
    operands.append(ignore_index)
    operands.append(total_weight)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def target(self):
    return self.operation.operands[2]

  @builtins.property
  def weight(self):
    return self.operation.operands[3]

  @builtins.property
  def reduction(self):
    return self.operation.operands[4]

  @builtins.property
  def ignore_index(self):
    return self.operation.operands[5]

  @builtins.property
  def total_weight(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_nll_loss2d_backward(result, grad_output, self_, target, weight, reduction, ignore_index, total_weight, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNllLoss2dBackwardOp(result=result, grad_output=grad_output, self_=self_, target=target, weight=weight, reduction=reduction, ignore_index=ignore_index, total_weight=total_weight, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNllLoss2dForwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.nll_loss2d_forward"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, total_weight, self_, target, weight, reduction, ignore_index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(target)
    operands.append(weight)
    operands.append(reduction)
    operands.append(ignore_index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    results.append(total_weight)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return self.operation.operands[3]

  @builtins.property
  def ignore_index(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def total_weight(self):
    return self.operation.results[1]

def aten_nll_loss2d_forward(output, total_weight, self_, target, weight, reduction, ignore_index, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNllLoss2dForwardOp(output=output, total_weight=total_weight, self_=self_, target=target, weight=weight, reduction=reduction, ignore_index=ignore_index, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNllLossBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.nll_loss_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, target, weight, reduction, ignore_index, total_weight, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(target)
    operands.append(weight)
    operands.append(reduction)
    operands.append(ignore_index)
    operands.append(total_weight)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def target(self):
    return self.operation.operands[2]

  @builtins.property
  def weight(self):
    return self.operation.operands[3]

  @builtins.property
  def reduction(self):
    return self.operation.operands[4]

  @builtins.property
  def ignore_index(self):
    return self.operation.operands[5]

  @builtins.property
  def total_weight(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_nll_loss_backward(result, grad_output, self_, target, weight, reduction, ignore_index, total_weight, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNllLossBackwardOp(result=result, grad_output=grad_output, self_=self_, target=target, weight=weight, reduction=reduction, ignore_index=ignore_index, total_weight=total_weight, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNllLossForwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.nll_loss_forward"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, total_weight, self_, target, weight, reduction, ignore_index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(target)
    operands.append(weight)
    operands.append(reduction)
    operands.append(ignore_index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    results.append(total_weight)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def weight(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return self.operation.operands[3]

  @builtins.property
  def ignore_index(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def total_weight(self):
    return self.operation.results[1]

def aten_nll_loss_forward(output, total_weight, self_, target, weight, reduction, ignore_index, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenNllLossForwardOp(output=output, total_weight=total_weight, self_=self_, target=target, weight=weight, reduction=reduction, ignore_index=ignore_index, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenNormScalarOptDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.norm.ScalarOpt_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, dim, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(dim)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_norm_ScalarOpt_dim(result, self_, p, dim, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNormScalarOptDimOp(result=result, self_=self_, p=p, dim=dim, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNumelOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.numel"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_numel(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNumelOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenNumpyTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.numpy_T"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_numpy_T(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenNumpyTOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenOneHotOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.one_hot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, num_classes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(num_classes)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def num_classes(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_one_hot(result, self_, num_classes, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenOneHotOp(result=result, self_=self_, num_classes=num_classes, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenOnesLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ones_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ones_like(result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenOnesLikeOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenOnesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ones"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ones(result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenOnesOp(result=result, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPadOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, pad, mode, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(pad)
    operands.append(mode)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def pad(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pad(result, self_, pad, mode, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPadOp(result=result, self_=self_, pad=pad, mode=mode, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPermuteCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.permute_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dims)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_permute_copy(result, self_, dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPermuteCopyOp(result=result, self_=self_, dims=dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.permute"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dims)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_permute(result, self_, dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPermuteOp(result=result, self_=self_, dims=dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowFloatIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.float_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_float_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowFloatIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowIntFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.int_float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_int_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowIntFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowIntToIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.int_to_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_int_to_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowIntToIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(exponent)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_Scalar(result, self_, exponent, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowScalarOp(result=result, self_=self_, exponent=exponent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowTensorScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.Tensor_Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(exponent)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_Tensor_Scalar(result, self_, exponent, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowTensorScalarOp(result=result, self_=self_, exponent=exponent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPowTensorTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.pow.Tensor_Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(exponent)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_pow_Tensor_Tensor(result, self_, exponent, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPowTensorTensorOp(result=result, self_=self_, exponent=exponent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenPreluOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.prelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, weight, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(weight)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_prelu(result, self_, weight, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenPreluOp(result=result, self_=self_, weight=weight, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.rand_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_rand_like(result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandLikeOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandintLowOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.randint.low"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, low, high, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(low)
    operands.append(high)
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def low(self):
    return self.operation.operands[0]

  @builtins.property
  def high(self):
    return self.operation.operands[1]

  @builtins.property
  def size(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def layout(self):
    return self.operation.operands[4]

  @builtins.property
  def device(self):
    return self.operation.operands[5]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_randint_low(result, low, high, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandintLowOp(result=result, low=low, high=high, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandintOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.randint"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, high, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(high)
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def high(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_randint(result, high, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandintOp(result=result, high=high, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandnGeneratorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.randn.generator"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, generator, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(generator)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def generator(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def layout(self):
    return self.operation.operands[3]

  @builtins.property
  def device(self):
    return self.operation.operands[4]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_randn_generator(result, size, generator, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandnGeneratorOp(result=result, size=size, generator=generator, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandnLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.randn_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_randn_like(result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandnLikeOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRandnOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.randn"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_randn(result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRandnOp(result=result, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRealOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.real"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_real(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRealOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_reciprocal(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenReciprocalOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenReciprocal_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.reciprocal_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_reciprocal_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenReciprocal_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRelu6Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.relu6"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_relu6(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRelu6Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRelu6_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.relu6_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_relu6_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRelu6_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenReluOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_relu(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenReluOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRelu_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.relu_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_relu_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRelu_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRemainderIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.remainder.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_remainder_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRemainderIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRemainderScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.remainder.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_remainder_Scalar(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRemainderScalarOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRepeatInterleaveSelfIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.repeat_interleave.self_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, repeats, dim, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(repeats)
    operands.append(dim)
    operands.append(output_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def output_size(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_repeat_interleave_self_int(result, self_, repeats, dim, output_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRepeatInterleaveSelfIntOp(result=result, self_=self_, repeats=repeats, dim=dim, output_size=output_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, repeats, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(repeats)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_repeat(result, self_, repeats, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRepeatOp(result=result, self_=self_, repeats=repeats, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_reshape(result, self_, shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenReshapeOp(result=result, self_=self_, shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenResize_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.resize_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_resize_(result, self_, size, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenResize_Op(result=result, self_=self_, size=size, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRollOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.roll"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, shifts, dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(shifts)
    operands.append(dims)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def shifts(self):
    return self.operation.operands[1]

  @builtins.property
  def dims(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_roll(result, self_, shifts, dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRollOp(result=result, self_=self_, shifts=shifts, dims=dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRoundOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_round(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRoundOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRound_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.round_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_round_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRound_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_rsqrt(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRsqrtOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRsqrt_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.rsqrt_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_rsqrt_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRsqrt_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenRsubScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.rsub.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_rsub_Scalar(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenRsubScalarOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScalarImplicitOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.ScalarImplicit"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_ScalarImplicit(result, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScalarImplicitOp(result=result, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScalarTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scalar_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, s, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(s)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def s(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scalar_tensor(result, s, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScalarTensorOp(result=result, s=s, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScaledDotProductAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scaled_dot_product_attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, query, key, value, attn_mask, dropout_p, is_causal, scale, enable_gqa, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(query)
    operands.append(key)
    operands.append(value)
    operands.append(attn_mask)
    operands.append(dropout_p)
    operands.append(is_causal)
    operands.append(scale)
    operands.append(enable_gqa)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def query(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def attn_mask(self):
    return self.operation.operands[3]

  @builtins.property
  def dropout_p(self):
    return self.operation.operands[4]

  @builtins.property
  def is_causal(self):
    return self.operation.operands[5]

  @builtins.property
  def scale(self):
    return self.operation.operands[6]

  @builtins.property
  def enable_gqa(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scaled_dot_product_attention(result, query, key, value, attn_mask, dropout_p, is_causal, scale, enable_gqa, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScaledDotProductAttentionOp(result=result, query=query, key=key, value=value, attn_mask=attn_mask, dropout_p=dropout_p, is_causal=is_causal, scale=scale, enable_gqa=enable_gqa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterAddOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter_add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def src(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_add(result, self_, dim, index, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterAddOp(result=result, self_=self_, dim=dim, index=index, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterAdd_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter_add_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def src(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_add_(result, self_, dim, index, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterAdd_Op(result=result, self_=self_, dim=dim, index=index, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterReduceTwoOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter_reduce.two"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, src, reduce, include_self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(src)
    operands.append(reduce)
    operands.append(include_self)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def src(self):
    return self.operation.operands[3]

  @builtins.property
  def reduce(self):
    return self.operation.operands[4]

  @builtins.property
  def include_self(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_reduce_two(result, self_, dim, index, src, reduce, include_self, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterReduceTwoOp(result=result, self_=self_, dim=dim, index=index, src=src, reduce=reduce, include_self=include_self, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterReduce_TwoOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter_reduce_.two"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, src, reduce, include_self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(src)
    operands.append(reduce)
    operands.append(include_self)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def src(self):
    return self.operation.operands[3]

  @builtins.property
  def reduce(self):
    return self.operation.operands[4]

  @builtins.property
  def include_self(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_reduce__two(result, self_, dim, index, src, reduce, include_self, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterReduce_TwoOp(result=result, self_=self_, dim=dim, index=index, src=src, reduce=reduce, include_self=include_self, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterSrcOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter.src"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def src(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_src(result, self_, dim, index, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterSrcOp(result=result, self_=self_, dim=dim, index=index, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenScatterValueOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.scatter.value"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_scatter_value(result, self_, dim, index, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenScatterValueOp(result=result, self_=self_, dim=dim, index=index, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSelectCopyIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.select_copy.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_select_copy_int(result, self_, dim, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSelectCopyIntOp(result=result, self_=self_, dim=dim, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSelectIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.select.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_select_int(result, self_, dim, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSelectIntOp(result=result, self_=self_, dim=dim, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSelectScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.select_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, dim, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(dim)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def index(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_select_scatter(result, self_, src, dim, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSelectScatterOp(result=result, self_=self_, src=src, dim=dim, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sigmoid(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSigmoidOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSigmoid_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sigmoid_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sigmoid_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSigmoid_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSiluOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.silu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_silu(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSiluOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSilu_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.silu_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_silu_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSilu_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sin(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSinOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSin_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sin_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sin_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSin_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSizeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.size.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_size_int(self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSizeIntOp(self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_size(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSizeOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSliceCopyTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.slice_copy.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def end(self):
    return self.operation.operands[3]

  @builtins.property
  def step(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_slice_copy_Tensor(result, self_, dim, start, end, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSliceCopyTensorOp(result=result, self_=self_, dim=dim, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSliceScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.slice_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, src, dim, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(src)
    operands.append(dim)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def start(self):
    return self.operation.operands[3]

  @builtins.property
  def end(self):
    return self.operation.operands[4]

  @builtins.property
  def step(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_slice_scatter(result, self_, src, dim, start, end, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSliceScatterOp(result=result, self_=self_, src=src, dim=dim, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSliceTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.slice.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, l, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def end(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_slice_t(result, l, start, end, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSliceTOp(result=result, l=l, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSliceTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.slice.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def end(self):
    return self.operation.operands[3]

  @builtins.property
  def step(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_slice_Tensor(result, self_, dim, start, end, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSliceTensorOp(result=result, self_=self_, dim=dim, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSoftmaxIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.softmax.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_softmax_int(result, self_, dim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSoftmaxIntOp(result=result, self_=self_, dim=dim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSoftplusOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.softplus"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, beta, threshold, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(beta)
    operands.append(threshold)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def beta(self):
    return self.operation.operands[1]

  @builtins.property
  def threshold(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_softplus(result, self_, beta, threshold, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSoftplusOp(result=result, self_=self_, beta=beta, threshold=threshold, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSortIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sort.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, reverse, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(reverse)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def reverse(self):
    return self.operation.operands[1]

def aten_sort_int(self_, reverse, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AtenSortIntOp(self_=self_, reverse=reverse, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AtenSortOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sort"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, self_, dim, descending, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(descending)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def descending(self):
    return self.operation.operands[2]

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def aten_sort(values, indices, self_, dim, descending, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenSortOp(values=values, indices=indices, self_=self_, dim=dim, descending=descending, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenSplitTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.split.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, split_size, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(split_size)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def split_size(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_split_Tensor(result, self_, split_size, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSplitTensorOp(result=result, self_=self_, split_size=split_size, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSplitWithSizesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.split_with_sizes"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, split_sizes, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(split_sizes)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def split_sizes(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_split_with_sizes(result, self_, split_sizes, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSplitWithSizesOp(result=result, self_=self_, split_sizes=split_sizes, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqrtIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sqrt.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sqrt_int(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqrtIntOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sqrt(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqrtOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqrt_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sqrt_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sqrt_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqrt_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSquareOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.square"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_square(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSquareOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSquare_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.square_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_square_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSquare_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqueezeCopyDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.squeeze_copy.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_squeeze_copy_dim(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqueezeCopyDimOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqueezeCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.squeeze_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_squeeze_copy(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqueezeCopyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqueezeDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.squeeze.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_squeeze_dim(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqueezeDimOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqueezeDimsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.squeeze.dims"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_squeeze_dims(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqueezeDimsOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.squeeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_squeeze(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSqueezeOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenStackOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.stack"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tensors, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(tensors)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tensors(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_stack(result, tensors, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenStackOp(result=result, tensors=tensors, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenStdCorrectionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.std.correction"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, correction, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(correction)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def correction(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_std_correction(result, self_, dim, correction, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenStdCorrectionOp(result=result, self_=self_, dim=dim, correction=correction, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenStdDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.std.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, unbiased, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(unbiased)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_std_dim(result, self_, dim, unbiased, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenStdDimOp(result=result, self_=self_, dim=dim, unbiased=unbiased, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenStdOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.std"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, unbiased, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(unbiased)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_std(result, self_, unbiased, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenStdOp(result=result, self_=self_, unbiased=unbiased, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, elem, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(elem)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elem(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_str(elem, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenStrOp(elem=elem, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSubFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub_float(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSubFloatOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSubIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSubIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSubOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub(result, a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSubOp(result=result, a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSubScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub_Scalar(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSubScalarOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSubTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub_Tensor(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSubTensorOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSub_ScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub_.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub__Scalar(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSub_ScalarOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSub_TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sub_.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(alpha)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def alpha(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sub__Tensor(result, self_, other, alpha, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSub_TensorOp(result=result, self_=self_, other=other, alpha=alpha, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSumDimIntListOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sum.dim_IntList"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, keepdim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(keepdim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[2]

  @builtins.property
  def dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sum_dim_IntList(result, self_, dim, keepdim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSumDimIntListOp(result=result, self_=self_, dim=dim, keepdim=keepdim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSumOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sum(result, self_, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSumOp(result=result, self_=self_, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenSymSizeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.sym_size.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_sym_size_int(self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenSymSizeIntOp(self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.t_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_t_copy(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTCopyOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_t(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTanhBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tanh_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, output, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tanh_backward(result, grad_output, output, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTanhBackwardOp(result=result, grad_output=grad_output, output=output, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTanhOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tanh(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTanhOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTanh_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tanh_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tanh_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTanh_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTensorBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tensor.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, t, dtype, device, requires_grad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(t)
    operands.append(dtype)
    operands.append(device)
    operands.append(requires_grad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def t(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def device(self):
    return self.operation.operands[2]

  @builtins.property
  def requires_grad(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tensor_bool(result, t, dtype, device, requires_grad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTensorBoolOp(result=result, t=t, dtype=dtype, device=device, requires_grad=requires_grad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTensorFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tensor.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, t, dtype, device, requires_grad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(t)
    operands.append(dtype)
    operands.append(device)
    operands.append(requires_grad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def t(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def device(self):
    return self.operation.operands[2]

  @builtins.property
  def requires_grad(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tensor_float(result, t, dtype, device, requires_grad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTensorFloatOp(result=result, t=t, dtype=dtype, device=device, requires_grad=requires_grad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTensorIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tensor.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, t, dtype, device, requires_grad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(t)
    operands.append(dtype)
    operands.append(device)
    operands.append(requires_grad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def t(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def device(self):
    return self.operation.operands[2]

  @builtins.property
  def requires_grad(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tensor_int(result, t, dtype, device, requires_grad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTensorIntOp(result=result, t=t, dtype=dtype, device=device, requires_grad=requires_grad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, data, dtype, device, requires_grad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(data)
    operands.append(dtype)
    operands.append(device)
    operands.append(requires_grad)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def data(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def device(self):
    return self.operation.operands[2]

  @builtins.property
  def requires_grad(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_tensor(result, data, dtype, device, requires_grad, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTensorOp(result=result, data=data, dtype=dtype, device=device, requires_grad=requires_grad, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenThresholdBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.threshold_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, self_, threshold, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(self_)
    operands.append(threshold)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def threshold(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_threshold_backward(result, grad_output, self_, threshold, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenThresholdBackwardOp(result=result, grad_output=grad_output, self_=self_, threshold=threshold, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenThresholdOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.threshold"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, threshold, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(threshold)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def threshold(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_threshold(result, self_, threshold, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenThresholdOp(result=result, self_=self_, threshold=threshold, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenThreshold_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.threshold_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, threshold, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(threshold)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def threshold(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_threshold_(result, self_, threshold, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenThreshold_Op(result=result, self_=self_, threshold=threshold, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenToDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.to.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, device, dtype, non_blocking, copy, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(device)
    operands.append(dtype)
    operands.append(non_blocking)
    operands.append(copy)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def device(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[3]

  @builtins.property
  def copy(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_to_device(result, self_, device, dtype, non_blocking, copy, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenToDeviceOp(result=result, self_=self_, device=device, dtype=dtype, non_blocking=non_blocking, copy=copy, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenToDtypeLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.to.dtype_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, non_blocking, copy, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(non_blocking)
    operands.append(copy)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[5]

  @builtins.property
  def copy(self):
    return self.operation.operands[6]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[7]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_to_dtype_layout(result, self_, dtype, layout, device, pin_memory, non_blocking, copy, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenToDtypeLayoutOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, non_blocking=non_blocking, copy=copy, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenToDtypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.to.dtype"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, non_blocking, copy, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(non_blocking)
    operands.append(copy)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[2]

  @builtins.property
  def copy(self):
    return self.operation.operands[3]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_to_dtype(result, self_, dtype, non_blocking, copy, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenToDtypeOp(result=result, self_=self_, dtype=dtype, non_blocking=non_blocking, copy=copy, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenToOtherOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.to.other"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, non_blocking, copy, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    operands.append(non_blocking)
    operands.append(copy)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[2]

  @builtins.property
  def copy(self):
    return self.operation.operands[3]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_to_other(result, self_, other, non_blocking, copy, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenToOtherOp(result=result, self_=self_, other=other, non_blocking=non_blocking, copy=copy, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenToPrimDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.to.prim_Device"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, device, dtype, non_blocking, copy, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(device)
    operands.append(dtype)
    operands.append(non_blocking)
    operands.append(copy)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def device(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[3]

  @builtins.property
  def copy(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_to_prim_Device(result, self_, device, dtype, non_blocking, copy, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenToPrimDeviceOp(result=result, self_=self_, device=device, dtype=dtype, non_blocking=non_blocking, copy=copy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTopkOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.topk"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, self_, k, dim, largest, sorted, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(k)
    operands.append(dim)
    operands.append(largest)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def k(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def largest(self):
    return self.operation.operands[3]

  @builtins.property
  def sorted(self):
    return self.operation.operands[4]

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def aten_topk(values, indices, self_, k, dim, largest, sorted, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenTopkOp(values=values, indices=indices, self_=self_, k=k, dim=dim, largest=largest, sorted=sorted, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenTransposeCopyIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.transpose_copy.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim0, dim1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim0)
    operands.append(dim1)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim0(self):
    return self.operation.operands[1]

  @builtins.property
  def dim1(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_transpose_copy_int(result, self_, dim0, dim1, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTransposeCopyIntOp(result=result, self_=self_, dim0=dim0, dim1=dim1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTransposeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.transpose.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim0, dim1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim0)
    operands.append(dim1)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim0(self):
    return self.operation.operands[1]

  @builtins.property
  def dim1(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_transpose_int(result, self_, dim0, dim1, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTransposeIntOp(result=result, self_=self_, dim0=dim0, dim1=dim1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTriuOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.triu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, diagonal, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(diagonal)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def diagonal(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_triu(result, self_, diagonal, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTriuOp(result=result, self_=self_, diagonal=diagonal, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTriu_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.triu_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, diagonal, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(diagonal)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def diagonal(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_triu_(result, self_, diagonal, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTriu_Op(result=result, self_=self_, diagonal=diagonal, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTruncOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_trunc(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTruncOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTrunc_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.trunc_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_trunc_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTrunc_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenTypeAsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.type_as"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_type_as(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenTypeAsOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUnbindIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.unbind.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_unbind_int(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUnbindIntOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUnfoldCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.unfold_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dimension, size, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dimension)
    operands.append(size)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return self.operation.operands[1]

  @builtins.property
  def size(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_unfold_copy(result, self_, dimension, size, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUnfoldCopyOp(result=result, self_=self_, dimension=dimension, size=size, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUniformOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, from_, to, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(from_)
    operands.append(to)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def from_(self):
    return self.operation.operands[1]

  @builtins.property
  def to(self):
    return self.operation.operands[2]

  @builtins.property
  def generator(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_uniform(result, self_, from_, to, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUniformOp(result=result, self_=self_, from_=from_, to=to, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUniform_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.uniform_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, from_, to, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(from_)
    operands.append(to)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def from_(self):
    return self.operation.operands[1]

  @builtins.property
  def to(self):
    return self.operation.operands[2]

  @builtins.property
  def generator(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_uniform_(result, self_, from_, to, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUniform_Op(result=result, self_=self_, from_=from_, to=to, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUnsqueezeCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.unsqueeze_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_unsqueeze_copy(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUnsqueezeCopyOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUnsqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.unsqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_unsqueeze(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUnsqueezeOp(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUnsqueeze_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.unsqueeze_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_unsqueeze_(result, self_, dim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUnsqueeze_Op(result=result, self_=self_, dim=dim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleBicubic2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_bicubic2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, align_corners, scales_h, scales_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    operands.append(align_corners)
    operands.append(scales_h)
    operands.append(scales_w)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def align_corners(self):
    return self.operation.operands[2]

  @builtins.property
  def scales_h(self):
    return self.operation.operands[3]

  @builtins.property
  def scales_w(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_bicubic2d(result, self_, output_size, align_corners, scales_h, scales_w, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleBicubic2dOp(result=result, self_=self_, output_size=output_size, align_corners=align_corners, scales_h=scales_h, scales_w=scales_w, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleBicubic2dVecOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_bicubic2d.vec"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, output_size, align_corners, scale_factors, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(output_size)
    operands.append(align_corners)
    operands.append(scale_factors)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def align_corners(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_factors(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_bicubic2d_vec(result, input, output_size, align_corners, scale_factors, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleBicubic2dVecOp(result=result, input=input, output_size=output_size, align_corners=align_corners, scale_factors=scale_factors, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleBilinear2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_bilinear2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, align_corners, scales_h, scales_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    operands.append(align_corners)
    operands.append(scales_h)
    operands.append(scales_w)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def align_corners(self):
    return self.operation.operands[2]

  @builtins.property
  def scales_h(self):
    return self.operation.operands[3]

  @builtins.property
  def scales_w(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_bilinear2d(result, self_, output_size, align_corners, scales_h, scales_w, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleBilinear2dOp(result=result, self_=self_, output_size=output_size, align_corners=align_corners, scales_h=scales_h, scales_w=scales_w, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleBilinear2dVecOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_bilinear2d.vec"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, output_size, align_corners, scale_factors, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(output_size)
    operands.append(align_corners)
    operands.append(scale_factors)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def align_corners(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_factors(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_bilinear2d_vec(result, input, output_size, align_corners, scale_factors, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleBilinear2dVecOp(result=result, input=input, output_size=output_size, align_corners=align_corners, scale_factors=scale_factors, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleNearest2dBackwardOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_nearest2d_backward"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, output_size, input_size, scales_h, scales_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(output_size)
    operands.append(input_size)
    operands.append(scales_h)
    operands.append(scales_w)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def input_size(self):
    return self.operation.operands[2]

  @builtins.property
  def scales_h(self):
    return self.operation.operands[3]

  @builtins.property
  def scales_w(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_nearest2d_backward(result, grad_output, output_size, input_size, scales_h, scales_w, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleNearest2dBackwardOp(result=result, grad_output=grad_output, output_size=output_size, input_size=input_size, scales_h=scales_h, scales_w=scales_w, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleNearest2dOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_nearest2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, output_size, scales_h, scales_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(output_size)
    operands.append(scales_h)
    operands.append(scales_w)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def scales_h(self):
    return self.operation.operands[2]

  @builtins.property
  def scales_w(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_nearest2d(result, self_, output_size, scales_h, scales_w, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleNearest2dOp(result=result, self_=self_, output_size=output_size, scales_h=scales_h, scales_w=scales_w, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenUpsampleNearest2dVecOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.upsample_nearest2d.vec"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, output_size, scale_factors, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(output_size)
    operands.append(scale_factors)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.operands[1]

  @builtins.property
  def scale_factors(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_upsample_nearest2d_vec(result, input, output_size, scale_factors, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenUpsampleNearest2dVecOp(result=result, input=input, output_size=output_size, scale_factors=scale_factors, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVAppendTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.vappend.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, el, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(el)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def el(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_vappend_t(result, self_, el, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVAppendTOp(result=result, self_=self_, el=el, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVDeleteDictStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.VDelete.Dict_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_VDelete_Dict_str(result, self_, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVDeleteDictStrOp(result=result, self_=self_, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVGetDefaultStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.vget.default_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, default_value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    operands.append(default_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def default_value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_vget_default_str(result, self_, key, default_value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVGetDefaultStrOp(result=result, self_=self_, key=key, default_value=default_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVInsertTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.vinsert.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, idx, el, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(idx)
    operands.append(el)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def el(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_vinsert_t(result, self_, idx, el, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVInsertTOp(result=result, self_=self_, idx=idx, el=el, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVKeysStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.vkeys.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_vkeys_str(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVKeysStrOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVarCorrectionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var.correction"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, correction, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(correction)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def correction(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_var_correction(result, self_, dim, correction, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVarCorrectionOp(result=result, self_=self_, dim=dim, correction=correction, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVarDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, unbiased, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(unbiased)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_var_dim(result, self_, dim, unbiased, keepdim, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVarDimOp(result=result, self_=self_, dim=dim, unbiased=unbiased, keepdim=keepdim, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenVarMeanCorrectionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var_mean.correction"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, dim, correction, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(correction)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def correction(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_var_mean_correction(result0, result1, self_, dim, correction, keepdim, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenVarMeanCorrectionOp(result0=result0, result1=result1, self_=self_, dim=dim, correction=correction, keepdim=keepdim, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenVarMeanDimOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var_mean.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, dim, unbiased, keepdim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(unbiased)
    operands.append(keepdim)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[2]

  @builtins.property
  def keepdim(self):
    return self.operation.operands[3]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_var_mean_dim(result0, result1, self_, dim, unbiased, keepdim, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenVarMeanDimOp(result0=result0, result1=result1, self_=self_, dim=dim, unbiased=unbiased, keepdim=keepdim, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenVarMeanOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var_mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, self_, unbiased, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(unbiased)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[1]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

def aten_var_mean(result0, result1, self_, unbiased, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtenVarMeanOp(result0=result0, result1=result1, self_=self_, unbiased=unbiased, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtenVarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.var"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, unbiased, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(unbiased)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def unbiased(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_var(result, self_, unbiased, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenVarOp(result=result, self_=self_, unbiased=unbiased, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenViewAsComplexOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.view_as_complex"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_view_as_complex(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenViewAsComplexOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenViewCopyDtypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.view_copy.dtype"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_view_copy_dtype(result, self_, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenViewCopyDtypeOp(result=result, self_=self_, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenViewCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.view_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_view_copy(result, self_, size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenViewCopyOp(result=result, self_=self_, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenViewOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.view"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_view(result, self_, size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenViewOp(result=result, self_=self_, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenWhereScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.where.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def other(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_where_Scalar(result, condition, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenWhereScalarOp(result=result, condition=condition, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenWhereScalarOtherOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.where.ScalarOther"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def other(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_where_ScalarOther(result, condition, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenWhereScalarOtherOp(result=result, condition=condition, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenWhereScalarSelfOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.where.ScalarSelf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def other(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_where_ScalarSelf(result, condition, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenWhereScalarSelfOp(result=result, condition=condition, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenWhereSelfOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.where.self"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def self_(self):
    return self.operation.operands[1]

  @builtins.property
  def other(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_where_self(result, condition, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenWhereSelfOp(result=result, condition=condition, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenZeroOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_zero(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenZeroOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenZero_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.zero_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_zero_(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenZero_Op(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenZerosLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.zeros_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[5]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_zeros_like(result, self_, dtype, layout, device, pin_memory, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenZerosLikeOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtenZerosOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.zeros"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(size)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten_zeros(result, size, dtype, layout, device, pin_memory, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtenZerosOp(result=result, size=size, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ConvolutionDeprecatedOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._convolution.deprecated"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(transposed)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(benchmark)
    operands.append(deterministic)
    operands.append(cudnn_enabled)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def transposed(self):
    return self.operation.operands[6]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[7]

  @builtins.property
  def groups(self):
    return self.operation.operands[8]

  @builtins.property
  def benchmark(self):
    return self.operation.operands[9]

  @builtins.property
  def deterministic(self):
    return self.operation.operands[10]

  @builtins.property
  def cudnn_enabled(self):
    return self.operation.operands[11]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__convolution_deprecated(result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ConvolutionDeprecatedOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, transposed=transposed, output_padding=output_padding, groups=groups, benchmark=benchmark, deterministic=deterministic, cudnn_enabled=cudnn_enabled, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ConvolutionModeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._convolution_mode"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(groups)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def groups(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__convolution_mode(result, input, weight, bias, stride, padding, dilation, groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ConvolutionModeOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, groups=groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ConvolutionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._convolution"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(stride)
    operands.append(padding)
    operands.append(dilation)
    operands.append(transposed)
    operands.append(output_padding)
    operands.append(groups)
    operands.append(benchmark)
    operands.append(deterministic)
    operands.append(cudnn_enabled)
    operands.append(allow_tf32)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def padding(self):
    return self.operation.operands[4]

  @builtins.property
  def dilation(self):
    return self.operation.operands[5]

  @builtins.property
  def transposed(self):
    return self.operation.operands[6]

  @builtins.property
  def output_padding(self):
    return self.operation.operands[7]

  @builtins.property
  def groups(self):
    return self.operation.operands[8]

  @builtins.property
  def benchmark(self):
    return self.operation.operands[9]

  @builtins.property
  def deterministic(self):
    return self.operation.operands[10]

  @builtins.property
  def cudnn_enabled(self):
    return self.operation.operands[11]

  @builtins.property
  def allow_tf32(self):
    return self.operation.operands[12]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__convolution(result, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ConvolutionOp(result=result, input=input, weight=weight, bias=bias, stride=stride, padding=padding, dilation=dilation, transposed=transposed, output_padding=output_padding, groups=groups, benchmark=benchmark, deterministic=deterministic, cudnn_enabled=cudnn_enabled, allow_tf32=allow_tf32, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_EmbeddingBagOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._embedding_bag"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, result3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(weight)
    operands.append(indices)
    operands.append(offsets)
    operands.append(scale_grad_by_freq)
    operands.append(mode)
    operands.append(sparse)
    operands.append(per_sample_weights)
    operands.append(include_last_offset)
    operands.append(padding_idx)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    results.append(result3)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def offsets(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_grad_by_freq(self):
    return self.operation.operands[3]

  @builtins.property
  def mode(self):
    return self.operation.operands[4]

  @builtins.property
  def sparse(self):
    return self.operation.operands[5]

  @builtins.property
  def per_sample_weights(self):
    return self.operation.operands[6]

  @builtins.property
  def include_last_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def padding_idx(self):
    return self.operation.operands[8]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

  @builtins.property
  def result3(self):
    return self.operation.results[3]

def aten__embedding_bag(result0, result1, result2, result3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return Aten_EmbeddingBagOp(result0=result0, result1=result1, result2=result2, result3=result3, weight=weight, indices=indices, offsets=offsets, scale_grad_by_freq=scale_grad_by_freq, mode=mode, sparse=sparse, per_sample_weights=per_sample_weights, include_last_offset=include_last_offset, padding_idx=padding_idx, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class Aten_IndexPutImplOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._index_put_impl"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, unsafe, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    operands.append(unsafe)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def unsafe(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__index_put_impl(result, self_, indices, values, accumulate, unsafe, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_IndexPutImplOp(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, unsafe=unsafe, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_IndexPutImpl_Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._index_put_impl_"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, values, accumulate, unsafe, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    operands.append(values)
    operands.append(accumulate)
    operands.append(unsafe)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.operands[3]

  @builtins.property
  def unsafe(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__index_put_impl_(result, self_, indices, values, accumulate, unsafe, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_IndexPutImpl_Op(result=result, self_=self_, indices=indices, values=values, accumulate=accumulate, unsafe=unsafe, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_LogSoftmaxBackwardDataOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._log_softmax_backward_data"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, output, dim, input_dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(output)
    operands.append(dim)
    operands.append(input_dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def input_dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__log_softmax_backward_data(result, grad_output, output, dim, input_dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_LogSoftmaxBackwardDataOp(result=result, grad_output=grad_output, output=output, dim=dim, input_dtype=input_dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_LogSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._log_softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, half_to_float, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(half_to_float)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def half_to_float(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__log_softmax(result, self_, dim, half_to_float, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_LogSoftmaxOp(result=result, self_=self_, dim=dim, half_to_float=half_to_float, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_NativeBatchNormLegitNoTrainingOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._native_batch_norm_legit_no_training"

  _ODS_REGIONS = (0, True)

  def __init__(self, result0, result1, result2, input, weight, bias, running_mean, running_var, momentum, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(running_mean)
    operands.append(running_var)
    operands.append(momentum)
    operands.append(eps)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result0)
    results.append(result1)
    results.append(result2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def running_var(self):
    return self.operation.operands[4]

  @builtins.property
  def momentum(self):
    return self.operation.operands[5]

  @builtins.property
  def eps(self):
    return self.operation.operands[6]

  @builtins.property
  def result0(self):
    return self.operation.results[0]

  @builtins.property
  def result1(self):
    return self.operation.results[1]

  @builtins.property
  def result2(self):
    return self.operation.results[2]

def aten__native_batch_norm_legit_no_training(result0, result1, result2, input, weight, bias, running_mean, running_var, momentum, eps, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return Aten_NativeBatchNormLegitNoTrainingOp(result0=result0, result1=result1, result2=result2, input=input, weight=weight, bias=bias, running_mean=running_mean, running_var=running_var, momentum=momentum, eps=eps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class Aten_ReshapeAliasCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._reshape_alias_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, stride, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__reshape_alias_copy(result, self_, size, stride, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ReshapeAliasCopyOp(result=result, self_=self_, size=size, stride=stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ReshapeAliasOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._reshape_alias"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, stride, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__reshape_alias(result, self_, size, stride, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ReshapeAliasOp(result=result, self_=self_, size=size, stride=stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_SafeSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._safe_softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def dtype(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__safe_softmax(result, self_, dim, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_SafeSoftmaxOp(result=result, self_=self_, dim=dim, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ScaledDotProductEfficientAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._scaled_dot_product_efficient_attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, log_sumexp, philox_seed, philox_offset, query, key, value, attn_bias, compute_log_sumexp, dropout_p, is_causal, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(query)
    operands.append(key)
    operands.append(value)
    operands.append(attn_bias)
    operands.append(compute_log_sumexp)
    operands.append(dropout_p)
    operands.append(is_causal)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    results.append(log_sumexp)
    results.append(philox_seed)
    results.append(philox_offset)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def query(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def attn_bias(self):
    return self.operation.operands[3]

  @builtins.property
  def compute_log_sumexp(self):
    return self.operation.operands[4]

  @builtins.property
  def dropout_p(self):
    return self.operation.operands[5]

  @builtins.property
  def is_causal(self):
    return self.operation.operands[6]

  @builtins.property
  def scale(self):
    return self.operation.operands[7]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def log_sumexp(self):
    return self.operation.results[1]

  @builtins.property
  def philox_seed(self):
    return self.operation.results[2]

  @builtins.property
  def philox_offset(self):
    return self.operation.results[3]

def aten__scaled_dot_product_efficient_attention(output, log_sumexp, philox_seed, philox_offset, query, key, value, attn_bias, compute_log_sumexp, dropout_p, is_causal, scale, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return Aten_ScaledDotProductEfficientAttentionOp(output=output, log_sumexp=log_sumexp, philox_seed=philox_seed, philox_offset=philox_offset, query=query, key=key, value=value, attn_bias=attn_bias, compute_log_sumexp=compute_log_sumexp, dropout_p=dropout_p, is_causal=is_causal, scale=scale, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class Aten_ScaledDotProductFlashAttentionForCpuOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._scaled_dot_product_flash_attention_for_cpu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, logsumexp, query, key, value, dropout_p, is_causal, attn_mask, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(query)
    operands.append(key)
    operands.append(value)
    operands.append(dropout_p)
    operands.append(is_causal)
    operands.append(attn_mask)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    results.append(logsumexp)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def query(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def dropout_p(self):
    return self.operation.operands[3]

  @builtins.property
  def is_causal(self):
    return self.operation.operands[4]

  @builtins.property
  def attn_mask(self):
    return self.operation.operands[5]

  @builtins.property
  def scale(self):
    return self.operation.operands[6]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def logsumexp(self):
    return self.operation.results[1]

def aten__scaled_dot_product_flash_attention_for_cpu(output, logsumexp, query, key, value, dropout_p, is_causal, attn_mask, scale, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return Aten_ScaledDotProductFlashAttentionForCpuOp(output=output, logsumexp=logsumexp, query=query, key=key, value=value, dropout_p=dropout_p, is_causal=is_causal, attn_mask=attn_mask, scale=scale, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class Aten_ScaledDotProductFlashAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._scaled_dot_product_flash_attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, philox_seed, philox_offset, debug_attn_mask, query, key, value, dropout_p, is_causal, return_debug_mask, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(query)
    operands.append(key)
    operands.append(value)
    operands.append(dropout_p)
    operands.append(is_causal)
    operands.append(return_debug_mask)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    results.append(logsumexp)
    results.append(cum_seq_q)
    results.append(cum_seq_k)
    results.append(max_q)
    results.append(max_k)
    results.append(philox_seed)
    results.append(philox_offset)
    results.append(debug_attn_mask)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def query(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def dropout_p(self):
    return self.operation.operands[3]

  @builtins.property
  def is_causal(self):
    return self.operation.operands[4]

  @builtins.property
  def return_debug_mask(self):
    return self.operation.operands[5]

  @builtins.property
  def scale(self):
    return self.operation.operands[6]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def logsumexp(self):
    return self.operation.results[1]

  @builtins.property
  def cum_seq_q(self):
    return self.operation.results[2]

  @builtins.property
  def cum_seq_k(self):
    return self.operation.results[3]

  @builtins.property
  def max_q(self):
    return self.operation.results[4]

  @builtins.property
  def max_k(self):
    return self.operation.results[5]

  @builtins.property
  def philox_seed(self):
    return self.operation.results[6]

  @builtins.property
  def philox_offset(self):
    return self.operation.results[7]

  @builtins.property
  def debug_attn_mask(self):
    return self.operation.results[8]

def aten__scaled_dot_product_flash_attention(output, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, philox_seed, philox_offset, debug_attn_mask, query, key, value, dropout_p, is_causal, return_debug_mask, scale, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return Aten_ScaledDotProductFlashAttentionOp(output=output, logsumexp=logsumexp, cum_seq_q=cum_seq_q, cum_seq_k=cum_seq_k, max_q=max_q, max_k=max_k, philox_seed=philox_seed, philox_offset=philox_offset, debug_attn_mask=debug_attn_mask, query=query, key=key, value=value, dropout_p=dropout_p, is_causal=is_causal, return_debug_mask=return_debug_mask, scale=scale, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class Aten_SetItemStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._set_item.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, l, idx, v, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    operands.append(idx)
    operands.append(v)
    _ods_context = _ods_get_default_loc_context(loc)
    if result is not None: results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def v(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def aten__set_item_str(result, l, idx, v, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Aten_SetItemStrOp(result=result, l=l, idx=idx, v=v, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Aten_SetItemTOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._set_item.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, l, idx, el, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    operands.append(idx)
    operands.append(el)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def el(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__set_item_t(result, l, idx, el, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_SetItemTOp(result=result, l=l, idx=idx, el=el, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ShapeAsTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._shape_as_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__shape_as_tensor(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ShapeAsTensorOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_SoftmaxBackwardDataOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._softmax_backward_data"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, grad_output, output, dim, input_dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(grad_output)
    operands.append(output)
    operands.append(dim)
    operands.append(input_dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.operands[2]

  @builtins.property
  def input_dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__softmax_backward_data(result, grad_output, output, dim, input_dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_SoftmaxBackwardDataOp(result=result, grad_output=grad_output, output=output, dim=dim, input_dtype=input_dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dim, half_to_float, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dim)
    operands.append(half_to_float)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def half_to_float(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__softmax(result, self_, dim, half_to_float, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_SoftmaxOp(result=result, self_=self_, dim=dim, half_to_float=half_to_float, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_ToCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._to_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, dtype, layout, device, pin_memory, non_blocking, memory_format, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(dtype)
    operands.append(layout)
    operands.append(device)
    operands.append(pin_memory)
    operands.append(non_blocking)
    operands.append(memory_format)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.operands[2]

  @builtins.property
  def device(self):
    return self.operation.operands[3]

  @builtins.property
  def pin_memory(self):
    return self.operation.operands[4]

  @builtins.property
  def non_blocking(self):
    return self.operation.operands[5]

  @builtins.property
  def memory_format(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__to_copy(result, self_, dtype, layout, device, pin_memory, non_blocking, memory_format, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_ToCopyOp(result=result, self_=self_, dtype=dtype, layout=layout, device=device, pin_memory=pin_memory, non_blocking=non_blocking, memory_format=memory_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_UnsafeIndexTensorHackedTwinOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._unsafe_index.Tensor_hacked_twin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__unsafe_index_Tensor_hacked_twin(result, self_, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_UnsafeIndexTensorHackedTwinOp(result=result, self_=self_, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_UnsafeIndexTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._unsafe_index.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__unsafe_index_Tensor(result, self_, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_UnsafeIndexTensorOp(result=result, self_=self_, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_UnsafeViewOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._unsafe_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__unsafe_view(result, self_, size, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_UnsafeViewOp(result=result, self_=self_, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten_VSetItemStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten._vset_item.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, l, idx, v, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    operands.append(idx)
    operands.append(v)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def v(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten__vset_item_str(result, l, idx, v, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten_VSetItemStrOp(result=result, l=l, idx=idx, v=v, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__And__BoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__and__.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___and___bool(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__And__BoolOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__And__TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__and__.Tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, other, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(other)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def other(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___and___Tensor(result, self_, other, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__And__TensorOp(result=result, self_=self_, other=other, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Contains__IntListOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__contains__.int_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, l, item, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(l)
    operands.append(item)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def l(self):
    return self.operation.operands[0]

  @builtins.property
  def item(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___contains___int_list(l, item, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Contains__IntListOp(l=l, item=item, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Contains__StrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__contains__.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, dict, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(dict)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dict(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___contains___str(dict, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Contains__StrOp(dict=dict, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__DeriveIndexOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__derive_index"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, start, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(start)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___derive_index(index, start, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__DeriveIndexOp(index=index, start=start, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Getitem__DictStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__getitem__.Dict_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___getitem___Dict_str(result, self_, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Getitem__DictStrOp(result=result, self_=self_, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Getitem__TOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__getitem__.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, idx, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(idx)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___getitem___t(result, list, idx, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Getitem__TOp(result=result, list=list, idx=idx, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Is__Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__is__"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, obj, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(obj)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def obj(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___is__(self_, obj, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Is__Op(self_=self_, obj=obj, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Isnot__Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__isnot__"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, obj, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(obj)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def obj(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___isnot__(self_, obj, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Isnot__Op(self_=self_, obj=obj, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__Not__Op(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__not__"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___not__(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__Not__Op(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__RangeLengthOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__range_length"

  _ODS_REGIONS = (0, True)

  def __init__(self, lo, hi, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lo)
    operands.append(hi)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lo(self):
    return self.operation.operands[0]

  @builtins.property
  def hi(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___range_length(lo, hi, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__RangeLengthOp(lo=lo, hi=hi, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__VGetitem__DictStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__vgetitem__.Dict_str"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___vgetitem___Dict_str(result, self_, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__VGetitem__DictStrOp(result=result, self_=self_, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Aten__VGetitem__TOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.aten.__vgetitem__.t"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, idx, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(idx)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aten___vgetitem___t(result, list, idx, *, loc=None, ip=None) -> _ods_ir.Value:
  return Aten__VGetitem__TOp(result=result, list=list, idx=idx, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AttrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.attr"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, type_, *, isPrivate=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(isPrivate): attributes["isPrivate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def isPrivate(self):
    return "isPrivate" in self.operation.attributes

  @isPrivate.setter
  def isPrivate(self, value):
    if bool(value):
      self.operation.attributes["isPrivate"] = _ods_ir.UnitAttr.get()
    elif "isPrivate" in self.operation.attributes:
      del self.operation.attributes["isPrivate"]

  @isPrivate.deleter
  def isPrivate(self):
    del self.operation.attributes["isPrivate"]

def attr(name, type_, *, is_private=None, loc=None, ip=None) -> _ods_ir.Operation:
  return AttrOp(name=name, type_=type_, isPrivate=is_private, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClassTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.class_type"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def region(self):
    return self.regions[0]

def class_type(sym_name, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ClassTypeOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClassTypeTerminatorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.class_type_terminator"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def class_type_terminator(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ClassTypeTerminatorOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConstantBoolOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.bool"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_bool(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantBoolOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_device(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantDeviceOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_float(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantFloatOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyI64Attr')) else
      _ods_ir.AttrBuilder.get('AnyI64Attr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_int(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantIntOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantNoneOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.none"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_none(*, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantNoneOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantNumberOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.number"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_510')) else
      _ods_ir.AttrBuilder.get('anonymous_510')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_number(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantNumberOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantStrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.constant.str"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_str(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantStrOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyToNonValueTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.copy.to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def copy_to_tensor(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CopyToNonValueTensorOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyToValueTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.copy.to_vtensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def copy_to_vtensor(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CopyToValueTensorOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeepCopyToNonValueTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.deep_copy.to_nonvalue_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def deep_copy_to_nonvalue_type(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return DeepCopyToNonValueTypeOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeepCopyToValueTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.deep_copy.to_value_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def deep_copy_to_value_type(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return DeepCopyToValueTypeOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DerefineOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.derefine"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def derefine(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return DerefineOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DtypeCalculateOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.dtype.calculate"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

  @builtins.property
  def calculation(self):
    return self.regions[1]

def dtype_calculate(results_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DtypeCalculateOp(results_=results_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DtypeCalculateYieldDtypesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.dtype.calculate.yield.dtypes"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def dtype_calculate_yield_dtypes(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DtypeCalculateYieldDtypesOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DtypeCalculateYieldOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.dtype.calculate.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def dtype_calculate_yield(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DtypeCalculateYieldOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalSlotGetOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.global_slot.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, slot, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slot"] = (slot if (
    isinstance(slot, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(slot, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def slot(self):
    return self.operation.attributes["slot"]

  @slot.setter
  def slot(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slot"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_slot_get(result, slot, *, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalSlotGetOp(result=result, slot=slot, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalSlotInitOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.global_slot.init"

  _ODS_REGIONS = (0, True)

  def __init__(self, initialValue, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(initialValue)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initialValue(self):
    return self.operation.operands[0]

def global_slot_init(initial_value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalSlotInitOp(initialValue=initial_value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalSlotModuleInitializerOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.global_slot.module_initializer"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initializer(self):
    return self.regions[0]

def global_slot_module_initializer(*, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalSlotModuleInitializerOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalSlotOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.global_slot"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, typeBound, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["typeBound"] = (typeBound if (
    isinstance(typeBound, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(typeBound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def typeBound(self):
    return self.operation.attributes["typeBound"]

  @typeBound.setter
  def typeBound(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["typeBound"] = value

def global_slot(sym_name, type_bound, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalSlotOp(sym_name=sym_name, typeBound=type_bound, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalSlotSetOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.global_slot.set"

  _ODS_REGIONS = (0, True)

  def __init__(self, slot, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slot"] = (slot if (
    isinstance(slot, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(slot, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def slot(self):
    return self.operation.attributes["slot"]

  @slot.setter
  def slot(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slot"] = value

def global_slot_set(slot, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalSlotSetOp(slot=slot, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitializeGlobalSlotsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.initialize.global_slots"

  _ODS_REGIONS = (0, True)

  def __init__(self, slotSymNames, initialValues, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(initialValues))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slotSymNames"] = (slotSymNames if (
    isinstance(slotSymNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(slotSymNames, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initialValues(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def slotSymNames(self):
    return self.operation.attributes["slotSymNames"]

  @slotSymNames.setter
  def slotSymNames(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slotSymNames"] = value

def initialize_global_slots(slot_sym_names, initial_values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return InitializeGlobalSlotsOp(slotSymNames=slot_sym_names, initialValues=initial_values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LinearParamsCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.linear_params.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, weight, *, bias=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(weight)
    if bias is not None: operands.append(bias)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self):
    return self.operation.operands[0]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def linear_params_create(weight, *, bias=None, loc=None, ip=None) -> _ods_ir.Value:
  return LinearParamsCreateOp(weight=weight, bias=bias, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MethodOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.method"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, function, *, isPrivate=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["function"] = (function if (
    isinstance(function, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function, context=_ods_context))
    if bool(isPrivate): attributes["isPrivate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def function(self):
    return self.operation.attributes["function"]

  @function.setter
  def function(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function"] = value

  @builtins.property
  def isPrivate(self):
    return "isPrivate" in self.operation.attributes

  @isPrivate.setter
  def isPrivate(self, value):
    if bool(value):
      self.operation.attributes["isPrivate"] = _ods_ir.UnitAttr.get()
    elif "isPrivate" in self.operation.attributes:
      del self.operation.attributes["isPrivate"]

  @isPrivate.deleter
  def isPrivate(self):
    del self.operation.attributes["isPrivate"]

def method(name, function, *, is_private=None, loc=None, ip=None) -> _ods_ir.Operation:
  return MethodOp(name=name, function=function, isPrivate=is_private, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MojoCustomDtypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.mojo.custom.dtype"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, name, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def mojo_custom_dtype(results_, name, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MojoCustomDtypeOp(results_=results_, name=name, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MojoCustomOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.mojo.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, name, operands_, *, function=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if function is not None: attributes["function"] = (function if (
        isinstance(function, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(function, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def function(self):
    return self.operation.attributes["function"]

  @function.setter
  def function(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def mojo_custom(results_, name, operands_, *, function=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MojoCustomOp(results_=results_, name=name, operands_=operands_, function=function, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MojoCustomShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.mojo.custom.shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, name, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def mojo_custom_shape(results_, name, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MojoCustomShapeOp(results_=results_, name=name, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NnModuleOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.nn_module"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def region(self):
    return self.regions[0]

def nn_module(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return NnModuleOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NnModuleTerminatorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.nn_module_terminator"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def nn_module_terminator(*, loc=None, ip=None) -> _ods_ir.Operation:
  return NnModuleTerminatorOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NonValueTensorLiteralOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.tensor.literal"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, device=None, externalize=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    if device is not None: attributes["device"] = (device if (
        isinstance(device, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(device, context=_ods_context))
    if externalize is not None: attributes["externalize"] = (externalize if (
        isinstance(externalize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(externalize, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def device(self):
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def externalize(self):
    return self.operation.attributes["externalize"]

  @externalize.setter
  def externalize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["externalize"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_literal(value, *, device=None, externalize=None, loc=None, ip=None) -> _ods_ir.Value:
  return NonValueTensorLiteralOp(value=value, device=device, externalize=externalize, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OperatorOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.operator"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, name, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def operator(results_, name, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(OperatorOp(results_=results_, name=name, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class OverwriteTensorContentsOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.overwrite.tensor.contents"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, overwritten, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(overwritten)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def overwritten(self):
    return self.operation.operands[1]

def overwrite_tensor_contents(value, overwritten, *, loc=None, ip=None) -> _ods_ir.Operation:
  return OverwriteTensorContentsOp(value=value, overwritten=overwritten, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PerTensorAffineCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.per_tensor_affine.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, int_repr, scale, offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(int_repr)
    operands.append(scale)
    operands.append(offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def int_repr(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def per_tensor_affine_create(result, int_repr, scale, offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return PerTensorAffineCreateOp(result=result, int_repr=int_repr, scale=scale, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimAbsScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.abs.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_abs_Scalar(result, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimAbsScalarOp(result=result, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimCallMethodOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.CallMethod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, receiver, methodOperands, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(receiver)
    operands.extend(_get_op_results_or_values(methodOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def receiver(self):
    return self.operation.operands[0]

  @builtins.property
  def methodOperands(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_CallMethod(result, name, receiver, method_operands, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimCallMethodOp(result=result, name=name, receiver=receiver, methodOperands=method_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimCreateObjectOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.CreateObject"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_CreateObject(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimCreateObjectOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_device(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimDeviceOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimDictConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.DictConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, keys, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(keys))
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def keys(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def values(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_DictConstruct(result, keys, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimDictConstructOp(result=result, keys=keys, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimDtypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.dtype"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_dtype(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimDtypeOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimEnterOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Enter"

  _ODS_REGIONS = (0, True)

  def __init__(self, inp, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(inp)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inp(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_Enter(inp, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimEnterOp(inp=inp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimExitOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Exit"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inp, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(inp)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inp(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_Exit(result, inp, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimExitOp(result=result, inp=inp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimGetAttrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.GetAttr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, receiver, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(receiver)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def receiver(self):
    return self.operation.operands[0]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_GetAttr(result, name, receiver, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimGetAttrOp(result=result, name=name, receiver=receiver, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimIfOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.If"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, condition, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def thenRegion(self):
    return self.regions[0]

  @builtins.property
  def elseRegion(self):
    return self.regions[1]

def prim_If(results_, condition, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PrimIfOp(results_=results_, condition=condition, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrimIfYieldOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.If.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def prim_If_yield(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimIfYieldOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_layout(a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimLayoutOp(a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimListConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.ListConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, elements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_ListConstruct(result, elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimListConstructOp(result=result, elements=elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimListUnpackOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.ListUnpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def prim_ListUnpack(results_, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PrimListUnpackOp(results_=results_, operand=operand, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrimLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_Load(result, name, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimLoadOp(result=result, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimLoopConditionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Loop.condition"

  _ODS_REGIONS = (0, True)

  def __init__(self, shouldContinue, iterArgs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(shouldContinue)
    operands.extend(_get_op_results_or_values(iterArgs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shouldContinue(self):
    return self.operation.operands[0]

  @builtins.property
  def iterArgs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

def prim_Loop_condition(should_continue, iter_args, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimLoopConditionOp(shouldContinue=should_continue, iterArgs=iter_args, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimLoopOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, maxTripCount, initialCondition, iterArgsInit, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(maxTripCount)
    operands.append(initialCondition)
    operands.extend(_get_op_results_or_values(iterArgsInit))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def maxTripCount(self):
    return self.operation.operands[0]

  @builtins.property
  def initialCondition(self):
    return self.operation.operands[1]

  @builtins.property
  def iterArgsInit(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def prim_Loop(results_, max_trip_count, initial_condition, iter_args_init, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PrimLoopOp(results_=results_, maxTripCount=max_trip_count, initialCondition=initial_condition, iterArgsInit=iter_args_init, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrimMaxIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.max.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_max_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimMaxIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimMaxSelfIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.max.self_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_max_self_int(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimMaxSelfIntOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimMinIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.min.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_min_int(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimMinIntOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimMinSelfIntOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.min.self_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_min_self_int(self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimMinSelfIntOp(self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimNumToTensorScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.NumToTensor.Scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_NumToTensor_Scalar(result, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimNumToTensorScalarOp(result=result, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimPrintOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Print"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def prim_Print(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimPrintOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimRaiseExceptionOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.RaiseException"

  _ODS_REGIONS = (0, True)

  def __init__(self, msg, cls, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(msg)
    operands.append(cls)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def msg(self):
    return self.operation.operands[0]

  @builtins.property
  def cls(self):
    return self.operation.operands[1]

def prim_RaiseException(msg, cls, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimRaiseExceptionOp(msg=msg, cls=cls, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimSetAttrOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.SetAttr"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, receiver, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(receiver)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def receiver(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def prim_SetAttr(name, receiver, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimSetAttrOp(name=name, receiver=receiver, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Store"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def prim_Store(name, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrimStoreOp(name=name, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrimTolistOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.tolist"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def prim_tolist(results_, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PrimTolistOp(results_=results_, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrimTupleConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.TupleConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, elements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_TupleConstruct(result, elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimTupleConstructOp(result=result, elements=elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimTupleIndexOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.TupleIndex"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tup, i, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(tup)
    operands.append(i)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tup(self):
    return self.operation.operands[0]

  @builtins.property
  def i(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_TupleIndex(result, tup, i, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimTupleIndexOp(result=result, tup=tup, i=i, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimTupleUnpackOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.TupleUnpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, tup, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(tup)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tup(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def prim_TupleUnpack(results_, tup, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PrimTupleUnpackOp(results_=results_, tup=tup, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrimUncheckedCastOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.unchecked_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_unchecked_cast(result, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimUncheckedCastOp(result=result, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimUninitializedOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.Uninitialized"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_Uninitialized(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimUninitializedOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimValueDictConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.ValueDictConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, keys, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(keys))
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def keys(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def values(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_ValueDictConstruct(result, keys, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimValueDictConstructOp(result=result, keys=keys, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimValueListConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prim.ValueListConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, elements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prim_ValueListConstruct(result, elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimValueListConstructOp(result=result, elements=elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimsConvertElementTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prims.convert_element_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prims_convert_element_type(result, a, dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimsConvertElementTypeOp(result=result, a=a, dtype=dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimsSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prims.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prims_sqrt(result, self_, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimsSqrtOp(result=result, self_=self_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimsSqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prims.squeeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(dimensions)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def dimensions(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prims_squeeze(result, a, dimensions, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimsSqueezeOp(result=result, a=a, dimensions=dimensions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimsVarOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prims.var"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inp, dims, correction, output_dtype, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(inp)
    operands.append(dims)
    operands.append(correction)
    operands.append(output_dtype)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inp(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.operands[1]

  @builtins.property
  def correction(self):
    return self.operation.operands[2]

  @builtins.property
  def output_dtype(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prims_var(result, inp, dims, correction, output_dtype, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimsVarOp(result=result, inp=inp, dims=dims, correction=correction, output_dtype=output_dtype, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrimsViewOfOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.prims.view_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prims_view_of(result, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrimsViewOfOp(result=result, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PromoteDtypesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.promote_dtypes"

  _ODS_REGIONS = (0, True)

  def __init__(self, ranks, dtypes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(ranks)
    operands.append(dtypes)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ranks(self):
    return self.operation.operands[0]

  @builtins.property
  def dtypes(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def promote_dtypes(ranks, dtypes, *, loc=None, ip=None) -> _ods_ir.Value:
  return PromoteDtypesOp(ranks=ranks, dtypes=dtypes, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class QuantizedLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.quantized.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, X, W_prepack, Y_scale_i, Y_zero_point_i, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(X)
    operands.append(W_prepack)
    operands.append(Y_scale_i)
    operands.append(Y_zero_point_i)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(Y)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def X(self):
    return self.operation.operands[0]

  @builtins.property
  def W_prepack(self):
    return self.operation.operands[1]

  @builtins.property
  def Y_scale_i(self):
    return self.operation.operands[2]

  @builtins.property
  def Y_zero_point_i(self):
    return self.operation.operands[3]

  @builtins.property
  def Y(self):
    return self.operation.results[0]

def quantized_linear(y, x, w_prepack, y_scale_i, y_zero_point_i, *, loc=None, ip=None) -> _ods_ir.Value:
  return QuantizedLinearOp(Y=y, X=x, W_prepack=w_prepack, Y_scale_i=y_scale_i, Y_zero_point_i=y_zero_point_i, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeAssertOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.runtime.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, message, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def runtime_assert(condition, message, *, loc=None, ip=None) -> _ods_ir.Operation:
  return RuntimeAssertOp(condition=condition, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ShapeCalculateOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.shape.calculate"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

  @builtins.property
  def calculation(self):
    return self.regions[1]

def shape_calculate(results_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ShapeCalculateOp(results_=results_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ShapeCalculateYieldOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.shape.calculate.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def shape_calculate_yield(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ShapeCalculateYieldOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ShapeCalculateYieldShapesOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.shape.calculate.yield.shapes"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def shape_calculate_yield_shapes(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ShapeCalculateYieldShapesOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SlotOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.slot"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def slot(name, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SlotOp(name=name, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorStaticInfoCastOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.tensor_static_info_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_static_info_cast(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorStaticInfoCastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TorchvisionRoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.torchvision.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, rois, spatial_scale, pooled_height, pooled_width, sampling_ratio, aligned, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rois)
    operands.append(spatial_scale)
    operands.append(pooled_height)
    operands.append(pooled_width)
    operands.append(sampling_ratio)
    operands.append(aligned)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def spatial_scale(self):
    return self.operation.operands[2]

  @builtins.property
  def pooled_height(self):
    return self.operation.operands[3]

  @builtins.property
  def pooled_width(self):
    return self.operation.operands[4]

  @builtins.property
  def sampling_ratio(self):
    return self.operation.operands[5]

  @builtins.property
  def aligned(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def torchvision_roi_align(result, input, rois, spatial_scale, pooled_height, pooled_width, sampling_ratio, aligned, *, loc=None, ip=None) -> _ods_ir.Value:
  return TorchvisionRoiAlignOp(result=result, input=input, rois=rois, spatial_scale=spatial_scale, pooled_height=pooled_height, pooled_width=pooled_width, sampling_ratio=sampling_ratio, aligned=aligned, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValsemVariantAtenBernoulliFloatOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.valsem.aten.bernoulli.float"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, self_, p, generator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(self_)
    operands.append(p)
    operands.append(generator)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def self_(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.operands[1]

  @builtins.property
  def generator(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def valsem_aten_bernoulli_float(result, self_, p, generator, *, loc=None, ip=None) -> _ods_ir.Value:
  return ValsemVariantAtenBernoulliFloatOp(result=result, self_=self_, p=p, generator=generator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValueTensorLiteralOp(_ods_ir.OpView):
  OPERATION_NAME = "torch.vtensor.literal"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, device=None, externalize=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    if device is not None: attributes["device"] = (device if (
        isinstance(device, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(device, context=_ods_context))
    if externalize is not None: attributes["externalize"] = (externalize if (
        isinstance(externalize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(externalize, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def device(self):
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def externalize(self):
    return self.operation.attributes["externalize"]

  @externalize.setter
  def externalize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["externalize"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def vtensor_literal(value, *, device=None, externalize=None, loc=None, ip=None) -> _ods_ir.Value:
  return ValueTensorLiteralOp(value=value, device=device, externalize=externalize, loc=loc, ip=ip).result
