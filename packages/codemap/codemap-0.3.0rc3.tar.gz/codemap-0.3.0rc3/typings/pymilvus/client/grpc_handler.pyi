"""
This type stub file was generated by pyright.
"""

import grpc
from typing import Any, Callable, Dict, List, Mapping, Optional, Union
from pymilvus.decorators import ignore_unimplemented, retry_on_rpc_failure
from . import utils
from .abstract import AnnSearchRequest, BaseRanker
from .types import BulkInsertState, CompactionPlans, CompactionState, Replica, ReplicaInfo, ResourceGroupConfig, ResourceGroupInfo

class GrpcHandler:
    def __init__(self, uri: str = ..., host: str = ..., port: str = ..., channel: Optional[grpc.Channel] = ..., **kwargs) -> None:
        ...
    
    def register_state_change_callback(self, callback: Callable): # -> None:
        ...
    
    def deregister_state_change_callbacks(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self: object, exc_type: object, exc_val: object, exc_tb: object): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def reset_db_name(self, db_name: str): # -> None:
        ...
    
    def set_onetime_loglevel(self, log_level: str): # -> None:
        ...
    
    def set_onetime_request_id(self, req_id: int): # -> None:
        ...
    
    @property
    def server_address(self): # -> str:
        """Server network address"""
        ...
    
    def get_server_type(self): # -> Literal['zilliz', 'milvus']:
        ...
    
    def reset_password(self, user: str, old_password: str, new_password: str, timeout: Optional[float] = ...): # -> None:
        """
        reset password and then setup the grpc channel.
        """
        ...
    
    @retry_on_rpc_failure()
    def create_collection(self, collection_name: str, fields: List, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_collection(self, collection_name: str, timeout: Optional[float] = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def alter_collection_properties(self, collection_name: str, properties: Dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def alter_collection_field_properties(self, collection_name: str, field_name: str, field_params: List, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_collection_properties(self, collection_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def has_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> bool:
        ...
    
    @retry_on_rpc_failure()
    def describe_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> dict[Any, Any] | dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    def list_collections(self, timeout: Optional[float] = ...): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    def rename_collections(self, old_name: str, new_name: str, new_db_name: str = ..., timeout: Optional[float] = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def create_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def has_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def get_partition_info(self, collection_name: str, partition_name: str, timeout: Optional[float] = ...): # -> dict[Any, Any]:
        ...
    
    @retry_on_rpc_failure()
    def list_partitions(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    def get_partition_stats(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def insert_rows(self, collection_name: str, entities: Union[Dict, List[Dict]], partition_name: Optional[str] = ..., schema: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    def update_schema(self, collection_name: str, timeout: Optional[float] = ...):
        ...
    
    @retry_on_rpc_failure()
    def batch_insert(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationFuture | MutationResult:
        ...
    
    @retry_on_rpc_failure()
    def delete(self, collection_name: str, expression: str, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationFuture | MutationResult:
        ...
    
    @retry_on_rpc_failure()
    def upsert(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationFuture | MutationResult:
        ...
    
    @retry_on_rpc_failure()
    def upsert_rows(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    def search(self, collection_name: str, data: Union[List[List[float]], utils.SparseMatrixInputType], anns_field: str, param: Dict, limit: int, expression: Optional[str] = ..., partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., **kwargs): # -> SearchFuture | SearchResult:
        ...
    
    @retry_on_rpc_failure()
    def hybrid_search(self, collection_name: str, reqs: List[AnnSearchRequest], rerank: BaseRanker, limit: int, partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., **kwargs): # -> SearchFuture | SearchResult:
        ...
    
    @retry_on_rpc_failure()
    def get_query_segment_info(self, collection_name: str, timeout: float = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def create_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def alter_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def describe_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> dict[str, str]:
        ...
    
    @retry_on_rpc_failure()
    def list_aliases(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> dict[str, list[Any]]:
        ...
    
    @retry_on_rpc_failure()
    def create_index(self, collection_name: str, field_name: str, params: Dict, timeout: Optional[float] = ..., **kwargs): # -> CreateIndexFuture | Status:
        ...
    
    @retry_on_rpc_failure()
    def alter_index_properties(self, collection_name: str, index_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_index_properties(self, collection_name: str, index_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def list_indexes(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    def describe_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., timestamp: Optional[int] = ..., **kwargs): # -> dict[Any, Any] | None:
        ...
    
    @retry_on_rpc_failure()
    def get_index_build_progress(self, collection_name: str, index_name: str, timeout: Optional[float] = ...): # -> dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    def get_index_state(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., timestamp: Optional[int] = ..., **kwargs): # -> tuple[Any, Any]:
        ...
    
    @retry_on_rpc_failure()
    def wait_for_creating_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> tuple[Literal[True], Any] | tuple[Literal[False], Any]:
        ...
    
    @retry_on_rpc_failure()
    def load_collection(self, collection_name: str, replica_number: int = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def load_collection_progress(self, collection_name: str, timeout: Optional[float] = ...): # -> dict[str, str]:
        """Return loading progress of collection"""
        ...
    
    @retry_on_rpc_failure()
    def wait_for_loading_collection(self, collection_name: str, timeout: Optional[float] = ..., is_refresh: bool = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def release_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def load_partitions(self, collection_name: str, partition_names: List[str], replica_number: int = ..., timeout: Optional[float] = ..., **kwargs): # -> LoadPartitionsFuture | None:
        ...
    
    @retry_on_rpc_failure()
    def wait_for_loading_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., is_refresh: bool = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def get_loading_progress(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., is_refresh: bool = ...):
        ...
    
    @retry_on_rpc_failure()
    def create_database(self, db_name: str, properties: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_database(self, db_name: str, timeout: Optional[float] = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def list_database(self, timeout: Optional[float] = ...): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    def alter_database(self, db_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_database_properties(self, db_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def describe_database(self, db_name: str, timeout: Optional[float] = ...): # -> Dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    def get_load_state(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ...): # -> LoadState:
        ...
    
    @retry_on_rpc_failure()
    def load_partitions_progress(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ...): # -> dict[str, str]:
        """Return loading progress of partitions"""
        ...
    
    @retry_on_rpc_failure()
    def release_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def get_collection_stats(self, collection_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def get_flush_state(self, segment_ids: List[int], collection_name: str, flush_ts: int, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def get_persistent_segment_infos(self, collection_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure(initial_back_off=1)
    def flush(self, collection_names: list, timeout: Optional[float] = ..., **kwargs): # -> FlushFuture | None:
        ...
    
    @retry_on_rpc_failure()
    def drop_index(self, collection_name: str, field_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def dummy(self, request_type: Any, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def fake_register_link(self, timeout: Optional[float] = ...):
        ...
    
    @retry_on_rpc_failure()
    def get(self, collection_name: str, ids: List[int], output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ...):
        ...
    
    @retry_on_rpc_failure()
    def query(self, collection_name: str, expr: str, output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs): # -> list[Any] | ExtraList:
        ...
    
    @retry_on_rpc_failure()
    def load_balance(self, collection_name: str, src_node_id: int, dst_node_ids: List[int], sealed_segment_ids: List[int], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def compact(self, collection_name: str, is_clustering: Optional[bool] = ..., timeout: Optional[float] = ..., **kwargs) -> int:
        ...
    
    @retry_on_rpc_failure()
    def get_compaction_state(self, compaction_id: int, timeout: Optional[float] = ..., **kwargs) -> CompactionState:
        ...
    
    @retry_on_rpc_failure()
    def wait_for_compaction_completed(self, compaction_id: int, timeout: Optional[float] = ..., **kwargs): # -> bool:
        ...
    
    @retry_on_rpc_failure()
    def get_compaction_plans(self, compaction_id: int, timeout: Optional[float] = ..., **kwargs) -> CompactionPlans:
        ...
    
    @retry_on_rpc_failure()
    def get_replicas(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> Replica:
        ...
    
    @retry_on_rpc_failure()
    def describe_replica(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[ReplicaInfo]:
        ...
    
    @retry_on_rpc_failure()
    def do_bulk_insert(self, collection_name: str, partition_name: str, files: List[str], timeout: Optional[float] = ..., **kwargs) -> int:
        ...
    
    @retry_on_rpc_failure()
    def get_bulk_insert_state(self, task_id: int, timeout: Optional[float] = ..., **kwargs) -> BulkInsertState:
        ...
    
    @retry_on_rpc_failure()
    def list_bulk_insert_tasks(self, limit: int, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> list:
        ...
    
    @retry_on_rpc_failure()
    def create_user(self, user: str, password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def update_password(self, user: str, old_password: str, new_password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def delete_user(self, user: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def list_usernames(self, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def create_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_role(self, role_name: str, force_drop: bool = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def add_user_to_role(self, username: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def remove_user_from_role(self, username: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def select_one_role(self, role_name: str, include_user_info: bool, timeout: Optional[float] = ..., **kwargs): # -> RoleInfo:
        ...
    
    @retry_on_rpc_failure()
    def select_all_role(self, include_user_info: bool, timeout: Optional[float] = ..., **kwargs): # -> RoleInfo:
        ...
    
    @retry_on_rpc_failure()
    def select_one_user(self, username: str, include_role_info: bool, timeout: Optional[float] = ..., **kwargs): # -> UserInfo:
        ...
    
    @retry_on_rpc_failure()
    def select_all_user(self, include_role_info: bool, timeout: Optional[float] = ..., **kwargs): # -> UserInfo:
        ...
    
    @retry_on_rpc_failure()
    def grant_privilege(self, role_name: str, object: str, object_name: str, privilege: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def revoke_privilege(self, role_name: str, object: str, object_name: str, privilege: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def grant_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def revoke_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def select_grant_for_one_role(self, role_name: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> GrantInfo:
        ...
    
    @retry_on_rpc_failure()
    def select_grant_for_role_and_object(self, role_name: str, object: str, object_name: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> GrantInfo:
        ...
    
    @retry_on_rpc_failure()
    def get_server_version(self, timeout: Optional[float] = ..., **kwargs) -> str:
        ...
    
    @retry_on_rpc_failure()
    def create_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def update_resource_groups(self, configs: Mapping[str, ResourceGroupConfig], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def list_resource_groups(self, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    def describe_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs) -> ResourceGroupInfo:
        ...
    
    @retry_on_rpc_failure()
    def transfer_node(self, source: str, target: str, num_node: int, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def transfer_replica(self, source: str, target: str, collection_name: str, num_replica: int, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def get_flush_all_state(self, flush_all_ts: int, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    def flush_all(self, timeout: Optional[float] = ..., **kwargs): # -> FlushFuture | None:
        ...
    
    @retry_on_rpc_failure()
    @ignore_unimplemented(0)
    def alloc_timestamp(self, timeout: Optional[float] = ...) -> int:
        ...
    
    @retry_on_rpc_failure()
    def create_privilege_group(self, privilege_group: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def drop_privilege_group(self, privilege_group: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def list_privilege_groups(self, timeout: Optional[float] = ..., **kwargs): # -> PrivilegeGroupInfo:
        ...
    
    @retry_on_rpc_failure()
    def add_privileges_to_group(self, privilege_group: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def remove_privileges_from_group(self, privilege_group: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    def run_analyzer(self, texts: Union[str, List[str]], analyzer_params: Union[str, Dict], with_hash: bool = ..., with_detail: bool = ..., timeout: Optional[float] = ..., **kwargs): # -> AnalyzeResult | list[AnalyzeResult]:
        ...
    


