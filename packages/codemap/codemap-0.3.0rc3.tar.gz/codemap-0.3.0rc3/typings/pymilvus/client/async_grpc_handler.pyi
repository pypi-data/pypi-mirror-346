"""
This type stub file was generated by pyright.
"""

import grpc
from typing import Callable, Dict, List, Optional, Union
from pymilvus.decorators import ignore_unimplemented, retry_on_rpc_failure
from . import utils
from .abstract import AnnSearchRequest, BaseRanker

class AsyncGrpcHandler:
    def __init__(self, uri: str = ..., host: str = ..., port: str = ..., channel: Optional[grpc.aio.Channel] = ..., **kwargs) -> None:
        ...
    
    def register_state_change_callback(self, callback: Callable): # -> None:
        ...
    
    def deregister_state_change_callbacks(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self: object, exc_type: object, exc_val: object, exc_tb: object): # -> None:
        ...
    
    async def close(self): # -> None:
        ...
    
    @property
    def server_address(self): # -> str:
        ...
    
    def get_server_type(self): # -> Literal['zilliz', 'milvus']:
        ...
    
    async def ensure_channel_ready(self): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_collection(self, collection_name: str, fields: List, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_collection(self, collection_name: str, timeout: Optional[float] = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def load_collection(self, collection_name: str, replica_number: int = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_loading_collection(self, collection_name: str, timeout: Optional[float] = ..., is_refresh: bool = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def get_loading_progress(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., is_refresh: bool = ...):
        ...
    
    @retry_on_rpc_failure()
    async def describe_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> dict[Any, Any] | dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    async def release_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def insert_rows(self, collection_name: str, entities: Union[Dict, List[Dict]], partition_name: Optional[str] = ..., schema: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def delete(self, collection_name: str, expression: str, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def upsert(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def upsert_rows(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def search(self, collection_name: str, data: Union[List[List[float]], utils.SparseMatrixInputType], anns_field: str, param: Dict, limit: int, expression: Optional[str] = ..., partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., **kwargs): # -> SearchResult:
        ...
    
    @retry_on_rpc_failure()
    async def hybrid_search(self, collection_name: str, reqs: List[AnnSearchRequest], rerank: BaseRanker, limit: int, partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., **kwargs): # -> SearchResult:
        ...
    
    @retry_on_rpc_failure()
    async def create_index(self, collection_name: str, field_name: str, params: Dict, timeout: Optional[float] = ..., **kwargs): # -> Status:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_creating_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> tuple[Literal[True], Any] | tuple[Literal[False], Any]:
        ...
    
    @retry_on_rpc_failure()
    async def get_index_state(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., timestamp: Optional[int] = ..., **kwargs): # -> tuple[Any, Any]:
        ...
    
    @retry_on_rpc_failure()
    async def drop_index(self, collection_name: str, field_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def load_partitions(self, collection_name: str, partition_names: List[str], replica_number: int = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_loading_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., is_refresh: bool = ...): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def release_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def get(self, collection_name: str, ids: List[int], output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ...):
        ...
    
    @retry_on_rpc_failure()
    async def query(self, collection_name: str, expr: str, output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs): # -> ExtraList:
        ...
    
    @retry_on_rpc_failure()
    @ignore_unimplemented(0)
    async def alloc_timestamp(self, timeout: Optional[float] = ...) -> int:
        ...
    


