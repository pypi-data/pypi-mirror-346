"""
This type stub file was generated by pyright.
"""

import contextlib
import pyarrow.fs

"""
Utility functions for testing
"""
def randsign(): # -> Literal[-1, 1]:
    """Randomly choose either 1 or -1.

    Returns
    -------
    sign : int
    """
    ...

@contextlib.contextmanager
def random_seed(seed): # -> Generator[None, Any, None]:
    """Set the random seed inside of a context manager.

    Parameters
    ----------
    seed : int
        The seed to set

    Notes
    -----
    This function is useful when you want to set a random seed but not affect
    the random state of other functions using the random module.
    """
    ...

def randdecimal(precision, scale): # -> Decimal:
    """Generate a random decimal value with specified precision and scale.

    Parameters
    ----------
    precision : int
        The maximum number of digits to generate. Must be an integer between 1
        and 38 inclusive.
    scale : int
        The maximum number of digits following the decimal point.  Must be an
        integer greater than or equal to 0.

    Returns
    -------
    decimal_value : decimal.Decimal
        A random decimal.Decimal object with the specified precision and scale.
    """
    ...

def random_ascii(length): # -> bytes:
    ...

def rands(nchars): # -> str:
    """
    Generate one random string.
    """
    ...

def memory_leak_check(f, metric=..., threshold=..., iterations=..., check_interval=...): # -> None:
    """
    Execute the function and try to detect a clear memory leak either internal
    to Arrow or caused by a reference counting problem in the Python binding
    implementation. Raises exception if a leak detected

    Parameters
    ----------
    f : callable
        Function to invoke on each iteration
    metric : {'rss', 'vms', 'shared'}, default 'rss'
        Attribute of psutil.Process.memory_info to use for determining current
        memory use
    threshold : int, default 128K
        Threshold in number of bytes to consider a leak
    iterations : int, default 10
        Total number of invocations of f
    check_interval : int, default 1
        Number of invocations of f in between each memory use check
    """
    ...

def get_modified_env_with_pythonpath(): # -> dict[str, str]:
    ...

def invoke_script(script_name, *args): # -> None:
    ...

@contextlib.contextmanager
def changed_environ(name, value): # -> Generator[None, Any, None]:
    """
    Temporarily set environment variable *name* to *value*.
    """
    ...

@contextlib.contextmanager
def change_cwd(path): # -> Generator[None, Any, None]:
    ...

@contextlib.contextmanager
def disabled_gc(): # -> Generator[None, Any, None]:
    ...

class FSProtocolClass:
    def __init__(self, path) -> None:
        ...
    
    def __fspath__(self): # -> str:
        ...
    


class ProxyHandler(pyarrow.fs.FileSystemHandler):
    """
    A dataset handler that proxies to an underlying filesystem.  Useful
    to partially wrap an existing filesystem with partial changes.
    """
    def __init__(self, fs) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def get_type_name(self):
        ...
    
    def normalize_path(self, path):
        ...
    
    def get_file_info(self, paths):
        ...
    
    def get_file_info_selector(self, selector):
        ...
    
    def create_dir(self, path, recursive):
        ...
    
    def delete_dir(self, path):
        ...
    
    def delete_dir_contents(self, path, missing_dir_ok):
        ...
    
    def delete_root_dir_contents(self):
        ...
    
    def delete_file(self, path):
        ...
    
    def move(self, src, dest):
        ...
    
    def copy_file(self, src, dest):
        ...
    
    def open_input_stream(self, path):
        ...
    
    def open_input_file(self, path):
        ...
    
    def open_output_stream(self, path, metadata):
        ...
    
    def open_append_stream(self, path, metadata):
        ...
    


@contextlib.contextmanager
def signal_wakeup_fd(*, warn_on_full_buffer=...): # -> Generator[socket, Any, None]:
    ...

def windows_has_tzdata(): # -> bool:
    """
    This is the default location where tz.cpp will look for (until we make
    this configurable at run-time)
    """
    ...

