# Cylestio Local Server - Database Schema Design

## Entity-Relationship Diagram

```
                                 ┌───────────────┐
                                 │    Agents     │
                                 │               │
                                 │ PK: agent_id  │
                                 └───────┬───────┘
                                         │
                                         │ generates
                                         ▼
┌────────────────┐              ┌─────────────────┐              ┌────────────────┐
│    Sessions    │◀─────────────│     Events      │─────────────▶│    Traces      │
│                │              │                 │              │                │
│ PK: session_id │              │ PK: id          │              │ PK: trace_id   │
│ FK: agent_id   │              │ FK: agent_id    │              │ FK: agent_id   │
└────────────────┘              │ FK: session_id  │              └────────┬───────┘
                                │ FK: trace_id    │                       │
                                └────────┬────────┘                       │
                                         │                                │
                                         │ specializes into               │
                                         ▼                                ▼
          ┌────────────────────┬─────────────────┬────────────────┐    ┌────────────────┐
          │                    │                 │                │    │     Spans      │
          ▼                    ▼                 ▼                ▼    │                │
┌─────────────────┐    ┌──────────────┐  ┌──────────────┐  ┌───────────┐ PK: span_id    │
│  LLM            │    │  Tool        │  │  Security    │  │ Framework │ FK: trace_id   │
│  Interactions   │    │  Interactions│  │  Alerts      │  │ Events    │ FK: parent_span│
│                 │    │              │  │              │  │           └────────────────┘
│ PK: id          │    │ PK: id       │  │ PK: id       │  │ PK: id    │
│ FK: event_id    │    │ FK: event_id │  │ FK: event_id │  │ FK: event_id
└────────┬────────┘    └──────┬───────┘  └───────┬──────┘  └─────┬─────┘
         │                    │                  │                │
         │ has                │ has              │ has            │ has
         ▼                    ▼                  ▼                ▼
┌─────────────────┐    ┌──────────────┐  ┌──────────────┐  ┌─────────────┐
│  LLM            │    │  Tool        │  │  Security    │  │ Framework   │
│  Attributes     │    │  Attributes  │  │  Attributes  │  │ Attributes  │
│                 │    │              │  │              │  │             │
│ PK: id          │    │ PK: id       │  │ PK: id       │  │ PK: id      │
│ FK: llm_id      │    │ FK: tool_id  │  │ FK: alert_id │  │ FK: frame_id│
└─────────────────┘    └──────────────┘  └──────────────┘  └─────────────┘
                                             ▲
                                             │ triggered by
                                             │
                                       ┌─────┴─────────────────┐
                                       │  Security Alert       │
                                       │  Triggers             │
                                       │                       │
                                       │ PK: id                │
                                       │ FK: alert_id          │
                                       │ FK: triggering_event_id│
                                       └───────────────────────┘
```

## Agent-Centric Design Philosophy

Our database schema is explicitly designed around the **Agent-Centric** principle. Agents are the core entity in our product, and all other entities relate back to agents either directly or indirectly. This design philosophy reflects the fundamental nature of our product, where agents are the primary subjects being monitored.

## Entity Descriptions

### 1. Agents
The central entity representing monitoring agents that generate telemetry data.
- **agent_id**: Unique identifier for the agent
- **first_seen_timestamp**: When the agent was first seen
- **last_seen_timestamp**: When the agent was last seen
- **version**: Agent version
- **monitoring_version**: Version of the monitoring tool
- **environment**: JSON data with environment details

### 2. Events
Telemetry records generated by agents. All events are connected to an agent.
- **id**: Unique identifier for the event
- **agent_id**: Reference to the agent that generated this event
- **session_id**: Reference to the session this event belongs to
- **trace_id**: Reference to the trace this event belongs to
- **span_id**: Reference to the span this event represents
- **parent_span_id**: Reference to the parent span if applicable
- **timestamp**: When the event occurred
- **schema_version**: Version of the schema
- **name**: Event name (e.g., "llm.call.start", "monitoring.start")
- **level**: Log level (INFO, WARNING, ERROR)
- **event_type**: Type of event (monitoring, llm, tool, security, etc.)

### 3. Sessions
User sessions containing multiple events.
- **session_id**: Unique identifier for the session
- **agent_id**: Reference to the agent associated with this session
- **start_timestamp**: When the session started
- **end_timestamp**: When the session ended

### 4. Traces
Group of related operations identified by trace_id.
- **trace_id**: Unique identifier for the trace
- **agent_id**: Reference to the agent associated with this trace
- **start_timestamp**: When the trace started
- **end_timestamp**: When the trace ended

### 5. Spans
Individual operations within a trace.
- **span_id**: Unique identifier for the span
- **trace_id**: Reference to the trace this span belongs to
- **parent_span_id**: Reference to the parent span if applicable
- **name**: Name of the span
- **start_timestamp**: When the span started
- **end_timestamp**: When the span ended

### 6. LLM Interactions
Specialized events for LLM API calls.
- **id**: Unique identifier for the LLM interaction
- **event_id**: Reference to the event this interaction represents
- **interaction_type**: Type of interaction (start or finish)
- **vendor**: LLM provider (e.g., "anthropic")
- **model**: Model used (e.g., "claude-3-haiku-20240307")
- **request_timestamp**: When the request was made
- **response_timestamp**: When the response was received
- **duration_ms**: Duration in milliseconds
- **input_tokens**: Number of input tokens
- **output_tokens**: Number of output tokens
- **total_tokens**: Total tokens used
- **request_data**: JSON data with request details
- **response_content**: JSON data with response content
- **response_id**: Unique identifier for the response
- **stop_reason**: Why the response generation stopped

### 7. Tool Interactions
Specialized events for tool usage.
- **id**: Unique identifier for the tool interaction
- **event_id**: Reference to the event this interaction represents
- **tool_name**: Name of the tool
- **tool_id**: Unique identifier for the tool
- **interaction_type**: Type of interaction (execution or result)
- **params**: JSON data with parameters
- **status**: Result status
- **result_type**: Type of the result
- **result_data**: JSON data with result details
- **framework_name**: Framework used
- **framework_type**: Type of framework

### 8. Security Alerts
Specialized events for security concerns.
- **id**: Unique identifier for the security alert
- **event_id**: Reference to the event this alert represents
- **alert_level**: Severity of the alert
- **keywords**: JSON array of flagged keywords
- **content_sample**: Sample of the suspicious content
- **detection_timestamp**: When the issue was detected

### 9. Security Alert Triggers
Links security alerts to the events that triggered them.
- **id**: Unique identifier for the trigger
- **security_alert_id**: Reference to the security alert
- **triggering_event_id**: Reference to the event that triggered the alert

### 10. Attributes Tables
Each specialized event type has its own attributes table:
- **LLM Attributes**: Attributes specific to LLM interactions
- **Tool Attributes**: Attributes specific to tool interactions
- **Security Attributes**: Attributes specific to security alerts
- **Framework Attributes**: Attributes specific to framework events

## Table Definitions

### Agents Table
```sql
CREATE TABLE agents (
    agent_id TEXT PRIMARY KEY,
    first_seen_timestamp TIMESTAMP NOT NULL,
    last_seen_timestamp TIMESTAMP NOT NULL,
    version TEXT,
    monitoring_version TEXT,
    environment JSON
);

CREATE INDEX idx_agents_timestamps ON agents(first_seen_timestamp, last_seen_timestamp);
```

### Sessions Table
```sql
CREATE TABLE sessions (
    session_id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL,
    start_timestamp TIMESTAMP NOT NULL,
    end_timestamp TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES agents(agent_id)
);

CREATE INDEX idx_sessions_agent_id ON sessions(agent_id);
CREATE INDEX idx_sessions_timestamps ON sessions(start_timestamp, end_timestamp);
```

### Traces Table
```sql
CREATE TABLE traces (
    trace_id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL,
    start_timestamp TIMESTAMP,
    end_timestamp TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES agents(agent_id)
);

CREATE INDEX idx_traces_agent_id ON traces(agent_id);
CREATE INDEX idx_traces_timestamps ON traces(start_timestamp, end_timestamp);
```

### Spans Table
```sql
CREATE TABLE spans (
    span_id TEXT PRIMARY KEY,
    trace_id TEXT NOT NULL,
    parent_span_id TEXT,
    name TEXT,
    start_timestamp TIMESTAMP,
    end_timestamp TIMESTAMP,
    FOREIGN KEY (trace_id) REFERENCES traces(trace_id)
);

CREATE INDEX idx_spans_trace_id ON spans(trace_id);
CREATE INDEX idx_spans_parent_id ON spans(parent_span_id);
```

### Events Table
```sql
CREATE TABLE events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    agent_id TEXT NOT NULL,
    session_id TEXT,
    trace_id TEXT,
    span_id TEXT,
    parent_span_id TEXT,
    timestamp TIMESTAMP NOT NULL,
    schema_version TEXT NOT NULL,
    name TEXT NOT NULL,
    level TEXT NOT NULL,
    event_type TEXT NOT NULL,
    FOREIGN KEY (agent_id) REFERENCES agents(agent_id),
    FOREIGN KEY (session_id) REFERENCES sessions(session_id),
    FOREIGN KEY (trace_id) REFERENCES traces(trace_id),
    FOREIGN KEY (span_id) REFERENCES spans(span_id)
);

CREATE INDEX idx_events_agent_id ON events(agent_id);
CREATE INDEX idx_events_session_id ON events(session_id);
CREATE INDEX idx_events_trace_id ON events(trace_id);
CREATE INDEX idx_events_timestamp ON events(timestamp);
CREATE INDEX idx_events_name ON events(name);
CREATE INDEX idx_events_type ON events(event_type);
CREATE INDEX idx_events_agent_timestamp ON events(agent_id, timestamp);
CREATE INDEX idx_events_agent_type ON events(agent_id, event_type);
```

### LLM Interactions Table
```sql
CREATE TABLE llm_interactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id INTEGER NOT NULL,
    interaction_type TEXT NOT NULL,
    vendor TEXT NOT NULL,
    model TEXT NOT NULL,
    request_timestamp TIMESTAMP,
    response_timestamp TIMESTAMP,
    duration_ms INTEGER,
    input_tokens INTEGER,
    output_tokens INTEGER,
    total_tokens INTEGER,
    request_data JSON,
    response_content JSON,
    response_id TEXT,
    stop_reason TEXT,
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE INDEX idx_llm_event_id ON llm_interactions(event_id);
CREATE INDEX idx_llm_model ON llm_interactions(model);
CREATE INDEX idx_llm_vendor ON llm_interactions(vendor);
CREATE INDEX idx_llm_timestamps ON llm_interactions(request_timestamp, response_timestamp);
```

### Tool Interactions Table
```sql
CREATE TABLE tool_interactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id INTEGER NOT NULL,
    tool_name TEXT NOT NULL,
    tool_id TEXT,
    interaction_type TEXT NOT NULL,
    params JSON,
    status TEXT,
    result_type TEXT,
    result_data JSON,
    framework_name TEXT,
    framework_type TEXT,
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE INDEX idx_tool_event_id ON tool_interactions(event_id);
CREATE INDEX idx_tool_name ON tool_interactions(tool_name);
CREATE INDEX idx_tool_status ON tool_interactions(status);
```

### Security Alerts Table
```sql
CREATE TABLE security_alerts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id INTEGER NOT NULL,
    alert_level TEXT NOT NULL,
    keywords JSON,
    content_sample TEXT,
    detection_timestamp TIMESTAMP NOT NULL,
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE INDEX idx_security_event_id ON security_alerts(event_id);
CREATE INDEX idx_security_level ON security_alerts(alert_level);
CREATE INDEX idx_security_timestamp ON security_alerts(detection_timestamp);
```

### Security Alert Triggers Table
```sql
CREATE TABLE security_alert_triggers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    security_alert_id INTEGER NOT NULL,
    triggering_event_id INTEGER NOT NULL,
    FOREIGN KEY (security_alert_id) REFERENCES security_alerts(id) ON DELETE CASCADE,
    FOREIGN KEY (triggering_event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE INDEX idx_security_alert_triggers ON security_alert_triggers(security_alert_id, triggering_event_id);
```

### LLM Attributes Table
```sql
CREATE TABLE llm_attributes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    llm_interaction_id INTEGER NOT NULL,
    key TEXT NOT NULL,
    value_text TEXT,
    value_numeric REAL,
    value_boolean BOOLEAN,
    value_type TEXT NOT NULL,
    FOREIGN KEY (llm_interaction_id) REFERENCES llm_interactions(id) ON DELETE CASCADE
);

CREATE INDEX idx_llm_attr_interaction_id ON llm_attributes(llm_interaction_id);
CREATE INDEX idx_llm_attr_key ON llm_attributes(key);
```

### Tool Attributes Table
```sql
CREATE TABLE tool_attributes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tool_interaction_id INTEGER NOT NULL,
    key TEXT NOT NULL,
    value_text TEXT,
    value_numeric REAL,
    value_boolean BOOLEAN,
    value_type TEXT NOT NULL,
    FOREIGN KEY (tool_interaction_id) REFERENCES tool_interactions(id) ON DELETE CASCADE
);

CREATE INDEX idx_tool_attr_interaction_id ON tool_attributes(tool_interaction_id);
CREATE INDEX idx_tool_attr_key ON tool_attributes(key);
```

### Framework Events Table
```sql
CREATE TABLE framework_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id INTEGER NOT NULL,
    framework_name TEXT NOT NULL,
    framework_type TEXT,
    action TEXT NOT NULL,
    patch_type TEXT,
    patch_components JSON,
    version TEXT,
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE INDEX idx_framework_event_id ON framework_events(event_id);
CREATE INDEX idx_framework_name ON framework_events(framework_name);
CREATE INDEX idx_framework_action ON framework_events(action);
```

## Common Query Patterns

### 1. Agent Activity Overview
```sql
SELECT 
    a.agent_id,
    COUNT(e.id) AS total_events,
    COUNT(DISTINCT e.session_id) AS total_sessions,
    MIN(e.timestamp) AS first_event,
    MAX(e.timestamp) AS last_event
FROM agents a
LEFT JOIN events e ON a.agent_id = e.agent_id
GROUP BY a.agent_id;
```

### 2. Agent Token Usage
```sql
SELECT 
    a.agent_id,
    l.model,
    SUM(l.input_tokens) AS total_input_tokens,
    SUM(l.output_tokens) AS total_output_tokens,
    SUM(l.total_tokens) AS total_tokens
FROM agents a
JOIN events e ON a.agent_id = e.agent_id
JOIN llm_interactions l ON e.id = l.event_id
WHERE l.interaction_type = 'finish'
AND e.timestamp BETWEEN ? AND ?
GROUP BY a.agent_id, l.model;
```

### 3. Agent Tool Usage
```sql
SELECT 
    a.agent_id,
    t.tool_name,
    COUNT(*) AS usage_count
FROM agents a
JOIN events e ON a.agent_id = e.agent_id
JOIN tool_interactions t ON e.id = t.event_id
WHERE t.interaction_type = 'execution'
AND e.timestamp BETWEEN ? AND ?
GROUP BY a.agent_id, t.tool_name
ORDER BY a.agent_id, usage_count DESC;
```

### 4. Agent Security Alerts
```sql
SELECT 
    a.agent_id,
    s.alert_level,
    COUNT(*) AS alert_count
FROM agents a
JOIN events e ON a.agent_id = e.agent_id
JOIN security_alerts s ON e.id = s.event_id
WHERE e.timestamp BETWEEN ? AND ?
GROUP BY a.agent_id, s.alert_level
ORDER BY a.agent_id, alert_count DESC;
```

### 5. Request-Response Pair Analysis
```sql
SELECT 
    req.id AS request_event_id,
    resp.id AS response_event_id,
    a.agent_id,
    req.timestamp AS request_time,
    resp.timestamp AS response_time,
    (julianday(resp.timestamp) - julianday(req.timestamp)) * 86400 AS response_time_seconds,
    li_req.model,
    li_resp.input_tokens,
    li_resp.output_tokens
FROM agents a
JOIN events req ON a.agent_id = req.agent_id
JOIN events resp ON req.trace_id = resp.trace_id
JOIN llm_interactions li_req ON req.id = li_req.event_id
JOIN llm_interactions li_resp ON resp.id = li_resp.event_id
WHERE req.name = 'llm.call.start'
AND resp.name = 'llm.call.finish'
AND li_req.span_id = li_resp.span_id
ORDER BY req.timestamp;
```

### 6. Session Analysis
```sql
SELECT 
    s.session_id,
    a.agent_id,
    COUNT(e.id) AS event_count,
    COUNT(DISTINCT t.trace_id) AS trace_count,
    MIN(e.timestamp) AS session_start,
    MAX(e.timestamp) AS session_end
FROM sessions s
JOIN agents a ON s.agent_id = a.agent_id
JOIN events e ON s.session_id = e.session_id
LEFT JOIN traces t ON e.trace_id = t.trace_id
GROUP BY s.session_id, a.agent_id;
```

### 7. Complete Trace Flow
```sql
WITH RECURSIVE span_tree AS (
    -- Start with root spans (no parent)
    SELECT 
        s.span_id, 
        s.parent_span_id, 
        e.name, 
        e.timestamp,
        0 AS level,
        s.span_id AS path
    FROM spans s
    JOIN events e ON s.span_id = e.span_id
    WHERE s.trace_id = ? AND s.parent_span_id IS NULL
    
    UNION ALL
    
    -- Add child spans
    SELECT 
        s.span_id, 
        s.parent_span_id, 
        e.name, 
        e.timestamp,
        st.level + 1,
        st.path || '.' || s.span_id
    FROM spans s
    JOIN events e ON s.span_id = e.span_id
    JOIN span_tree st ON s.parent_span_id = st.span_id
    WHERE s.trace_id = ?
)
SELECT 
    level,
    span_id,
    parent_span_id,
    name,
    timestamp
FROM span_tree
ORDER BY path;
```

### 8. Security Alert Investigations
```sql
SELECT 
    sa.id AS alert_id,
    sa.alert_level,
    sa.keywords,
    sa.content_sample,
    sa.detection_timestamp,
    e_trigger.id AS triggering_event_id,
    e_trigger.name AS triggering_event_name,
    e_trigger.timestamp AS triggering_event_time,
    a.agent_id
FROM security_alerts sa
JOIN events e_alert ON sa.event_id = e_alert.id
JOIN security_alert_triggers sat ON sa.id = sat.security_alert_id
JOIN events e_trigger ON sat.triggering_event_id = e_trigger.id
JOIN agents a ON e_alert.agent_id = a.agent_id
WHERE a.agent_id = ?
ORDER BY sa.detection_timestamp DESC;
```

## Design Decisions and Rationale

### 1. Agent-Centric Design
Our schema places agents at the center of the data model, reflecting that agents are the main focus of our product. All queries flow from agents to their related entities.

**Rationale**: Since the primary objective of our product is to monitor and analyze agent behavior, starting queries from the agent entity results in more intuitive and efficient data access patterns.

### 2. Specialized Event Tables
Rather than storing all event details in a single table, we use specialized tables for different event types (LLM interactions, tool interactions, security alerts).

**Rationale**: This approach:
- Improves query performance by avoiding excessive JOINs
- Provides type-specific validation
- Allows for specialized indexing strategies
- Makes the schema more maintainable and understandable

### 3. Flexible Attribute Storage
We implemented attribute tables for each specialized event type rather than a single generic attribute table.

**Rationale**: This design:
- Maintains proper normalization
- Improves query performance when accessing specific attribute types
- Provides stronger type safety and referential integrity
- Allows for type-specific indexing and querying strategies

### 4. Security Alert Triggers
We added a specialized relationship table to connect security alerts to the events that triggered them.

**Rationale**: This enables powerful security analysis capabilities:
- Tracking which actions commonly trigger security alerts
- Investigating the context around security alerts
- Creating better detection rules based on prior triggering patterns

### 5. Comprehensive Temporal Design
We added timestamp fields throughout the schema and robust indexing on these fields.

**Rationale**: Time-based queries are extremely common in monitoring systems:
- Performance analysis requires time range filtering
- Usage patterns emerge through temporal analysis
- Billing and cost allocation typically occur over time periods
- Security investigations rely on establishing precise timelines

## Scaling Considerations

### 1. Index Optimization
The schema includes carefully designed indexes to support common query patterns while minimizing overhead.

### 2. Partition Strategy
For larger deployments, consider time-based partitioning of the events table to improve query performance on recent data.

### 3. JSON Storage Efficiency
We use JSON for complex structures that don't need to be queried directly, balancing flexibility and performance.

### 4. Future Event Types
The schema design makes it easy to add new specialized event types by creating new tables that reference the events table, ensuring extensibility.

## SQLite Compatibility

The schema is fully compatible with SQLite, with these considerations:

1. SQLite doesn't enforce foreign key constraints by default; PRAGMA foreign_keys = ON must be set.
2. The TIMESTAMP type is implemented as TEXT in SQLite; proper ISO 8601 formatting should be used.
3. SQLite's JSON support is more limited than other databases; simple JSON operations should be prioritized. 