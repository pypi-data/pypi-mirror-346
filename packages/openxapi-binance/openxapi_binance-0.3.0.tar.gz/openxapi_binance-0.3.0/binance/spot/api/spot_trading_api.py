# coding: utf-8

"""
    Binance Spot API

    OpenAPI specification for Binance exchange - Spot API

    The version of the OpenAPI document: 0.3.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from binance.spot.models.create_order_list_oco_v3_resp import CreateOrderListOcoV3Resp
from binance.spot.models.create_order_list_oto_v3_resp import CreateOrderListOtoV3Resp
from binance.spot.models.create_order_list_otoco_v3_resp import CreateOrderListOtocoV3Resp
from binance.spot.models.create_order_oco_v3_resp import CreateOrderOcoV3Resp
from binance.spot.models.create_sor_order_v3_resp import CreateSorOrderV3Resp
from binance.spot.models.create_user_data_stream_v3_resp import CreateUserDataStreamV3Resp
from binance.spot.models.delete_order_list_v3_resp import DeleteOrderListV3Resp
from binance.spot.models.delete_order_v3_resp import DeleteOrderV3Resp
from binance.spot.models.get_account_commission_v3_resp import GetAccountCommissionV3Resp
from binance.spot.models.get_account_v3_resp import GetAccountV3Resp
from binance.spot.models.get_all_order_list_v3_resp_item import GetAllOrderListV3RespItem
from binance.spot.models.get_all_orders_v3_resp_item import GetAllOrdersV3RespItem
from binance.spot.models.get_avg_price_v3_resp import GetAvgPriceV3Resp
from binance.spot.models.get_depth_v3_resp import GetDepthV3Resp
from binance.spot.models.get_historical_trades_v3_resp_item import GetHistoricalTradesV3RespItem
from binance.spot.models.get_klines_v3200_response_inner_inner import GetKlinesV3200ResponseInnerInner
from binance.spot.models.get_my_allocations_v3_resp_item import GetMyAllocationsV3RespItem
from binance.spot.models.get_my_prevented_matches_v3_resp_item import GetMyPreventedMatchesV3RespItem
from binance.spot.models.get_my_trades_v3_resp_item import GetMyTradesV3RespItem
from binance.spot.models.get_open_order_list_v3_resp_item import GetOpenOrderListV3RespItem
from binance.spot.models.get_open_orders_v3_resp_item import GetOpenOrdersV3RespItem
from binance.spot.models.get_order_list_v3_resp import GetOrderListV3Resp
from binance.spot.models.get_order_v3_resp import GetOrderV3Resp
from binance.spot.models.get_rate_limit_order_v3_resp_item import GetRateLimitOrderV3RespItem
from binance.spot.models.get_time_v3_resp import GetTimeV3Resp
from binance.spot.models.get_trades_v3_resp_item import GetTradesV3RespItem
from binance.spot.models.spot_create_order_cancel_replace_v3_resp import SpotCreateOrderCancelReplaceV3Resp
from binance.spot.models.spot_create_order_test_v3_resp import SpotCreateOrderTestV3Resp
from binance.spot.models.spot_create_order_v3_resp import SpotCreateOrderV3Resp
from binance.spot.models.spot_create_sor_order_test_v3_resp import SpotCreateSorOrderTestV3Resp
from binance.spot.models.spot_delete_open_orders_v3_resp_inner import SpotDeleteOpenOrdersV3RespInner
from binance.spot.models.spot_get_agg_trades_v3_resp_item import SpotGetAggTradesV3RespItem
from binance.spot.models.spot_get_exchange_info_v3_resp import SpotGetExchangeInfoV3Resp
from binance.spot.models.spot_get_ticker24hr_v3_resp import SpotGetTicker24hrV3Resp
from binance.spot.models.spot_get_ticker_book_ticker_v3_resp import SpotGetTickerBookTickerV3Resp
from binance.spot.models.spot_get_ticker_price_v3_resp import SpotGetTickerPriceV3Resp
from binance.spot.models.spot_get_ticker_trading_day_v3_resp import SpotGetTickerTradingDayV3Resp
from binance.spot.models.spot_get_ticker_v3_resp import SpotGetTickerV3Resp

from binance.spot.api_client import ApiClient, RequestSerialized
from binance.spot.api_response import ApiResponse
from binance.spot.rest import RESTResponseType


class SpotTradingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_order_cancel_replace_v3(
        self,
        cancel_replace_mode: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        cancel_new_client_order_id: Optional[StrictStr] = None,
        cancel_order_id: Optional[StrictInt] = None,
        cancel_orig_client_order_id: Optional[StrictStr] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        order_rate_limit_exceeded_mode: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotCreateOrderCancelReplaceV3Resp:
        """Cancel an Existing Order and Send a New Order (TRADE)

        Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

        :param cancel_replace_mode: (required)
        :type cancel_replace_mode: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param cancel_new_client_order_id:
        :type cancel_new_client_order_id: str
        :param cancel_order_id:
        :type cancel_order_id: int
        :param cancel_orig_client_order_id:
        :type cancel_orig_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param order_rate_limit_exceeded_mode:
        :type order_rate_limit_exceeded_mode: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_cancel_replace_v3_serialize(
            cancel_replace_mode=cancel_replace_mode,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_order_id=cancel_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_restrictions=cancel_restrictions,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            order_rate_limit_exceeded_mode=order_rate_limit_exceeded_mode,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderCancelReplaceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_cancel_replace_v3_with_http_info(
        self,
        cancel_replace_mode: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        cancel_new_client_order_id: Optional[StrictStr] = None,
        cancel_order_id: Optional[StrictInt] = None,
        cancel_orig_client_order_id: Optional[StrictStr] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        order_rate_limit_exceeded_mode: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotCreateOrderCancelReplaceV3Resp]:
        """Cancel an Existing Order and Send a New Order (TRADE)

        Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

        :param cancel_replace_mode: (required)
        :type cancel_replace_mode: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param cancel_new_client_order_id:
        :type cancel_new_client_order_id: str
        :param cancel_order_id:
        :type cancel_order_id: int
        :param cancel_orig_client_order_id:
        :type cancel_orig_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param order_rate_limit_exceeded_mode:
        :type order_rate_limit_exceeded_mode: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_cancel_replace_v3_serialize(
            cancel_replace_mode=cancel_replace_mode,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_order_id=cancel_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_restrictions=cancel_restrictions,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            order_rate_limit_exceeded_mode=order_rate_limit_exceeded_mode,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderCancelReplaceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_cancel_replace_v3_without_preload_content(
        self,
        cancel_replace_mode: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        cancel_new_client_order_id: Optional[StrictStr] = None,
        cancel_order_id: Optional[StrictInt] = None,
        cancel_orig_client_order_id: Optional[StrictStr] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        order_rate_limit_exceeded_mode: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel an Existing Order and Send a New Order (TRADE)

        Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

        :param cancel_replace_mode: (required)
        :type cancel_replace_mode: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param cancel_new_client_order_id:
        :type cancel_new_client_order_id: str
        :param cancel_order_id:
        :type cancel_order_id: int
        :param cancel_orig_client_order_id:
        :type cancel_orig_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param order_rate_limit_exceeded_mode:
        :type order_rate_limit_exceeded_mode: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_cancel_replace_v3_serialize(
            cancel_replace_mode=cancel_replace_mode,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_order_id=cancel_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_restrictions=cancel_restrictions,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            order_rate_limit_exceeded_mode=order_rate_limit_exceeded_mode,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderCancelReplaceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_cancel_replace_v3_serialize(
        self,
        cancel_replace_mode,
        side,
        symbol,
        timestamp,
        type,
        cancel_new_client_order_id,
        cancel_order_id,
        cancel_orig_client_order_id,
        cancel_restrictions,
        iceberg_qty,
        new_client_order_id,
        new_order_resp_type,
        order_rate_limit_exceeded_mode,
        price,
        quantity,
        quote_order_qty,
        recv_window,
        self_trade_prevention_mode,
        stop_price,
        strategy_id,
        strategy_type,
        time_in_force,
        trailing_delta,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if cancel_new_client_order_id is not None:
            _form_params.append(('cancelNewClientOrderId', cancel_new_client_order_id))
        if cancel_order_id is not None:
            _form_params.append(('cancelOrderId', cancel_order_id))
        if cancel_orig_client_order_id is not None:
            _form_params.append(('cancelOrigClientOrderId', cancel_orig_client_order_id))
        if cancel_replace_mode is not None:
            _form_params.append(('cancelReplaceMode', cancel_replace_mode))
        if cancel_restrictions is not None:
            _form_params.append(('cancelRestrictions', cancel_restrictions))
        if iceberg_qty is not None:
            _form_params.append(('icebergQty', iceberg_qty))
        if new_client_order_id is not None:
            _form_params.append(('newClientOrderId', new_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if order_rate_limit_exceeded_mode is not None:
            _form_params.append(('orderRateLimitExceededMode', order_rate_limit_exceeded_mode))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if quote_order_qty is not None:
            _form_params.append(('quoteOrderQty', quote_order_qty))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if strategy_id is not None:
            _form_params.append(('strategyId', strategy_id))
        if strategy_type is not None:
            _form_params.append(('strategyType', strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if time_in_force is not None:
            _form_params.append(('timeInForce', time_in_force))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if trailing_delta is not None:
            _form_params.append(('trailingDelta', trailing_delta))
        if type is not None:
            _form_params.append(('type', type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/cancelReplace',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_list_oco_v3(
        self,
        above_type: StrictStr,
        below_type: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        above_client_order_id: Optional[StrictStr] = None,
        above_iceberg_qty: Optional[StrictInt] = None,
        above_price: Optional[StrictStr] = None,
        above_stop_price: Optional[StrictStr] = None,
        above_strategy_id: Optional[StrictInt] = None,
        above_strategy_type: Optional[StrictInt] = None,
        above_time_in_force: Optional[StrictStr] = None,
        above_trailing_delta: Optional[StrictInt] = None,
        below_client_order_id: Optional[StrictStr] = None,
        below_iceberg_qty: Optional[StrictInt] = None,
        below_price: Optional[StrictStr] = None,
        below_stop_price: Optional[StrictStr] = None,
        below_strategy_id: Optional[StrictInt] = None,
        below_strategy_type: Optional[StrictInt] = None,
        below_time_in_force: Optional[StrictStr] = None,
        below_trailing_delta: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateOrderListOcoV3Resp:
        """New Order list - OCO (TRADE)

        Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

        :param above_type: (required)
        :type above_type: str
        :param below_type: (required)
        :type below_type: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param above_client_order_id:
        :type above_client_order_id: str
        :param above_iceberg_qty:
        :type above_iceberg_qty: int
        :param above_price:
        :type above_price: str
        :param above_stop_price:
        :type above_stop_price: str
        :param above_strategy_id:
        :type above_strategy_id: int
        :param above_strategy_type:
        :type above_strategy_type: int
        :param above_time_in_force:
        :type above_time_in_force: str
        :param above_trailing_delta:
        :type above_trailing_delta: int
        :param below_client_order_id:
        :type below_client_order_id: str
        :param below_iceberg_qty:
        :type below_iceberg_qty: int
        :param below_price:
        :type below_price: str
        :param below_stop_price:
        :type below_stop_price: str
        :param below_strategy_id:
        :type below_strategy_id: int
        :param below_strategy_type:
        :type below_strategy_type: int
        :param below_time_in_force:
        :type below_time_in_force: str
        :param below_trailing_delta:
        :type below_trailing_delta: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oco_v3_serialize(
            above_type=above_type,
            below_type=below_type,
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            above_client_order_id=above_client_order_id,
            above_iceberg_qty=above_iceberg_qty,
            above_price=above_price,
            above_stop_price=above_stop_price,
            above_strategy_id=above_strategy_id,
            above_strategy_type=above_strategy_type,
            above_time_in_force=above_time_in_force,
            above_trailing_delta=above_trailing_delta,
            below_client_order_id=below_client_order_id,
            below_iceberg_qty=below_iceberg_qty,
            below_price=below_price,
            below_stop_price=below_stop_price,
            below_strategy_id=below_strategy_id,
            below_strategy_type=below_strategy_type,
            below_time_in_force=below_time_in_force,
            below_trailing_delta=below_trailing_delta,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_list_oco_v3_with_http_info(
        self,
        above_type: StrictStr,
        below_type: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        above_client_order_id: Optional[StrictStr] = None,
        above_iceberg_qty: Optional[StrictInt] = None,
        above_price: Optional[StrictStr] = None,
        above_stop_price: Optional[StrictStr] = None,
        above_strategy_id: Optional[StrictInt] = None,
        above_strategy_type: Optional[StrictInt] = None,
        above_time_in_force: Optional[StrictStr] = None,
        above_trailing_delta: Optional[StrictInt] = None,
        below_client_order_id: Optional[StrictStr] = None,
        below_iceberg_qty: Optional[StrictInt] = None,
        below_price: Optional[StrictStr] = None,
        below_stop_price: Optional[StrictStr] = None,
        below_strategy_id: Optional[StrictInt] = None,
        below_strategy_type: Optional[StrictInt] = None,
        below_time_in_force: Optional[StrictStr] = None,
        below_trailing_delta: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateOrderListOcoV3Resp]:
        """New Order list - OCO (TRADE)

        Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

        :param above_type: (required)
        :type above_type: str
        :param below_type: (required)
        :type below_type: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param above_client_order_id:
        :type above_client_order_id: str
        :param above_iceberg_qty:
        :type above_iceberg_qty: int
        :param above_price:
        :type above_price: str
        :param above_stop_price:
        :type above_stop_price: str
        :param above_strategy_id:
        :type above_strategy_id: int
        :param above_strategy_type:
        :type above_strategy_type: int
        :param above_time_in_force:
        :type above_time_in_force: str
        :param above_trailing_delta:
        :type above_trailing_delta: int
        :param below_client_order_id:
        :type below_client_order_id: str
        :param below_iceberg_qty:
        :type below_iceberg_qty: int
        :param below_price:
        :type below_price: str
        :param below_stop_price:
        :type below_stop_price: str
        :param below_strategy_id:
        :type below_strategy_id: int
        :param below_strategy_type:
        :type below_strategy_type: int
        :param below_time_in_force:
        :type below_time_in_force: str
        :param below_trailing_delta:
        :type below_trailing_delta: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oco_v3_serialize(
            above_type=above_type,
            below_type=below_type,
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            above_client_order_id=above_client_order_id,
            above_iceberg_qty=above_iceberg_qty,
            above_price=above_price,
            above_stop_price=above_stop_price,
            above_strategy_id=above_strategy_id,
            above_strategy_type=above_strategy_type,
            above_time_in_force=above_time_in_force,
            above_trailing_delta=above_trailing_delta,
            below_client_order_id=below_client_order_id,
            below_iceberg_qty=below_iceberg_qty,
            below_price=below_price,
            below_stop_price=below_stop_price,
            below_strategy_id=below_strategy_id,
            below_strategy_type=below_strategy_type,
            below_time_in_force=below_time_in_force,
            below_trailing_delta=below_trailing_delta,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_list_oco_v3_without_preload_content(
        self,
        above_type: StrictStr,
        below_type: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        above_client_order_id: Optional[StrictStr] = None,
        above_iceberg_qty: Optional[StrictInt] = None,
        above_price: Optional[StrictStr] = None,
        above_stop_price: Optional[StrictStr] = None,
        above_strategy_id: Optional[StrictInt] = None,
        above_strategy_type: Optional[StrictInt] = None,
        above_time_in_force: Optional[StrictStr] = None,
        above_trailing_delta: Optional[StrictInt] = None,
        below_client_order_id: Optional[StrictStr] = None,
        below_iceberg_qty: Optional[StrictInt] = None,
        below_price: Optional[StrictStr] = None,
        below_stop_price: Optional[StrictStr] = None,
        below_strategy_id: Optional[StrictInt] = None,
        below_strategy_type: Optional[StrictInt] = None,
        below_time_in_force: Optional[StrictStr] = None,
        below_trailing_delta: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Order list - OCO (TRADE)

        Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

        :param above_type: (required)
        :type above_type: str
        :param below_type: (required)
        :type below_type: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param above_client_order_id:
        :type above_client_order_id: str
        :param above_iceberg_qty:
        :type above_iceberg_qty: int
        :param above_price:
        :type above_price: str
        :param above_stop_price:
        :type above_stop_price: str
        :param above_strategy_id:
        :type above_strategy_id: int
        :param above_strategy_type:
        :type above_strategy_type: int
        :param above_time_in_force:
        :type above_time_in_force: str
        :param above_trailing_delta:
        :type above_trailing_delta: int
        :param below_client_order_id:
        :type below_client_order_id: str
        :param below_iceberg_qty:
        :type below_iceberg_qty: int
        :param below_price:
        :type below_price: str
        :param below_stop_price:
        :type below_stop_price: str
        :param below_strategy_id:
        :type below_strategy_id: int
        :param below_strategy_type:
        :type below_strategy_type: int
        :param below_time_in_force:
        :type below_time_in_force: str
        :param below_trailing_delta:
        :type below_trailing_delta: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oco_v3_serialize(
            above_type=above_type,
            below_type=below_type,
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            above_client_order_id=above_client_order_id,
            above_iceberg_qty=above_iceberg_qty,
            above_price=above_price,
            above_stop_price=above_stop_price,
            above_strategy_id=above_strategy_id,
            above_strategy_type=above_strategy_type,
            above_time_in_force=above_time_in_force,
            above_trailing_delta=above_trailing_delta,
            below_client_order_id=below_client_order_id,
            below_iceberg_qty=below_iceberg_qty,
            below_price=below_price,
            below_stop_price=below_stop_price,
            below_strategy_id=below_strategy_id,
            below_strategy_type=below_strategy_type,
            below_time_in_force=below_time_in_force,
            below_trailing_delta=below_trailing_delta,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_list_oco_v3_serialize(
        self,
        above_type,
        below_type,
        quantity,
        side,
        symbol,
        timestamp,
        above_client_order_id,
        above_iceberg_qty,
        above_price,
        above_stop_price,
        above_strategy_id,
        above_strategy_type,
        above_time_in_force,
        above_trailing_delta,
        below_client_order_id,
        below_iceberg_qty,
        below_price,
        below_stop_price,
        below_strategy_id,
        below_strategy_type,
        below_time_in_force,
        below_trailing_delta,
        list_client_order_id,
        new_order_resp_type,
        recv_window,
        self_trade_prevention_mode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if above_client_order_id is not None:
            _form_params.append(('aboveClientOrderId', above_client_order_id))
        if above_iceberg_qty is not None:
            _form_params.append(('aboveIcebergQty', above_iceberg_qty))
        if above_price is not None:
            _form_params.append(('abovePrice', above_price))
        if above_stop_price is not None:
            _form_params.append(('aboveStopPrice', above_stop_price))
        if above_strategy_id is not None:
            _form_params.append(('aboveStrategyId', above_strategy_id))
        if above_strategy_type is not None:
            _form_params.append(('aboveStrategyType', above_strategy_type))
        if above_time_in_force is not None:
            _form_params.append(('aboveTimeInForce', above_time_in_force))
        if above_trailing_delta is not None:
            _form_params.append(('aboveTrailingDelta', above_trailing_delta))
        if above_type is not None:
            _form_params.append(('aboveType', above_type))
        if below_client_order_id is not None:
            _form_params.append(('belowClientOrderId', below_client_order_id))
        if below_iceberg_qty is not None:
            _form_params.append(('belowIcebergQty', below_iceberg_qty))
        if below_price is not None:
            _form_params.append(('belowPrice', below_price))
        if below_stop_price is not None:
            _form_params.append(('belowStopPrice', below_stop_price))
        if below_strategy_id is not None:
            _form_params.append(('belowStrategyId', below_strategy_id))
        if below_strategy_type is not None:
            _form_params.append(('belowStrategyType', below_strategy_type))
        if below_time_in_force is not None:
            _form_params.append(('belowTimeInForce', below_time_in_force))
        if below_trailing_delta is not None:
            _form_params.append(('belowTrailingDelta', below_trailing_delta))
        if below_type is not None:
            _form_params.append(('belowType', below_type))
        if list_client_order_id is not None:
            _form_params.append(('listClientOrderId', list_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/orderList/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_list_oto_v3(
        self,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        pending_type: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_client_order_id: Optional[StrictStr] = None,
        pending_iceberg_qty: Optional[StrictStr] = None,
        pending_price: Optional[StrictStr] = None,
        pending_stop_price: Optional[StrictStr] = None,
        pending_strategy_id: Optional[StrictInt] = None,
        pending_strategy_type: Optional[StrictInt] = None,
        pending_time_in_force: Optional[StrictStr] = None,
        pending_trailing_delta: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateOrderListOtoV3Resp:
        """New Order list - OTO (TRADE)

        Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param pending_type: (required)
        :type pending_type: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_client_order_id:
        :type pending_client_order_id: str
        :param pending_iceberg_qty:
        :type pending_iceberg_qty: str
        :param pending_price:
        :type pending_price: str
        :param pending_stop_price:
        :type pending_stop_price: str
        :param pending_strategy_id:
        :type pending_strategy_id: int
        :param pending_strategy_type:
        :type pending_strategy_type: int
        :param pending_time_in_force:
        :type pending_time_in_force: str
        :param pending_trailing_delta:
        :type pending_trailing_delta: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oto_v3_serialize(
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            pending_type=pending_type,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_client_order_id=pending_client_order_id,
            pending_iceberg_qty=pending_iceberg_qty,
            pending_price=pending_price,
            pending_stop_price=pending_stop_price,
            pending_strategy_id=pending_strategy_id,
            pending_strategy_type=pending_strategy_type,
            pending_time_in_force=pending_time_in_force,
            pending_trailing_delta=pending_trailing_delta,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_list_oto_v3_with_http_info(
        self,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        pending_type: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_client_order_id: Optional[StrictStr] = None,
        pending_iceberg_qty: Optional[StrictStr] = None,
        pending_price: Optional[StrictStr] = None,
        pending_stop_price: Optional[StrictStr] = None,
        pending_strategy_id: Optional[StrictInt] = None,
        pending_strategy_type: Optional[StrictInt] = None,
        pending_time_in_force: Optional[StrictStr] = None,
        pending_trailing_delta: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateOrderListOtoV3Resp]:
        """New Order list - OTO (TRADE)

        Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param pending_type: (required)
        :type pending_type: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_client_order_id:
        :type pending_client_order_id: str
        :param pending_iceberg_qty:
        :type pending_iceberg_qty: str
        :param pending_price:
        :type pending_price: str
        :param pending_stop_price:
        :type pending_stop_price: str
        :param pending_strategy_id:
        :type pending_strategy_id: int
        :param pending_strategy_type:
        :type pending_strategy_type: int
        :param pending_time_in_force:
        :type pending_time_in_force: str
        :param pending_trailing_delta:
        :type pending_trailing_delta: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oto_v3_serialize(
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            pending_type=pending_type,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_client_order_id=pending_client_order_id,
            pending_iceberg_qty=pending_iceberg_qty,
            pending_price=pending_price,
            pending_stop_price=pending_stop_price,
            pending_strategy_id=pending_strategy_id,
            pending_strategy_type=pending_strategy_type,
            pending_time_in_force=pending_time_in_force,
            pending_trailing_delta=pending_trailing_delta,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_list_oto_v3_without_preload_content(
        self,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        pending_type: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_client_order_id: Optional[StrictStr] = None,
        pending_iceberg_qty: Optional[StrictStr] = None,
        pending_price: Optional[StrictStr] = None,
        pending_stop_price: Optional[StrictStr] = None,
        pending_strategy_id: Optional[StrictInt] = None,
        pending_strategy_type: Optional[StrictInt] = None,
        pending_time_in_force: Optional[StrictStr] = None,
        pending_trailing_delta: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Order list - OTO (TRADE)

        Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param pending_type: (required)
        :type pending_type: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_client_order_id:
        :type pending_client_order_id: str
        :param pending_iceberg_qty:
        :type pending_iceberg_qty: str
        :param pending_price:
        :type pending_price: str
        :param pending_stop_price:
        :type pending_stop_price: str
        :param pending_strategy_id:
        :type pending_strategy_id: int
        :param pending_strategy_type:
        :type pending_strategy_type: int
        :param pending_time_in_force:
        :type pending_time_in_force: str
        :param pending_trailing_delta:
        :type pending_trailing_delta: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_oto_v3_serialize(
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            pending_type=pending_type,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_client_order_id=pending_client_order_id,
            pending_iceberg_qty=pending_iceberg_qty,
            pending_price=pending_price,
            pending_stop_price=pending_stop_price,
            pending_strategy_id=pending_strategy_id,
            pending_strategy_type=pending_strategy_type,
            pending_time_in_force=pending_time_in_force,
            pending_trailing_delta=pending_trailing_delta,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_list_oto_v3_serialize(
        self,
        pending_quantity,
        pending_side,
        pending_type,
        symbol,
        timestamp,
        working_price,
        working_quantity,
        working_side,
        working_type,
        list_client_order_id,
        new_order_resp_type,
        pending_client_order_id,
        pending_iceberg_qty,
        pending_price,
        pending_stop_price,
        pending_strategy_id,
        pending_strategy_type,
        pending_time_in_force,
        pending_trailing_delta,
        recv_window,
        self_trade_prevention_mode,
        working_client_order_id,
        working_iceberg_qty,
        working_strategy_id,
        working_strategy_type,
        working_time_in_force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if list_client_order_id is not None:
            _form_params.append(('listClientOrderId', list_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if pending_client_order_id is not None:
            _form_params.append(('pendingClientOrderId', pending_client_order_id))
        if pending_iceberg_qty is not None:
            _form_params.append(('pendingIcebergQty', pending_iceberg_qty))
        if pending_price is not None:
            _form_params.append(('pendingPrice', pending_price))
        if pending_quantity is not None:
            _form_params.append(('pendingQuantity', pending_quantity))
        if pending_side is not None:
            _form_params.append(('pendingSide', pending_side))
        if pending_stop_price is not None:
            _form_params.append(('pendingStopPrice', pending_stop_price))
        if pending_strategy_id is not None:
            _form_params.append(('pendingStrategyId', pending_strategy_id))
        if pending_strategy_type is not None:
            _form_params.append(('pendingStrategyType', pending_strategy_type))
        if pending_time_in_force is not None:
            _form_params.append(('pendingTimeInForce', pending_time_in_force))
        if pending_trailing_delta is not None:
            _form_params.append(('pendingTrailingDelta', pending_trailing_delta))
        if pending_type is not None:
            _form_params.append(('pendingType', pending_type))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if working_client_order_id is not None:
            _form_params.append(('workingClientOrderId', working_client_order_id))
        if working_iceberg_qty is not None:
            _form_params.append(('workingIcebergQty', working_iceberg_qty))
        if working_price is not None:
            _form_params.append(('workingPrice', working_price))
        if working_quantity is not None:
            _form_params.append(('workingQuantity', working_quantity))
        if working_side is not None:
            _form_params.append(('workingSide', working_side))
        if working_strategy_id is not None:
            _form_params.append(('workingStrategyId', working_strategy_id))
        if working_strategy_type is not None:
            _form_params.append(('workingStrategyType', working_strategy_type))
        if working_time_in_force is not None:
            _form_params.append(('workingTimeInForce', working_time_in_force))
        if working_type is not None:
            _form_params.append(('workingType', working_type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/orderList/oto',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_list_otoco_v3(
        self,
        pending_above_type: StrictStr,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_above_client_order_id: Optional[StrictStr] = None,
        pending_above_iceberg_qty: Optional[StrictStr] = None,
        pending_above_price: Optional[StrictStr] = None,
        pending_above_stop_price: Optional[StrictStr] = None,
        pending_above_strategy_id: Optional[StrictInt] = None,
        pending_above_strategy_type: Optional[StrictInt] = None,
        pending_above_time_in_force: Optional[StrictStr] = None,
        pending_above_trailing_delta: Optional[StrictStr] = None,
        pending_below_client_order_id: Optional[StrictStr] = None,
        pending_below_iceberg_qty: Optional[StrictStr] = None,
        pending_below_price: Optional[StrictStr] = None,
        pending_below_stop_price: Optional[StrictStr] = None,
        pending_below_strategy_id: Optional[StrictInt] = None,
        pending_below_strategy_type: Optional[StrictInt] = None,
        pending_below_time_in_force: Optional[StrictStr] = None,
        pending_below_trailing_delta: Optional[StrictStr] = None,
        pending_below_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateOrderListOtocoV3Resp:
        """New Order list - OTOCO (TRADE)

        Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

        :param pending_above_type: (required)
        :type pending_above_type: str
        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_above_client_order_id:
        :type pending_above_client_order_id: str
        :param pending_above_iceberg_qty:
        :type pending_above_iceberg_qty: str
        :param pending_above_price:
        :type pending_above_price: str
        :param pending_above_stop_price:
        :type pending_above_stop_price: str
        :param pending_above_strategy_id:
        :type pending_above_strategy_id: int
        :param pending_above_strategy_type:
        :type pending_above_strategy_type: int
        :param pending_above_time_in_force:
        :type pending_above_time_in_force: str
        :param pending_above_trailing_delta:
        :type pending_above_trailing_delta: str
        :param pending_below_client_order_id:
        :type pending_below_client_order_id: str
        :param pending_below_iceberg_qty:
        :type pending_below_iceberg_qty: str
        :param pending_below_price:
        :type pending_below_price: str
        :param pending_below_stop_price:
        :type pending_below_stop_price: str
        :param pending_below_strategy_id:
        :type pending_below_strategy_id: int
        :param pending_below_strategy_type:
        :type pending_below_strategy_type: int
        :param pending_below_time_in_force:
        :type pending_below_time_in_force: str
        :param pending_below_trailing_delta:
        :type pending_below_trailing_delta: str
        :param pending_below_type:
        :type pending_below_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_otoco_v3_serialize(
            pending_above_type=pending_above_type,
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_above_client_order_id=pending_above_client_order_id,
            pending_above_iceberg_qty=pending_above_iceberg_qty,
            pending_above_price=pending_above_price,
            pending_above_stop_price=pending_above_stop_price,
            pending_above_strategy_id=pending_above_strategy_id,
            pending_above_strategy_type=pending_above_strategy_type,
            pending_above_time_in_force=pending_above_time_in_force,
            pending_above_trailing_delta=pending_above_trailing_delta,
            pending_below_client_order_id=pending_below_client_order_id,
            pending_below_iceberg_qty=pending_below_iceberg_qty,
            pending_below_price=pending_below_price,
            pending_below_stop_price=pending_below_stop_price,
            pending_below_strategy_id=pending_below_strategy_id,
            pending_below_strategy_type=pending_below_strategy_type,
            pending_below_time_in_force=pending_below_time_in_force,
            pending_below_trailing_delta=pending_below_trailing_delta,
            pending_below_type=pending_below_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtocoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_list_otoco_v3_with_http_info(
        self,
        pending_above_type: StrictStr,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_above_client_order_id: Optional[StrictStr] = None,
        pending_above_iceberg_qty: Optional[StrictStr] = None,
        pending_above_price: Optional[StrictStr] = None,
        pending_above_stop_price: Optional[StrictStr] = None,
        pending_above_strategy_id: Optional[StrictInt] = None,
        pending_above_strategy_type: Optional[StrictInt] = None,
        pending_above_time_in_force: Optional[StrictStr] = None,
        pending_above_trailing_delta: Optional[StrictStr] = None,
        pending_below_client_order_id: Optional[StrictStr] = None,
        pending_below_iceberg_qty: Optional[StrictStr] = None,
        pending_below_price: Optional[StrictStr] = None,
        pending_below_stop_price: Optional[StrictStr] = None,
        pending_below_strategy_id: Optional[StrictInt] = None,
        pending_below_strategy_type: Optional[StrictInt] = None,
        pending_below_time_in_force: Optional[StrictStr] = None,
        pending_below_trailing_delta: Optional[StrictStr] = None,
        pending_below_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateOrderListOtocoV3Resp]:
        """New Order list - OTOCO (TRADE)

        Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

        :param pending_above_type: (required)
        :type pending_above_type: str
        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_above_client_order_id:
        :type pending_above_client_order_id: str
        :param pending_above_iceberg_qty:
        :type pending_above_iceberg_qty: str
        :param pending_above_price:
        :type pending_above_price: str
        :param pending_above_stop_price:
        :type pending_above_stop_price: str
        :param pending_above_strategy_id:
        :type pending_above_strategy_id: int
        :param pending_above_strategy_type:
        :type pending_above_strategy_type: int
        :param pending_above_time_in_force:
        :type pending_above_time_in_force: str
        :param pending_above_trailing_delta:
        :type pending_above_trailing_delta: str
        :param pending_below_client_order_id:
        :type pending_below_client_order_id: str
        :param pending_below_iceberg_qty:
        :type pending_below_iceberg_qty: str
        :param pending_below_price:
        :type pending_below_price: str
        :param pending_below_stop_price:
        :type pending_below_stop_price: str
        :param pending_below_strategy_id:
        :type pending_below_strategy_id: int
        :param pending_below_strategy_type:
        :type pending_below_strategy_type: int
        :param pending_below_time_in_force:
        :type pending_below_time_in_force: str
        :param pending_below_trailing_delta:
        :type pending_below_trailing_delta: str
        :param pending_below_type:
        :type pending_below_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_otoco_v3_serialize(
            pending_above_type=pending_above_type,
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_above_client_order_id=pending_above_client_order_id,
            pending_above_iceberg_qty=pending_above_iceberg_qty,
            pending_above_price=pending_above_price,
            pending_above_stop_price=pending_above_stop_price,
            pending_above_strategy_id=pending_above_strategy_id,
            pending_above_strategy_type=pending_above_strategy_type,
            pending_above_time_in_force=pending_above_time_in_force,
            pending_above_trailing_delta=pending_above_trailing_delta,
            pending_below_client_order_id=pending_below_client_order_id,
            pending_below_iceberg_qty=pending_below_iceberg_qty,
            pending_below_price=pending_below_price,
            pending_below_stop_price=pending_below_stop_price,
            pending_below_strategy_id=pending_below_strategy_id,
            pending_below_strategy_type=pending_below_strategy_type,
            pending_below_time_in_force=pending_below_time_in_force,
            pending_below_trailing_delta=pending_below_trailing_delta,
            pending_below_type=pending_below_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtocoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_list_otoco_v3_without_preload_content(
        self,
        pending_above_type: StrictStr,
        pending_quantity: StrictStr,
        pending_side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        working_price: StrictStr,
        working_quantity: StrictStr,
        working_side: StrictStr,
        working_type: StrictStr,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        pending_above_client_order_id: Optional[StrictStr] = None,
        pending_above_iceberg_qty: Optional[StrictStr] = None,
        pending_above_price: Optional[StrictStr] = None,
        pending_above_stop_price: Optional[StrictStr] = None,
        pending_above_strategy_id: Optional[StrictInt] = None,
        pending_above_strategy_type: Optional[StrictInt] = None,
        pending_above_time_in_force: Optional[StrictStr] = None,
        pending_above_trailing_delta: Optional[StrictStr] = None,
        pending_below_client_order_id: Optional[StrictStr] = None,
        pending_below_iceberg_qty: Optional[StrictStr] = None,
        pending_below_price: Optional[StrictStr] = None,
        pending_below_stop_price: Optional[StrictStr] = None,
        pending_below_strategy_id: Optional[StrictInt] = None,
        pending_below_strategy_type: Optional[StrictInt] = None,
        pending_below_time_in_force: Optional[StrictStr] = None,
        pending_below_trailing_delta: Optional[StrictStr] = None,
        pending_below_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        working_client_order_id: Optional[StrictStr] = None,
        working_iceberg_qty: Optional[StrictStr] = None,
        working_strategy_id: Optional[StrictInt] = None,
        working_strategy_type: Optional[StrictInt] = None,
        working_time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Order list - OTOCO (TRADE)

        Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

        :param pending_above_type: (required)
        :type pending_above_type: str
        :param pending_quantity: (required)
        :type pending_quantity: str
        :param pending_side: (required)
        :type pending_side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param working_price: (required)
        :type working_price: str
        :param working_quantity: (required)
        :type working_quantity: str
        :param working_side: (required)
        :type working_side: str
        :param working_type: (required)
        :type working_type: str
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param pending_above_client_order_id:
        :type pending_above_client_order_id: str
        :param pending_above_iceberg_qty:
        :type pending_above_iceberg_qty: str
        :param pending_above_price:
        :type pending_above_price: str
        :param pending_above_stop_price:
        :type pending_above_stop_price: str
        :param pending_above_strategy_id:
        :type pending_above_strategy_id: int
        :param pending_above_strategy_type:
        :type pending_above_strategy_type: int
        :param pending_above_time_in_force:
        :type pending_above_time_in_force: str
        :param pending_above_trailing_delta:
        :type pending_above_trailing_delta: str
        :param pending_below_client_order_id:
        :type pending_below_client_order_id: str
        :param pending_below_iceberg_qty:
        :type pending_below_iceberg_qty: str
        :param pending_below_price:
        :type pending_below_price: str
        :param pending_below_stop_price:
        :type pending_below_stop_price: str
        :param pending_below_strategy_id:
        :type pending_below_strategy_id: int
        :param pending_below_strategy_type:
        :type pending_below_strategy_type: int
        :param pending_below_time_in_force:
        :type pending_below_time_in_force: str
        :param pending_below_trailing_delta:
        :type pending_below_trailing_delta: str
        :param pending_below_type:
        :type pending_below_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param working_client_order_id:
        :type working_client_order_id: str
        :param working_iceberg_qty:
        :type working_iceberg_qty: str
        :param working_strategy_id:
        :type working_strategy_id: int
        :param working_strategy_type:
        :type working_strategy_type: int
        :param working_time_in_force:
        :type working_time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_list_otoco_v3_serialize(
            pending_above_type=pending_above_type,
            pending_quantity=pending_quantity,
            pending_side=pending_side,
            symbol=symbol,
            timestamp=timestamp,
            working_price=working_price,
            working_quantity=working_quantity,
            working_side=working_side,
            working_type=working_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            pending_above_client_order_id=pending_above_client_order_id,
            pending_above_iceberg_qty=pending_above_iceberg_qty,
            pending_above_price=pending_above_price,
            pending_above_stop_price=pending_above_stop_price,
            pending_above_strategy_id=pending_above_strategy_id,
            pending_above_strategy_type=pending_above_strategy_type,
            pending_above_time_in_force=pending_above_time_in_force,
            pending_above_trailing_delta=pending_above_trailing_delta,
            pending_below_client_order_id=pending_below_client_order_id,
            pending_below_iceberg_qty=pending_below_iceberg_qty,
            pending_below_price=pending_below_price,
            pending_below_stop_price=pending_below_stop_price,
            pending_below_strategy_id=pending_below_strategy_id,
            pending_below_strategy_type=pending_below_strategy_type,
            pending_below_time_in_force=pending_below_time_in_force,
            pending_below_trailing_delta=pending_below_trailing_delta,
            pending_below_type=pending_below_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            working_client_order_id=working_client_order_id,
            working_iceberg_qty=working_iceberg_qty,
            working_strategy_id=working_strategy_id,
            working_strategy_type=working_strategy_type,
            working_time_in_force=working_time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderListOtocoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_list_otoco_v3_serialize(
        self,
        pending_above_type,
        pending_quantity,
        pending_side,
        symbol,
        timestamp,
        working_price,
        working_quantity,
        working_side,
        working_type,
        list_client_order_id,
        new_order_resp_type,
        pending_above_client_order_id,
        pending_above_iceberg_qty,
        pending_above_price,
        pending_above_stop_price,
        pending_above_strategy_id,
        pending_above_strategy_type,
        pending_above_time_in_force,
        pending_above_trailing_delta,
        pending_below_client_order_id,
        pending_below_iceberg_qty,
        pending_below_price,
        pending_below_stop_price,
        pending_below_strategy_id,
        pending_below_strategy_type,
        pending_below_time_in_force,
        pending_below_trailing_delta,
        pending_below_type,
        recv_window,
        self_trade_prevention_mode,
        working_client_order_id,
        working_iceberg_qty,
        working_strategy_id,
        working_strategy_type,
        working_time_in_force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if list_client_order_id is not None:
            _form_params.append(('listClientOrderId', list_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if pending_above_client_order_id is not None:
            _form_params.append(('pendingAboveClientOrderId', pending_above_client_order_id))
        if pending_above_iceberg_qty is not None:
            _form_params.append(('pendingAboveIcebergQty', pending_above_iceberg_qty))
        if pending_above_price is not None:
            _form_params.append(('pendingAbovePrice', pending_above_price))
        if pending_above_stop_price is not None:
            _form_params.append(('pendingAboveStopPrice', pending_above_stop_price))
        if pending_above_strategy_id is not None:
            _form_params.append(('pendingAboveStrategyId', pending_above_strategy_id))
        if pending_above_strategy_type is not None:
            _form_params.append(('pendingAboveStrategyType', pending_above_strategy_type))
        if pending_above_time_in_force is not None:
            _form_params.append(('pendingAboveTimeInForce', pending_above_time_in_force))
        if pending_above_trailing_delta is not None:
            _form_params.append(('pendingAboveTrailingDelta', pending_above_trailing_delta))
        if pending_above_type is not None:
            _form_params.append(('pendingAboveType', pending_above_type))
        if pending_below_client_order_id is not None:
            _form_params.append(('pendingBelowClientOrderId', pending_below_client_order_id))
        if pending_below_iceberg_qty is not None:
            _form_params.append(('pendingBelowIcebergQty', pending_below_iceberg_qty))
        if pending_below_price is not None:
            _form_params.append(('pendingBelowPrice', pending_below_price))
        if pending_below_stop_price is not None:
            _form_params.append(('pendingBelowStopPrice', pending_below_stop_price))
        if pending_below_strategy_id is not None:
            _form_params.append(('pendingBelowStrategyId', pending_below_strategy_id))
        if pending_below_strategy_type is not None:
            _form_params.append(('pendingBelowStrategyType', pending_below_strategy_type))
        if pending_below_time_in_force is not None:
            _form_params.append(('pendingBelowTimeInForce', pending_below_time_in_force))
        if pending_below_trailing_delta is not None:
            _form_params.append(('pendingBelowTrailingDelta', pending_below_trailing_delta))
        if pending_below_type is not None:
            _form_params.append(('pendingBelowType', pending_below_type))
        if pending_quantity is not None:
            _form_params.append(('pendingQuantity', pending_quantity))
        if pending_side is not None:
            _form_params.append(('pendingSide', pending_side))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if working_client_order_id is not None:
            _form_params.append(('workingClientOrderId', working_client_order_id))
        if working_iceberg_qty is not None:
            _form_params.append(('workingIcebergQty', working_iceberg_qty))
        if working_price is not None:
            _form_params.append(('workingPrice', working_price))
        if working_quantity is not None:
            _form_params.append(('workingQuantity', working_quantity))
        if working_side is not None:
            _form_params.append(('workingSide', working_side))
        if working_strategy_id is not None:
            _form_params.append(('workingStrategyId', working_strategy_id))
        if working_strategy_type is not None:
            _form_params.append(('workingStrategyType', working_strategy_type))
        if working_time_in_force is not None:
            _form_params.append(('workingTimeInForce', working_time_in_force))
        if working_type is not None:
            _form_params.append(('workingType', working_type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/orderList/otoco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_oco_v3(
        self,
        price: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        stop_price: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        limit_client_order_id: Optional[StrictStr] = None,
        limit_iceberg_qty: Optional[StrictStr] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_client_order_id: Optional[StrictStr] = None,
        stop_iceberg_qty: Optional[StrictStr] = None,
        stop_limit_price: Optional[StrictStr] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateOrderOcoV3Resp:
        """New OCO - Deprecated (TRADE)

        Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

        :param price: (required)
        :type price: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param stop_price: (required)
        :type stop_price: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param limit_client_order_id:
        :type limit_client_order_id: str
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type:
        :type limit_strategy_type: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_client_order_id:
        :type stop_client_order_id: str
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: str
        :param stop_limit_price:
        :type stop_limit_price: str
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_oco_v3_serialize(
            price=price,
            quantity=quantity,
            side=side,
            stop_price=stop_price,
            symbol=symbol,
            timestamp=timestamp,
            limit_client_order_id=limit_client_order_id,
            limit_iceberg_qty=limit_iceberg_qty,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_client_order_id=stop_client_order_id,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_price=stop_limit_price,
            stop_limit_time_in_force=stop_limit_time_in_force,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_oco_v3_with_http_info(
        self,
        price: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        stop_price: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        limit_client_order_id: Optional[StrictStr] = None,
        limit_iceberg_qty: Optional[StrictStr] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_client_order_id: Optional[StrictStr] = None,
        stop_iceberg_qty: Optional[StrictStr] = None,
        stop_limit_price: Optional[StrictStr] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateOrderOcoV3Resp]:
        """New OCO - Deprecated (TRADE)

        Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

        :param price: (required)
        :type price: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param stop_price: (required)
        :type stop_price: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param limit_client_order_id:
        :type limit_client_order_id: str
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type:
        :type limit_strategy_type: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_client_order_id:
        :type stop_client_order_id: str
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: str
        :param stop_limit_price:
        :type stop_limit_price: str
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_oco_v3_serialize(
            price=price,
            quantity=quantity,
            side=side,
            stop_price=stop_price,
            symbol=symbol,
            timestamp=timestamp,
            limit_client_order_id=limit_client_order_id,
            limit_iceberg_qty=limit_iceberg_qty,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_client_order_id=stop_client_order_id,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_price=stop_limit_price,
            stop_limit_time_in_force=stop_limit_time_in_force,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_oco_v3_without_preload_content(
        self,
        price: StrictStr,
        quantity: StrictStr,
        side: StrictStr,
        stop_price: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        limit_client_order_id: Optional[StrictStr] = None,
        limit_iceberg_qty: Optional[StrictStr] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Optional[StrictInt] = None,
        list_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_client_order_id: Optional[StrictStr] = None,
        stop_iceberg_qty: Optional[StrictStr] = None,
        stop_limit_price: Optional[StrictStr] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New OCO - Deprecated (TRADE)

        Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

        :param price: (required)
        :type price: str
        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param stop_price: (required)
        :type stop_price: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param limit_client_order_id:
        :type limit_client_order_id: str
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type:
        :type limit_strategy_type: int
        :param list_client_order_id:
        :type list_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_client_order_id:
        :type stop_client_order_id: str
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: str
        :param stop_limit_price:
        :type stop_limit_price: str
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_oco_v3_serialize(
            price=price,
            quantity=quantity,
            side=side,
            stop_price=stop_price,
            symbol=symbol,
            timestamp=timestamp,
            limit_client_order_id=limit_client_order_id,
            limit_iceberg_qty=limit_iceberg_qty,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            list_client_order_id=list_client_order_id,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_client_order_id=stop_client_order_id,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_price=stop_limit_price,
            stop_limit_time_in_force=stop_limit_time_in_force,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateOrderOcoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_oco_v3_serialize(
        self,
        price,
        quantity,
        side,
        stop_price,
        symbol,
        timestamp,
        limit_client_order_id,
        limit_iceberg_qty,
        limit_strategy_id,
        limit_strategy_type,
        list_client_order_id,
        new_order_resp_type,
        recv_window,
        self_trade_prevention_mode,
        stop_client_order_id,
        stop_iceberg_qty,
        stop_limit_price,
        stop_limit_time_in_force,
        stop_strategy_id,
        stop_strategy_type,
        trailing_delta,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if limit_client_order_id is not None:
            _form_params.append(('limitClientOrderId', limit_client_order_id))
        if limit_iceberg_qty is not None:
            _form_params.append(('limitIcebergQty', limit_iceberg_qty))
        if limit_strategy_id is not None:
            _form_params.append(('limitStrategyId', limit_strategy_id))
        if limit_strategy_type is not None:
            _form_params.append(('limitStrategyType', limit_strategy_type))
        if list_client_order_id is not None:
            _form_params.append(('listClientOrderId', list_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if stop_client_order_id is not None:
            _form_params.append(('stopClientOrderId', stop_client_order_id))
        if stop_iceberg_qty is not None:
            _form_params.append(('stopIcebergQty', stop_iceberg_qty))
        if stop_limit_price is not None:
            _form_params.append(('stopLimitPrice', stop_limit_price))
        if stop_limit_time_in_force is not None:
            _form_params.append(('stopLimitTimeInForce', stop_limit_time_in_force))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if stop_strategy_id is not None:
            _form_params.append(('stopStrategyId', stop_strategy_id))
        if stop_strategy_type is not None:
            _form_params.append(('stopStrategyType', stop_strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if trailing_delta is not None:
            _form_params.append(('trailingDelta', trailing_delta))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_test_v3(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotCreateOrderTestV3Resp:
        """Test new order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_test_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_test_v3_with_http_info(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotCreateOrderTestV3Resp]:
        """Test new order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_test_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_test_v3_without_preload_content(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test new order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_test_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_test_v3_serialize(
        self,
        side,
        symbol,
        timestamp,
        type,
        compute_commission_rates,
        iceberg_qty,
        new_client_order_id,
        new_order_resp_type,
        price,
        quantity,
        quote_order_qty,
        recv_window,
        self_trade_prevention_mode,
        stop_price,
        strategy_id,
        strategy_type,
        time_in_force,
        trailing_delta,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if compute_commission_rates is not None:
            _form_params.append(('computeCommissionRates', compute_commission_rates))
        if iceberg_qty is not None:
            _form_params.append(('icebergQty', iceberg_qty))
        if new_client_order_id is not None:
            _form_params.append(('newClientOrderId', new_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if quote_order_qty is not None:
            _form_params.append(('quoteOrderQty', quote_order_qty))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if strategy_id is not None:
            _form_params.append(('strategyId', strategy_id))
        if strategy_type is not None:
            _form_params.append(('strategyType', strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if time_in_force is not None:
            _form_params.append(('timeInForce', time_in_force))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if trailing_delta is not None:
            _form_params.append(('trailingDelta', trailing_delta))
        if type is not None:
            _form_params.append(('type', type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/test',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_order_v3(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotCreateOrderV3Resp:
        """New order (TRADE)

        Send in a new order.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_v3_with_http_info(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotCreateOrderV3Resp]:
        """New order (TRADE)

        Send in a new order.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_v3_without_preload_content(
        self,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        quantity: Optional[StrictStr] = None,
        quote_order_qty: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        stop_price: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        trailing_delta: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New order (TRADE)

        Send in a new order.

        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param quantity:
        :type quantity: str
        :param quote_order_qty:
        :type quote_order_qty: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param stop_price:
        :type stop_price: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param trailing_delta:
        :type trailing_delta: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_v3_serialize(
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            stop_price=stop_price,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            trailing_delta=trailing_delta,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_v3_serialize(
        self,
        side,
        symbol,
        timestamp,
        type,
        iceberg_qty,
        new_client_order_id,
        new_order_resp_type,
        price,
        quantity,
        quote_order_qty,
        recv_window,
        self_trade_prevention_mode,
        stop_price,
        strategy_id,
        strategy_type,
        time_in_force,
        trailing_delta,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if iceberg_qty is not None:
            _form_params.append(('icebergQty', iceberg_qty))
        if new_client_order_id is not None:
            _form_params.append(('newClientOrderId', new_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if quote_order_qty is not None:
            _form_params.append(('quoteOrderQty', quote_order_qty))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if strategy_id is not None:
            _form_params.append(('strategyId', strategy_id))
        if strategy_type is not None:
            _form_params.append(('strategyType', strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if time_in_force is not None:
            _form_params.append(('timeInForce', time_in_force))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if trailing_delta is not None:
            _form_params.append(('trailingDelta', trailing_delta))
        if type is not None:
            _form_params.append(('type', type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_sor_order_test_v3(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotCreateSorOrderTestV3Resp:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_test_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateSorOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_sor_order_test_v3_with_http_info(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotCreateSorOrderTestV3Resp]:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_test_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateSorOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_sor_order_test_v3_without_preload_content(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        compute_commission_rates: Optional[StrictBool] = None,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param compute_commission_rates:
        :type compute_commission_rates: bool
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_test_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            compute_commission_rates=compute_commission_rates,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotCreateSorOrderTestV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_sor_order_test_v3_serialize(
        self,
        quantity,
        side,
        symbol,
        timestamp,
        type,
        compute_commission_rates,
        iceberg_qty,
        new_client_order_id,
        new_order_resp_type,
        price,
        recv_window,
        self_trade_prevention_mode,
        strategy_id,
        strategy_type,
        time_in_force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if compute_commission_rates is not None:
            _form_params.append(('computeCommissionRates', compute_commission_rates))
        if iceberg_qty is not None:
            _form_params.append(('icebergQty', iceberg_qty))
        if new_client_order_id is not None:
            _form_params.append(('newClientOrderId', new_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if strategy_id is not None:
            _form_params.append(('strategyId', strategy_id))
        if strategy_type is not None:
            _form_params.append(('strategyType', strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if time_in_force is not None:
            _form_params.append(('timeInForce', time_in_force))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if type is not None:
            _form_params.append(('type', type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/sor/order/test',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_sor_order_v3(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateSorOrderV3Resp:
        """New order using SOR (TRADE)

        Places an order using smart order routing (SOR).

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateSorOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_sor_order_v3_with_http_info(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateSorOrderV3Resp]:
        """New order using SOR (TRADE)

        Places an order using smart order routing (SOR).

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateSorOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_sor_order_v3_without_preload_content(
        self,
        quantity: StrictStr,
        side: StrictStr,
        symbol: StrictStr,
        timestamp: StrictInt,
        type: StrictStr,
        iceberg_qty: Optional[StrictStr] = None,
        new_client_order_id: Optional[StrictStr] = None,
        new_order_resp_type: Optional[StrictStr] = None,
        price: Optional[StrictStr] = None,
        recv_window: Optional[StrictInt] = None,
        self_trade_prevention_mode: Optional[StrictStr] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Optional[StrictInt] = None,
        time_in_force: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New order using SOR (TRADE)

        Places an order using smart order routing (SOR).

        :param quantity: (required)
        :type quantity: str
        :param side: (required)
        :type side: str
        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param type: (required)
        :type type: str
        :param iceberg_qty:
        :type iceberg_qty: str
        :param new_client_order_id:
        :type new_client_order_id: str
        :param new_order_resp_type:
        :type new_order_resp_type: str
        :param price:
        :type price: str
        :param recv_window:
        :type recv_window: int
        :param self_trade_prevention_mode:
        :type self_trade_prevention_mode: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type:
        :type strategy_type: int
        :param time_in_force:
        :type time_in_force: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_sor_order_v3_serialize(
            quantity=quantity,
            side=side,
            symbol=symbol,
            timestamp=timestamp,
            type=type,
            iceberg_qty=iceberg_qty,
            new_client_order_id=new_client_order_id,
            new_order_resp_type=new_order_resp_type,
            price=price,
            recv_window=recv_window,
            self_trade_prevention_mode=self_trade_prevention_mode,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            time_in_force=time_in_force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateSorOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_sor_order_v3_serialize(
        self,
        quantity,
        side,
        symbol,
        timestamp,
        type,
        iceberg_qty,
        new_client_order_id,
        new_order_resp_type,
        price,
        recv_window,
        self_trade_prevention_mode,
        strategy_id,
        strategy_type,
        time_in_force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if iceberg_qty is not None:
            _form_params.append(('icebergQty', iceberg_qty))
        if new_client_order_id is not None:
            _form_params.append(('newClientOrderId', new_client_order_id))
        if new_order_resp_type is not None:
            _form_params.append(('newOrderRespType', new_order_resp_type))
        if price is not None:
            _form_params.append(('price', price))
        if quantity is not None:
            _form_params.append(('quantity', quantity))
        if recv_window is not None:
            _form_params.append(('recvWindow', recv_window))
        if self_trade_prevention_mode is not None:
            _form_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
        if side is not None:
            _form_params.append(('side', side))
        if strategy_id is not None:
            _form_params.append(('strategyId', strategy_id))
        if strategy_type is not None:
            _form_params.append(('strategyType', strategy_type))
        if symbol is not None:
            _form_params.append(('symbol', symbol))
        if time_in_force is not None:
            _form_params.append(('timeInForce', time_in_force))
        if timestamp is not None:
            _form_params.append(('timestamp', timestamp))
        if type is not None:
            _form_params.append(('type', type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/sor/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_user_data_stream_v3(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateUserDataStreamV3Resp:
        """Start user data stream (USER_STREAM)

        Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_data_stream_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserDataStreamV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_user_data_stream_v3_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateUserDataStreamV3Resp]:
        """Start user data stream (USER_STREAM)

        Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_data_stream_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserDataStreamV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_user_data_stream_v3_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Start user data stream (USER_STREAM)

        Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_data_stream_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserDataStreamV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_user_data_stream_v3_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/userDataStream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_open_orders_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[SpotDeleteOpenOrdersV3RespInner]]:
        """Cancel All Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes orders that are part of an order list.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_open_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[SpotDeleteOpenOrdersV3RespInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_open_orders_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[SpotDeleteOpenOrdersV3RespInner]]]:
        """Cancel All Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes orders that are part of an order list.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_open_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[SpotDeleteOpenOrdersV3RespInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_open_orders_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel All Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes orders that are part of an order list.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_open_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[SpotDeleteOpenOrdersV3RespInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_open_orders_v3_serialize(
        self,
        symbol,
        timestamp,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/openOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_order_list_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteOrderListV3Resp:
        """Cancel Order list (TRADE)

        Cancel an entire Order list

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param list_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_list_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_order_list_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteOrderListV3Resp]:
        """Cancel Order list (TRADE)

        Cancel an entire Order list

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param list_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_list_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_order_list_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel Order list (TRADE)

        Cancel an entire Order list

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param list_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_list_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_order_list_v3_serialize(
        self,
        symbol,
        timestamp,
        order_list_id,
        list_client_order_id,
        new_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_list_id is not None:
            
            _query_params.append(('orderListId', order_list_id))
            
        if list_client_order_id is not None:
            
            _query_params.append(('listClientOrderId', list_client_order_id))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/orderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_order_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default.")] = None,
        cancel_restrictions: Annotated[Optional[StrictStr], Field(description="Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteOrderV3Resp:
        """Cancel order (TRADE)

        Cancel an active order.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default.
        :type new_client_order_id: str
        :param cancel_restrictions: Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_order_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default.")] = None,
        cancel_restrictions: Annotated[Optional[StrictStr], Field(description="Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteOrderV3Resp]:
        """Cancel order (TRADE)

        Cancel an active order.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default.
        :type new_client_order_id: str
        :param cancel_restrictions: Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_order_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default.")] = None,
        cancel_restrictions: Annotated[Optional[StrictStr], Field(description="Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel order (TRADE)

        Cancel an active order.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default.
        :type new_client_order_id: str
        :param cancel_restrictions: Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_order_v3_serialize(
        self,
        symbol,
        timestamp,
        order_id,
        orig_client_order_id,
        new_client_order_id,
        cancel_restrictions,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if cancel_restrictions is not None:
            
            _query_params.append(('cancelRestrictions', cancel_restrictions))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_user_data_stream_v3(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Close user data stream (USER_STREAM)

        Close out a user data stream.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_user_data_stream_v3_with_http_info(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Close user data stream (USER_STREAM)

        Close out a user data stream.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_user_data_stream_v3_without_preload_content(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Close user data stream (USER_STREAM)

        Close out a user data stream.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_user_data_stream_v3_serialize(
        self,
        listen_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if listen_key is not None:
            
            _query_params.append(('listenKey', listen_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/userDataStream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_account_commission_v3(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAccountCommissionV3Resp:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_commission_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountCommissionV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_account_commission_v3_with_http_info(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAccountCommissionV3Resp]:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_commission_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountCommissionV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_account_commission_v3_without_preload_content(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_commission_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountCommissionV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_account_commission_v3_serialize(
        self,
        symbol,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/account/commission',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_account_v3(
        self,
        timestamp: StrictInt,
        omit_zero_balances: Annotated[Optional[StrictBool], Field(description="When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAccountV3Resp:
        """Account information (USER_DATA)

        Get current account information.

        :param timestamp: (required)
        :type timestamp: int
        :param omit_zero_balances: When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`
        :type omit_zero_balances: bool
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_v3_serialize(
            timestamp=timestamp,
            omit_zero_balances=omit_zero_balances,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_account_v3_with_http_info(
        self,
        timestamp: StrictInt,
        omit_zero_balances: Annotated[Optional[StrictBool], Field(description="When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAccountV3Resp]:
        """Account information (USER_DATA)

        Get current account information.

        :param timestamp: (required)
        :type timestamp: int
        :param omit_zero_balances: When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`
        :type omit_zero_balances: bool
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_v3_serialize(
            timestamp=timestamp,
            omit_zero_balances=omit_zero_balances,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_account_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        omit_zero_balances: Annotated[Optional[StrictBool], Field(description="When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Account information (USER_DATA)

        Get current account information.

        :param timestamp: (required)
        :type timestamp: int
        :param omit_zero_balances: When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`
        :type omit_zero_balances: bool
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_v3_serialize(
            timestamp=timestamp,
            omit_zero_balances=omit_zero_balances,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAccountV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_account_v3_serialize(
        self,
        timestamp,
        omit_zero_balances,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if omit_zero_balances is not None:
            
            _query_params.append(('omitZeroBalances', omit_zero_balances))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/account',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_agg_trades_v3(
        self,
        symbol: StrictStr,
        from_id: Annotated[Optional[StrictInt], Field(description="ID to get aggregate trades from INCLUSIVE.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades from INCLUSIVE.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades until INCLUSIVE.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpotGetAggTradesV3RespItem]:
        """Compressed/Aggregate trades list

        Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.

        :param symbol: (required)
        :type symbol: str
        :param from_id: ID to get aggregate trades from INCLUSIVE.
        :type from_id: int
        :param start_time: Timestamp in ms to get aggregate trades from INCLUSIVE.
        :type start_time: int
        :param end_time: Timestamp in ms to get aggregate trades until INCLUSIVE.
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_agg_trades_v3_serialize(
            symbol=symbol,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpotGetAggTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_agg_trades_v3_with_http_info(
        self,
        symbol: StrictStr,
        from_id: Annotated[Optional[StrictInt], Field(description="ID to get aggregate trades from INCLUSIVE.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades from INCLUSIVE.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades until INCLUSIVE.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpotGetAggTradesV3RespItem]]:
        """Compressed/Aggregate trades list

        Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.

        :param symbol: (required)
        :type symbol: str
        :param from_id: ID to get aggregate trades from INCLUSIVE.
        :type from_id: int
        :param start_time: Timestamp in ms to get aggregate trades from INCLUSIVE.
        :type start_time: int
        :param end_time: Timestamp in ms to get aggregate trades until INCLUSIVE.
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_agg_trades_v3_serialize(
            symbol=symbol,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpotGetAggTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_agg_trades_v3_without_preload_content(
        self,
        symbol: StrictStr,
        from_id: Annotated[Optional[StrictInt], Field(description="ID to get aggregate trades from INCLUSIVE.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades from INCLUSIVE.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Timestamp in ms to get aggregate trades until INCLUSIVE.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Compressed/Aggregate trades list

        Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.

        :param symbol: (required)
        :type symbol: str
        :param from_id: ID to get aggregate trades from INCLUSIVE.
        :type from_id: int
        :param start_time: Timestamp in ms to get aggregate trades from INCLUSIVE.
        :type start_time: int
        :param end_time: Timestamp in ms to get aggregate trades until INCLUSIVE.
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_agg_trades_v3_serialize(
            symbol=symbol,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpotGetAggTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_agg_trades_v3_serialize(
        self,
        symbol,
        from_id,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/aggTrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_order_list_v3(
        self,
        timestamp: StrictInt,
        from_id: Annotated[Optional[StrictInt], Field(description="If supplied, neither `startTime` or `endTime` can be provided")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default Value: 500; Max Value: 1000")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetAllOrderListV3RespItem]:
        """Query all Order lists (USER_DATA)

        Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can't be longer than 24 hours.

        :param timestamp: (required)
        :type timestamp: int
        :param from_id: If supplied, neither `startTime` or `endTime` can be provided
        :type from_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default Value: 500; Max Value: 1000
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_order_list_v3_serialize(
            timestamp=timestamp,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_order_list_v3_with_http_info(
        self,
        timestamp: StrictInt,
        from_id: Annotated[Optional[StrictInt], Field(description="If supplied, neither `startTime` or `endTime` can be provided")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default Value: 500; Max Value: 1000")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetAllOrderListV3RespItem]]:
        """Query all Order lists (USER_DATA)

        Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can't be longer than 24 hours.

        :param timestamp: (required)
        :type timestamp: int
        :param from_id: If supplied, neither `startTime` or `endTime` can be provided
        :type from_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default Value: 500; Max Value: 1000
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_order_list_v3_serialize(
            timestamp=timestamp,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_order_list_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        from_id: Annotated[Optional[StrictInt], Field(description="If supplied, neither `startTime` or `endTime` can be provided")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default Value: 500; Max Value: 1000")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query all Order lists (USER_DATA)

        Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can't be longer than 24 hours.

        :param timestamp: (required)
        :type timestamp: int
        :param from_id: If supplied, neither `startTime` or `endTime` can be provided
        :type from_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default Value: 500; Max Value: 1000
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_order_list_v3_serialize(
            timestamp=timestamp,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_order_list_v3_serialize(
        self,
        timestamp,
        from_id,
        start_time,
        end_time,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/allOrderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_orders_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetAllOrdersV3RespItem]:
        """All orders (USER_DATA)

        Get all account orders; active, canceled, or filled.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_orders_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetAllOrdersV3RespItem]]:
        """All orders (USER_DATA)

        Get all account orders; active, canceled, or filled.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_orders_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All orders (USER_DATA)

        Get all account orders; active, canceled, or filled.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetAllOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_orders_v3_serialize(
        self,
        symbol,
        timestamp,
        order_id,
        start_time,
        end_time,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/allOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_avg_price_v3(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAvgPriceV3Resp:
        """Current average price

        Current average price for a symbol.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_avg_price_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAvgPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_avg_price_v3_with_http_info(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAvgPriceV3Resp]:
        """Current average price

        Current average price for a symbol.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_avg_price_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAvgPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_avg_price_v3_without_preload_content(
        self,
        symbol: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current average price

        Current average price for a symbol.

        :param symbol: (required)
        :type symbol: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_avg_price_v3_serialize(
            symbol=symbol,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAvgPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_avg_price_v3_serialize(
        self,
        symbol,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/avgPrice',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_depth_v3(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=5000, strict=True)]], Field(description="Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDepthV3Resp:
        """Order book


        :param symbol: (required)
        :type symbol: str
        :param limit: Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_depth_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDepthV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_depth_v3_with_http_info(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=5000, strict=True)]], Field(description="Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDepthV3Resp]:
        """Order book


        :param symbol: (required)
        :type symbol: str
        :param limit: Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_depth_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDepthV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_depth_v3_without_preload_content(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=5000, strict=True)]], Field(description="Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Order book


        :param symbol: (required)
        :type symbol: str
        :param limit: Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_depth_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDepthV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_depth_v3_serialize(
        self,
        symbol,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/depth',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_exchange_info_v3(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;")] = None,
        symbols: Annotated[Optional[List[StrictStr]], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;")] = None,
        permissions: Annotated[Optional[StrictStr], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;")] = None,
        show_permission_sets: Annotated[Optional[StrictBool], Field(description="Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`")] = None,
        symbol_status: Annotated[Optional[StrictStr], Field(description="Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetExchangeInfoV3Resp:
        """Exchange information

        Current exchange trading rules and symbol information

        :param symbol: Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;
        :type symbol: str
        :param symbols: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;
        :type symbols: List[str]
        :param permissions: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;
        :type permissions: str
        :param show_permission_sets: Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
        :type show_permission_sets: bool
        :param symbol_status: Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.
        :type symbol_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_exchange_info_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            permissions=permissions,
            show_permission_sets=show_permission_sets,
            symbol_status=symbol_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetExchangeInfoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_exchange_info_v3_with_http_info(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;")] = None,
        symbols: Annotated[Optional[List[StrictStr]], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;")] = None,
        permissions: Annotated[Optional[StrictStr], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;")] = None,
        show_permission_sets: Annotated[Optional[StrictBool], Field(description="Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`")] = None,
        symbol_status: Annotated[Optional[StrictStr], Field(description="Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetExchangeInfoV3Resp]:
        """Exchange information

        Current exchange trading rules and symbol information

        :param symbol: Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;
        :type symbol: str
        :param symbols: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;
        :type symbols: List[str]
        :param permissions: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;
        :type permissions: str
        :param show_permission_sets: Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
        :type show_permission_sets: bool
        :param symbol_status: Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.
        :type symbol_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_exchange_info_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            permissions=permissions,
            show_permission_sets=show_permission_sets,
            symbol_status=symbol_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetExchangeInfoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_exchange_info_v3_without_preload_content(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;")] = None,
        symbols: Annotated[Optional[List[StrictStr]], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;")] = None,
        permissions: Annotated[Optional[StrictStr], Field(description="Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;")] = None,
        show_permission_sets: Annotated[Optional[StrictBool], Field(description="Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`")] = None,
        symbol_status: Annotated[Optional[StrictStr], Field(description="Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Exchange information

        Current exchange trading rules and symbol information

        :param symbol: Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;
        :type symbol: str
        :param symbols: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;
        :type symbols: List[str]
        :param permissions: Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;
        :type permissions: str
        :param show_permission_sets: Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
        :type show_permission_sets: bool
        :param symbol_status: Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.
        :type symbol_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_exchange_info_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            permissions=permissions,
            show_permission_sets=show_permission_sets,
            symbol_status=symbol_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetExchangeInfoV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_exchange_info_v3_serialize(
        self,
        symbol,
        symbols,
        permissions,
        show_permission_sets,
        symbol_status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'symbols': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if show_permission_sets is not None:
            
            _query_params.append(('showPermissionSets', show_permission_sets))
            
        if symbol_status is not None:
            
            _query_params.append(('symbolStatus', symbol_status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/exchangeInfo',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_historical_trades_v3(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetHistoricalTradesV3RespItem]:
        """Old trade lookup

        Get older trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            from_id=from_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetHistoricalTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_historical_trades_v3_with_http_info(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetHistoricalTradesV3RespItem]]:
        """Old trade lookup

        Get older trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            from_id=from_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetHistoricalTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_historical_trades_v3_without_preload_content(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Old trade lookup

        Get older trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            from_id=from_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetHistoricalTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_historical_trades_v3_serialize(
        self,
        symbol,
        limit,
        from_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/historicalTrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_klines_v3(
        self,
        symbol: StrictStr,
        interval: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[GetKlinesV3200ResponseInnerInner]]:
        """Kline/Candlestick data

        Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

        :param symbol: (required)
        :type symbol: str
        :param interval: (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_klines_v3_with_http_info(
        self,
        symbol: StrictStr,
        interval: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[GetKlinesV3200ResponseInnerInner]]]:
        """Kline/Candlestick data

        Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

        :param symbol: (required)
        :type symbol: str
        :param interval: (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_klines_v3_without_preload_content(
        self,
        symbol: StrictStr,
        interval: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Kline/Candlestick data

        Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

        :param symbol: (required)
        :type symbol: str
        :param interval: (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_klines_v3_serialize(
        self,
        symbol,
        interval,
        start_time,
        end_time,
        time_zone,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if time_zone is not None:
            
            _query_params.append(('timeZone', time_zone))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/klines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_my_allocations_v3(
        self,
        symbol: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500;Max 1000")] = None,
        order_id: Optional[StrictInt] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        timestamp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetMyAllocationsV3RespItem]:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.

        :param symbol: (required)
        :type symbol: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500;Max 1000
        :type limit: int
        :param order_id:
        :type order_id: int
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param timestamp:
        :type timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_allocations_v3_serialize(
            symbol=symbol,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            timestamp=timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyAllocationsV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_my_allocations_v3_with_http_info(
        self,
        symbol: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500;Max 1000")] = None,
        order_id: Optional[StrictInt] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        timestamp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetMyAllocationsV3RespItem]]:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.

        :param symbol: (required)
        :type symbol: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500;Max 1000
        :type limit: int
        :param order_id:
        :type order_id: int
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param timestamp:
        :type timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_allocations_v3_serialize(
            symbol=symbol,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            timestamp=timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyAllocationsV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_my_allocations_v3_without_preload_content(
        self,
        symbol: StrictStr,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500;Max 1000")] = None,
        order_id: Optional[StrictInt] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`.")] = None,
        timestamp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.

        :param symbol: (required)
        :type symbol: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500;Max 1000
        :type limit: int
        :param order_id:
        :type order_id: int
        :param recv_window: The value cannot be greater than `60000`.
        :type recv_window: int
        :param timestamp:
        :type timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_allocations_v3_serialize(
            symbol=symbol,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            timestamp=timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyAllocationsV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_my_allocations_v3_serialize(
        self,
        symbol,
        start_time,
        end_time,
        from_allocation_id,
        limit,
        order_id,
        recv_window,
        timestamp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if from_allocation_id is not None:
            
            _query_params.append(('fromAllocationId', from_allocation_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myAllocations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_my_prevented_matches_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Optional[StrictInt] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default: `500`; Max: `1000`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetMyPreventedMatchesV3RespItem]:
        """Query Prevented Matches (USER_DATA)

        Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id:
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default: `500`; Max: `1000`
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_prevented_matches_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyPreventedMatchesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_my_prevented_matches_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Optional[StrictInt] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default: `500`; Max: `1000`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetMyPreventedMatchesV3RespItem]]:
        """Query Prevented Matches (USER_DATA)

        Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id:
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default: `500`; Max: `1000`
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_prevented_matches_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyPreventedMatchesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_my_prevented_matches_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Optional[StrictInt] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default: `500`; Max: `1000`")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Prevented Matches (USER_DATA)

        Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id:
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default: `500`; Max: `1000`
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_prevented_matches_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyPreventedMatchesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_my_prevented_matches_v3_serialize(
        self,
        symbol,
        timestamp,
        prevented_match_id,
        order_id,
        from_prevented_match_id,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if prevented_match_id is not None:
            
            _query_params.append(('preventedMatchId', prevented_match_id))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if from_prevented_match_id is not None:
            
            _query_params.append(('fromPreventedMatchId', from_prevented_match_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myPreventedMatches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_my_trades_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with `symbol`.")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetMyTradesV3RespItem]:
        """Account trade list (USER_DATA)

        Get trades for a specific account and symbol.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id: This can only be used in combination with `symbol`.
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_trades_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_my_trades_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with `symbol`.")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetMyTradesV3RespItem]]:
        """Account trade list (USER_DATA)

        Get trades for a specific account and symbol.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id: This can only be used in combination with `symbol`.
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_trades_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_my_trades_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with `symbol`.")] = None,
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="TradeId to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Account trade list (USER_DATA)

        Get trades for a specific account and symbol.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id: This can only be used in combination with `symbol`.
        :type order_id: int
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param from_id: TradeId to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_trades_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMyTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_my_trades_v3_serialize(
        self,
        symbol,
        timestamp,
        order_id,
        start_time,
        end_time,
        from_id,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myTrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_open_order_list_v3(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetOpenOrderListV3RespItem]:
        """Query Open Order lists (USER_DATA)


        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_order_list_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_open_order_list_v3_with_http_info(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetOpenOrderListV3RespItem]]:
        """Query Open Order lists (USER_DATA)


        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_order_list_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_open_order_list_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Open Order lists (USER_DATA)


        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_order_list_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrderListV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_open_order_list_v3_serialize(
        self,
        timestamp,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/openOrderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_open_orders_v3(
        self,
        timestamp: StrictInt,
        symbol: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetOpenOrdersV3RespItem]:
        """Current open orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted

        :param timestamp: (required)
        :type timestamp: int
        :param symbol:
        :type symbol: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_orders_v3_serialize(
            timestamp=timestamp,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_open_orders_v3_with_http_info(
        self,
        timestamp: StrictInt,
        symbol: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetOpenOrdersV3RespItem]]:
        """Current open orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted

        :param timestamp: (required)
        :type timestamp: int
        :param symbol:
        :type symbol: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_orders_v3_serialize(
            timestamp=timestamp,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_open_orders_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        symbol: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current open orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted

        :param timestamp: (required)
        :type timestamp: int
        :param symbol:
        :type symbol: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_open_orders_v3_serialize(
            timestamp=timestamp,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOpenOrdersV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_open_orders_v3_serialize(
        self,
        timestamp,
        symbol,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/openOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_list_v3(
        self,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrderListV3Resp:
        """Query Order list (USER_DATA)

        Retrieves a specific order list based on provided optional parameters.

        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param orig_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_list_v3_serialize(
            timestamp=timestamp,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_list_v3_with_http_info(
        self,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrderListV3Resp]:
        """Query Order list (USER_DATA)

        Retrieves a specific order list based on provided optional parameters.

        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param orig_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_list_v3_serialize(
            timestamp=timestamp,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_list_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        order_list_id: Annotated[Optional[StrictInt], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either `orderListId` or `listClientOrderId` must be provided")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Order list (USER_DATA)

        Retrieves a specific order list based on provided optional parameters.

        :param timestamp: (required)
        :type timestamp: int
        :param order_list_id: Either `orderListId` or `listClientOrderId` must be provided
        :type order_list_id: int
        :param orig_client_order_id: Either `orderListId` or `listClientOrderId` must be provided
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_list_v3_serialize(
            timestamp=timestamp,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderListV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_list_v3_serialize(
        self,
        timestamp,
        order_list_id,
        orig_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_list_id is not None:
            
            _query_params.append(('orderListId', order_list_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/orderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_v3(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrderV3Resp:
        """Query order (USER_DATA)

        Check an order's status.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_v3_with_http_info(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrderV3Resp]:
        """Query order (USER_DATA)

        Check an order's status.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_v3_without_preload_content(
        self,
        symbol: StrictStr,
        timestamp: StrictInt,
        order_id: Optional[StrictInt] = None,
        orig_client_order_id: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query order (USER_DATA)

        Check an order's status.

        :param symbol: (required)
        :type symbol: str
        :param timestamp: (required)
        :type timestamp: int
        :param order_id:
        :type order_id: int
        :param orig_client_order_id:
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_v3_serialize(
            symbol=symbol,
            timestamp=timestamp,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_v3_serialize(
        self,
        symbol,
        timestamp,
        order_id,
        orig_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ping_v3(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Test connectivity

        Test connectivity to the Rest API.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ping_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ping_v3_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Test connectivity

        Test connectivity to the Rest API.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ping_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ping_v3_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test connectivity

        Test connectivity to the Rest API.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ping_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ping_v3_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_rate_limit_order_v3(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetRateLimitOrderV3RespItem]:
        """Query Unfilled Order Count (USER_DATA)

        Displays the user's unfilled order count for all intervals.

        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rate_limit_order_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetRateLimitOrderV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_rate_limit_order_v3_with_http_info(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetRateLimitOrderV3RespItem]]:
        """Query Unfilled Order Count (USER_DATA)

        Displays the user's unfilled order count for all intervals.

        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rate_limit_order_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetRateLimitOrderV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_rate_limit_order_v3_without_preload_content(
        self,
        timestamp: StrictInt,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than `60000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Unfilled Order Count (USER_DATA)

        Displays the user's unfilled order count for all intervals.

        :param timestamp: (required)
        :type timestamp: int
        :param recv_window: The value cannot be greater than `60000`
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rate_limit_order_v3_serialize(
            timestamp=timestamp,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetRateLimitOrderV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_rate_limit_order_v3_serialize(
        self,
        timestamp,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/rateLimit/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticker24hr_v3(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetTicker24hrV3Resp:
        """24hr ticker price change statistics

        24 hour rolling window price change statistics. Careful when accessing this with no symbol.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker24hr_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTicker24hrV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticker24hr_v3_with_http_info(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetTicker24hrV3Resp]:
        """24hr ticker price change statistics

        24 hour rolling window price change statistics. Careful when accessing this with no symbol.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker24hr_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTicker24hrV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticker24hr_v3_without_preload_content(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """24hr ticker price change statistics

        24 hour rolling window price change statistics. Careful when accessing this with no symbol.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker24hr_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTicker24hrV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticker24hr_v3_serialize(
        self,
        symbol,
        symbols,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ticker/24hr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticker_book_ticker_v3(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetTickerBookTickerV3Resp:
        """Symbol order book ticker

        Best price/qty on the order book for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_book_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerBookTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticker_book_ticker_v3_with_http_info(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetTickerBookTickerV3Resp]:
        """Symbol order book ticker

        Best price/qty on the order book for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_book_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerBookTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticker_book_ticker_v3_without_preload_content(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Symbol order book ticker

        Best price/qty on the order book for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_book_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerBookTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticker_book_ticker_v3_serialize(
        self,
        symbol,
        symbols,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ticker/bookTicker',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticker_price_v3(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetTickerPriceV3Resp:
        """Symbol price ticker

        Latest price for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_price_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticker_price_v3_with_http_info(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetTickerPriceV3Resp]:
        """Symbol price ticker

        Latest price for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_price_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticker_price_v3_without_preload_content(
        self,
        symbol: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        symbols: Annotated[Optional[StrictStr], Field(description="Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Symbol price ticker

        Latest price for a symbol or symbols.

        :param symbol: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbol: str
        :param symbols: Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
        :type symbols: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_price_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerPriceV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticker_price_v3_serialize(
        self,
        symbol,
        symbols,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ticker/price',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticker_trading_day_v3(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetTickerTradingDayV3Resp:
        """Trading Day Ticker

        Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_trading_day_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            time_zone=time_zone,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerTradingDayV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticker_trading_day_v3_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetTickerTradingDayV3Resp]:
        """Trading Day Ticker

        Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_trading_day_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            time_zone=time_zone,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerTradingDayV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticker_trading_day_v3_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trading Day Ticker

        Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_trading_day_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            time_zone=time_zone,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerTradingDayV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticker_trading_day_v3_serialize(
        self,
        symbol,
        symbols,
        time_zone,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        if time_zone is not None:
            
            _query_params.append(('timeZone', time_zone))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ticker/tradingDay',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticker_v3(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        window_size: Annotated[Optional[StrictStr], Field(description="Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpotGetTickerV3Resp:
        """Rolling window price change statistics

        Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param window_size: Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)
        :type window_size: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            window_size=window_size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticker_v3_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        window_size: Annotated[Optional[StrictStr], Field(description="Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpotGetTickerV3Resp]:
        """Rolling window price change statistics

        Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param window_size: Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)
        :type window_size: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            window_size=window_size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticker_v3_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        symbols: Annotated[StrictStr, Field(description="Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.")],
        window_size: Annotated[Optional[StrictStr], Field(description="Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rolling window price change statistics

        Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

        :param symbol: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbol: str
        :param symbols: Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100. (required)
        :type symbols: str
        :param window_size: Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)
        :type window_size: str
        :param type: Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticker_v3_serialize(
            symbol=symbol,
            symbols=symbols,
            window_size=window_size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpotGetTickerV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticker_v3_serialize(
        self,
        symbol,
        symbols,
        window_size,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if symbols is not None:
            
            _query_params.append(('symbols', symbols))
            
        if window_size is not None:
            
            _query_params.append(('windowSize', window_size))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/ticker',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_time_v3(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTimeV3Resp:
        """Check server time

        Test connectivity to the Rest API and get the current server time.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_time_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTimeV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_time_v3_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTimeV3Resp]:
        """Check server time

        Test connectivity to the Rest API and get the current server time.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_time_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTimeV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_time_v3_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Check server time

        Test connectivity to the Rest API and get the current server time.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_time_v3_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTimeV3Resp",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_time_v3_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/time',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_trades_v3(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetTradesV3RespItem]:
        """Recent trades list

        Get recent trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_trades_v3_with_http_info(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetTradesV3RespItem]]:
        """Recent trades list

        Get recent trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_trades_v3_without_preload_content(
        self,
        symbol: StrictStr,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Recent trades list

        Get recent trades.

        :param symbol: (required)
        :type symbol: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_v3_serialize(
            symbol=symbol,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetTradesV3RespItem]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_trades_v3_serialize(
        self,
        symbol,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/trades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ui_klines_v3(
        self,
        symbol: StrictStr,
        interval: Annotated[StrictStr, Field(description="See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a>")],
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[GetKlinesV3200ResponseInnerInner]]:
        """UIKlines

        The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.

        :param symbol: (required)
        :type symbol: str
        :param interval: See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a> (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ui_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ui_klines_v3_with_http_info(
        self,
        symbol: StrictStr,
        interval: Annotated[StrictStr, Field(description="See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a>")],
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[GetKlinesV3200ResponseInnerInner]]]:
        """UIKlines

        The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.

        :param symbol: (required)
        :type symbol: str
        :param interval: See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a> (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ui_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ui_klines_v3_without_preload_content(
        self,
        symbol: StrictStr,
        interval: Annotated[StrictStr, Field(description="See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a>")],
        start_time: Optional[StrictInt] = None,
        end_time: Optional[StrictInt] = None,
        time_zone: Annotated[Optional[StrictStr], Field(description="Default: 0 (UTC)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Default 500; max 1000.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """UIKlines

        The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.

        :param symbol: (required)
        :type symbol: str
        :param interval: See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a> (required)
        :type interval: str
        :param start_time:
        :type start_time: int
        :param end_time:
        :type end_time: int
        :param time_zone: Default: 0 (UTC)
        :type time_zone: str
        :param limit: Default 500; max 1000.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ui_klines_v3_serialize(
            symbol=symbol,
            interval=interval,
            start_time=start_time,
            end_time=end_time,
            time_zone=time_zone,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[GetKlinesV3200ResponseInnerInner]]",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ui_klines_v3_serialize(
        self,
        symbol,
        interval,
        start_time,
        end_time,
        time_zone,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if time_zone is not None:
            
            _query_params.append(('timeZone', time_zone))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/uiKlines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_user_data_stream_v3(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Keepalive user data stream (USER_STREAM)

        Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_user_data_stream_v3_with_http_info(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Keepalive user data stream (USER_STREAM)

        Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_user_data_stream_v3_without_preload_content(
        self,
        listen_key: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Keepalive user data stream (USER_STREAM)

        Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

        :param listen_key: (required)
        :type listen_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_data_stream_v3_serialize(
            listen_key=listen_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '4XX': "APIError",
            '5XX': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_user_data_stream_v3_serialize(
        self,
        listen_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if listen_key is not None:
            _form_params.append(('listenKey', listen_key))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v3/userDataStream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


