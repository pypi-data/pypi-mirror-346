{
  "hash": "568a458b880581b05250ab30efbe2eef",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Quickstart guide\nsidebar: quickstart\n---\n\n\n\n## Requirements\nThe pyslammer package is built on Python 3.12. Earlier versions of Python 3 may work, but have not been tested.\n\n## Installation using pip\n[![PyPI](https://img.shields.io/pypi/v/pyslammer.svg){fig-align=\"left\"}](https://pypi.org/project/pyslammer)\n<!-- [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pyslammer.svg){fig-align=\"left\"}](https://pypi.org/project/pyslammer)\n[![PyPI - License](https://img.shields.io/pypi/l/pyslammer.svg){fig-align=\"left\"}](https://pypi.org/project/pyslammer) -->\n\nInstall pyslammer using `pip` from the Python Package Index (PyPI):\n``` bash\npip install pyslammer\n```\n## Basic Usage\nWith `pyslammer` installed, basic usage involves the following steps:\n1. Import the `pyslammer` module\n2. Import a ground motion\n3. Perform a rigid sliding block analysis\n4. View results\n\n### Import the pyslammer module\nThe recommended ailas for pyslammer is `slam`:\n\n::: {#9d04676b .cell execution_count=1}\n``` {.python .cell-code}\nimport pyslammer as slam \n```\n:::\n\n\nThis allows use of pyslammer features within your code with the short prefix `slam`.\n\nThe primary object type within pyslammer is the `SlidingBlockAnalysis` object.\nAt a minimum any `SlidingBlockAnalysis` requires a yield acceleration for the slope ($k_y$) and an input ground motion.\nAs basic example, consider a rigid sliding block analysis on a slope with a yield acceleration of $0.2$ g. \n\n### Import a ground motion\nA small number of sample ground motion records are included with `pyslammer`.\nWe will use one of the sample ground motion records, but we expect most users will import their ground motions from external sources. \nTo use any signal for a ground motion, `pyslammer` needs a 1-D array of acceleration in units of $g$ and the signal timestep (in seconds). \nSee The available sample ground motions can be viewed with:\n\n::: {#9832a3e6 .cell execution_count=2}\n``` {.python .cell-code}\nmotions = slam.sample_ground_motions() # Load all sample ground motions\nfor motion in motions:\n    print(motion)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMorgan_Hill_1984_CYC-285\nNisqually_2001_UNR-058\nImperial_Valley_1979_BCR-230\nNorthridge_1994_PAC-175\nChi-Chi_1999_TCU068-090\nCape_Mendocino_1992_PET-090\nCoalinga_1983_PVB-045\nMammoth_Lakes-2_1980_CVK-090\nKocaeli_1999_ATS-090\nNahanni_1985_NS1-280\nMammoth_Lakes-1_1980_CVK-090\nDuzce_1999_375-090\nLoma_Prieta_1989_HSP-000\nLanders_1992_LCN-345\nN_Palm_Springs_1986_WWT-180\nKobe_1995_TAK-090\nCoyote_Lake_1979_G02-050\nNorthridge_1994_VSP-360\n```\n:::\n:::\n\n\nFor this example, we will use the`Imperial_Valley_1979_BCR-230` motion.\n\n::: {#bf011644 .cell execution_count=3}\n``` {.python .cell-code}\ngm = motions[\"Imperial_Valley_1979_BCR-230\"]\n```\n:::\n\n\nThe timestep and acceleration signal for the imported ground motion are `gm.dt` and `gm.accel`, respectively.\n\n### Perform a rigid sliding block analysis\nWith the imported ground motion, `gm`, and the assumed value of $k_y$, we can perform a rigid sliding block analysis with pySLAMMER's `RigidAnalysis` object. \nThis simultaneously creates an instance of `RigidAnalysis` and performs the analysis, which is stored as `result`.\nThe inputs for `RigidAnalysis` are the input acceleration signal, time step, and the yield acceleration.\n\n\n\n\n```{note}\nA note admonition! Not for anyting in particular, though...\n```\n\n::: {#5ea401aa .cell execution_count=4}\n``` {.python .cell-code}\nky = 0.2 # yield acceleration in g\nresult = slam.RigidAnalysis(ky, gm.accel, gm.dt)\n```\n:::\n\n\n### View results\nThe primary output of the sliding block analysis is the final displacement (`SlidingBlockAnalysis.max_sliding_disp`).\nBy default, all lengths in pySLAMMER are in meters.\nThe cell below shows the displacement induced by the sample ground motion in the example:\n\n::: {#b3641313 .cell execution_count=5}\n``` {.python .cell-code}\nprint(f\"Slope yield acc: {ky:.2f} g \\nGround motion: {gm.name}; PGA: {gm.pga:.2f} g \\nSliding displacement: {result.max_sliding_disp:.3f} m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlope yield acc: 0.20 g \nGround motion: Imperial_Valley_1979_BCR-230; PGA: 0.77 g \nSliding displacement: 0.213 m\n```\n:::\n:::\n\n\nA built-in plotting function presents an at-a-glance picture of the analysis result in terms of the input motion and block accelerations, sliding velocity, and sliding displacement:\n\n::: {#cell-fig_quickstart_rigid .cell .column-page-right execution_count=6}\n``` {.python .cell-code}\nfig = result.sliding_block_plot()\n```\n\n::: {.cell-output .cell-output-display}\n![Rigid sliding block analysis results](quickstart_files/figure-html/fig_quickstart_rigid-output-1.png){#fig_quickstart_rigid width=662 height=470}\n:::\n:::\n\n\nIn addition to the final displacement, the displacement, velocity, and acceleration time histories of the block are returned as numpy arrays.\nSee the documentation for the `SlidingBlockAnalysis` class for a detailed description of all the results.\n\n",
    "supporting": [
      "quickstart_files"
    ],
    "filters": [],
    "includes": {}
  }
}