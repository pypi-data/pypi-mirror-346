{"title":"Results comparison to SLAMMER","markdown":{"yaml":{"title":"Results comparison to SLAMMER","bibliography":"references.bib","sidebar":"main"},"headingText":"Approach","containsRefs":false,"markdown":"\n\n```{python}\n#| echo: false\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport pyslammer as slam\nimport scipy.stats.mstats as ssmstat\nfrom cycler import cycler\nfrom tests.verification_processes import import_verification_data\nfrom great_tables import GT, md, html\nplt.style.use(slam.psfigstyle)\n```\n\nPySLAMMER's rigid, decoupled, and coupled analysis methods are intended to produce sliding block analysis results that match the legacy SLAMMER results. This is an important feature for sliding block displacements, which are used as a performance index (as opposed to providing a direct prediction of actual slope displacement) in practice. Equivalence with legacy results allows new results to be interpreted with reference to historical analyses and experience.\n\n\nTo demonstrate pySLAMMER's equivalence to SLAMMER, we performed several sliding block analyses across a broad parametric space. The three main categories of parameters studied were ground motion, analysis method, and analysis options.\n\n### Ground motion\n\nWe used the motions from pySLAMMER's built-in sample ground motion suite at several scales to capture a reasonable breadth of the familiar key engineering ground motion characteristics (frequency, amplitude, and duration). The acceleration response spectra for the input motion suite are shown in @fig-resp. Additional details on the ground motions are provided on the [ground motion suite page](ground_motions.qmd).\n\n```{python}\n#| code-fold: true\n#| label: fig-resp\n#| fig-align: center\n#| fig-cap: \"Acceleration response spectra for input ground motions\"\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\nfolder_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"pySLAMMER_suite_resp\"\ncsv_files = list(folder_path.glob(\"*.csv\"))\n\n# Read each CSV file into a DataFrame and store them in a list\nfreq_index = 0\nresp_index = 1\nspectra = {}\nfor csv_file in csv_files:\n    data = np.loadtxt(csv_file, delimiter=\",\", skiprows=2)\n    # convert response from cm/s^2 to g's\n    data[:, resp_index] = data[:, resp_index] / 981\n    spectra[csv_file.name.strip(\".csv\")] = data\n\n# Initialize the plot\nfig, ax = plt.subplots()\nax.set_prop_cycle(cycler(color=plt.cm.tab20.colors))\nfor motion in spectra:\n    ax.plot(\n        1/spectra[motion][:, freq_index],\n        spectra[motion][:, resp_index],\n        label=motion,\n        linewidth=0.5,\n    )\n\nax.text(0.012, 2.75, \"5% damping\")\n# Add labels, legend, and grid\nax.set_xlabel(\"Period (s)\")\nax.set_ylabel(\"Spectral Acceleration (g)\")\nax.set_title(\"Response Spectra\")\nax.set_xscale(\"log\")\nax.set_ylim(0,3)\nax.set_xlim(0.01,100)\n\nax.legend(\n    loc=\"center left\", \n    bbox_to_anchor=(0.6, 0.6), \n    fontsize=\"x-small\", \n    title=\"Ground Motion\", \n    title_fontsize=\"medium\",\n    frameon=False\n)\n\nplt.show()\n```\n\n### Analysis methods\n\nThe three rigorous analysis methods that SLAMMER performs are the Rigid, Decoupled, and Coupled methods. Each of these methods, which are briefly described below, are implemented in pySLAMMER and included in this comparison.\n\nRigid Block Analysis\n\n:   Conceptualized by Whitman in 1963 and further developed by Newmark in 1965 (@marcuson1994, @newmark1965), rigid block analysis models a potential landslide mass as a rigid mass on an inclined plane base with a perfectly plastic frictional interface. The rigid block motion matches the base motion exactly until the acceleration of the base exceeds some critical value (the yield acceleration, $k_y$). Once this critical $k_y$ value is reached, the block's acceleration remains constant $k_y$, resulting in relative velocity and displacement between block and base. The relative velocity is calculated by integrating the difference between the block and base accelerations. The displacement accumulated by the block moving down the ramp is calculated by integrating the relative velocity. Sliding stops (i.e., block motion again matches base motion exactly) when the relative velocity reaches zero.\n\nDecoupled Analysis\n\n:   Landslide materials are, of course, not rigid. Except for very shallow, stiff slide masses, the rigid block model does a poor job of approximating the dynamics of a co-seismic landslide system. The decoupled method was developed to provide some way of accounting for the deformation of the slope mass due to shaking (@seed1966, @makdisi1978) . It consists of two distinct (or decoupled, if you will) calculations: *dynamic response* and *rigid sliding*. During the dynamic response phase, the possibility of sliding is ignored while the slope response to strong ground motion is calculated. The average internal acceleration of the slope mass during this first phase is then used as the base input acceleration for the second phase (rigid sliding) which is simply a rigid block analysis.\n\nCoupled Analysis\n\n:   As indicated by the name, coupled analysis takes the two separate calculations from the decoupled analysis and performs them simultaneously. @chopra1991 introduced a model for earthquake-induced sliding of concrete gravity dams that considered the dynamic response of the dam during sliding. @rathje1999 modified the procedure and applied it to earth structures. With coupled sliding, the sliding mass's dynamic response is calculated for both sliding and non-sliding conditions. Sliding stops when the relative velocity of the sliding mass reaches zero. The stop of sliding can introduce an abrupt change in acceleration applied to the sliding mass. Because the dynamic response is being calculated continually through the analysis, the approach to identifying the timing of these abrupt changes will affect potential subsequent sliding events.\n\nDynamic Response\n\n:   The Decoupled and Coupled methods both require the calculation of the slope's dynamic response. The two methods for dynamic response in SLAMMER, which have been carried over to pySLAMMER are *linear elastic* and *equivalent linear*.\n\n### Analysis options\n\nSLAMMER allows users to include a constant $k_y$ value or a variable $k_y$ that changes with accumulated sliding displacement. The $k_y$ -- displacement relationship is stepwise with a table of paired values. This feature provides a rough means of approximating post-peak residual strength. ^[pySLAMMER includes additional options for variable yield acceleration, but only stepwise variation is applicable to comparison with SLAMMER]\n\nThe dynamic response of the system (applicable to decoupled and coupled analyses) is calculated using either *linear elastic* or *equivalent linear* assumptions. The minimum input parameters needed for the linear elastic analyses are a damping ration, the slope height, and the shear wave velocity of the material above and below the slip surface. For equivalent linear analysis, a reference strain parameter is also needed. Although not explicitly documented, inspection of the SLAMMER source code uses Darendeli (2001) modulus reduction and damping curves with a curvature coefficient of 1.\n\nSeparate entries for the shear wave velocity of the material above and below the slip surface ($V_s$ and $V_b$, respectively) are used to introduce an equivalent foundation radiation damping into the viscous material damping as described by @lee2004. This happens behind the scenes in SLAMMER by default and cannot be turned off. ^[If lower total damping than the equivalent foundation radiation damping is needed for some reason (e.g., for comparison with published analyses that did not include this damping mechanism) both SLAMMER and pySLAMMER accept negative values for damping ratio, which can be used to offset the damping applied by the foundation radiation damping.]\n\n@tbl-params shows the analysis options and ranges of input values used in the group of simulations used to compare pySLAMMER to \n\n```{python}\n#| code-fold: true\n#| label: tbl-params\n#| tbl-cap: Sliding block parameters used for pySLAMMER to SLAMMER comparison analyses.\n\nkykmax = [0.05, 1.0]\ntmts = [0.1, 10.0]\nheight = [0.1, 100]\nvs =  [200, 1200]\nvsvb =  [0.1, 100]\ndamp =  [5, 25]\nref_str =  [1, 10]\n\nparams = {\n    \"param\": [\n        \"Methods\",\n        \"Dynamic Resp.\",\n        \"ky/kmax\",\n        \"Tm/Tx *\",\n        \"Slope height (m) *\",\n        \"Slope shear wave vel., Vs (m/s) *\",\n        \"Vs/Vb *\",\n        \"Damping (%) *\",\n        \"Reference strain (%) **\"\n    ],\n    \"val\": [\n        \"Rigid, Decoupled, Coupled\",\n        \"Linear elastic, Equivalent linear\",\n        f\"{kykmax[0]} to {kykmax[1]}\",\n        f\"{tmts[0]} to {tmts[1]}\",\n        f\"{height[0]} to {height[1]}\",\n        f\"{vs[0]} to {vs[1]}\",\n        f\"{vsvb[0]} to {vsvb[1]}\",\n        f\"{damp[0]} to {damp[1]}\",\n        f\"{ref_str[0]} to {ref_str[1]}\"\n    ]\n}\n\n# * only applicable to Decoupled and Coupled methods\n# ** only applicable to equivalent linear dynamic response\n\ntbl = (\n    GT(pd.DataFrame(params))\n    .cols_label(\n    param=html(\"Parameter\"),\n    val=html(\"Range / Options used\")\n    )\n    .cols_align(align=\"center\", columns=1)\n    .tab_source_note(\"* Only applies to Decouled and Coupled analyses\") \n    .tab_source_note(\"** Only applies to equivalent linear analyses\")\n)\ntbl\n```\n\n## Results\n\nThe results of the simulations across the parametric space described in @tbl-params show excellent agreement between pySLAMMER and SLAMMER.\nWhen viewed at a linear scale, the results seem to show complete agreement (see @fig-linear).\nHowever, due to minor numerical differences and orders of operations between the two codes, some non-zero numerical differences should be expected.\n\n```{python}\n#| code-fold: true\n#| label: fig-linear\n#| fig-align: center\n#| fig-cap: \"Linear scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the differences are too small to be distinguished visually.\"\n\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\ndata_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"SLAMMER_results.xlsx\"\n\ndf = import_verification_data(data_path)\ndf[\"kykmax\"] = df[\"ky (g)\"] / df[\"kmax (g)\"]\n\ndfp = df[df[\"kykmax\"] < 1.0]\n\n############\n# pySLAMMER v. SLAMMER\n############\nfig, ax = plt.subplots()\ncmap = plt.cm.viridis  \n\n# Match color values to kykmax values\ncolor_values = dfp[\"kykmax\"] \n\n# Scatter plot with color mapping\nscatter = ax.scatter(\n    dfp[\"SLAMMER\"],  # x-axis values\n    dfp[\"pySLAMMER\"],  # y-axis values\n    c=color_values,  # Numeric values for coloring\n    cmap=cmap,  # Colormap\n    alpha=0.5,  # Transparency\n    marker=\".\",\n)\n\n# Add colorbar\ncbar = plt.colorbar(scatter, ax=ax, alpha=1)\ncbar.set_label(\"Yield Ratio ($k_y/k_{max}$)\")  # Label for the colorbar\n\n\nax.set_xlim(0, 1000)\nax.set_ylim(0, 1000)\n\nplt.grid()\n\nax.set_xlabel(\"SLAMMER displacement (cm)\")\nax.set_ylabel(\"pySLAMMER displacement (cm)\")\nplt.show()\n```\nViewed on a log-log scale, the numerical differences become become visible for analyses with sub-centimeter sliding displacements (@fig-loglog).\nIn practice, sub-centimeter sliding block displacements are not typically considered significant and the error magnitudes present at this scale are beyond the level of precision that sliding block results are interpreted at.\n\n```{python}\n#| code-fold: true\n#| label: fig-loglog\n#| fig-align: center\n#| fig-cap: \"Log-log scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the small differences become visible. Nevertheless, the match between the two is excellent in the range of engineering interest.\"\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlim(1e-3, 1e3)\nax.set_ylim(1e-3, 1e3)\n\nfig\n```\nThe numerical error magnitudes that are visibile in @fig-loglog are quantified in @tbl-comparison, which summarizes the fit of pySLAMMER to SLAMMER sliding block displacement results over different ranges of predicted displacement.\nThe linear regression parameters in @tbl-comparison show how well a straigt line fit would match the data set over discrete ranges of predicted displacements.\nWithin each displacment range, the 95th percentile error ^[95 percent of all simulations in the range had errors less than this.] is also reported.\n```{python}\n#| code-fold: true\n#| label: tbl-comparison\n#| tbl-cap: Comparison of pySLAMMER-SLAMMER results agreement by order of displacement magnitude.\n\nscales = [0.001, 0.01, 0.1, 1, 10, 100 ,1000]\ninterest = [\"no\", \"no\", \"yes\", \"yes\", \"yes\", \"yes\"]\nmatch_quality = [\"moderate\", \"very good\", \"excellent\", \"excellent\", \"excellent\", \"excellent\"]\ncomp = {\n    \"Range\": [],\n    \"Engineering\\nInterest\": [],\n    \"Computation\\nMatch\": [],\n    \"error_95\": [],\n    \"Slope\": [],\n    \"Intercept\": [],\n    \"R_sq\": []\n}\n\nfor i in range(len(scales)-1):\n    segment = dfp[\n        (dfp[\"SLAMMER\"] > scales[i])\n        & (dfp[\"SLAMMER\"] < scales[i+1])\n    ]\n    slope, intercept, r, p, se = ssmstat.linregress(\n        segment[\"SLAMMER\"],\n        segment[\"pySLAMMER\"],\n    )\n    comp[\"Range\"].append(f\"{scales[i]} to {scales[i+1]}\")\n    comp[\"Engineering\\nInterest\"].append(interest[i])\n    comp[\"error_95\"].append(f\"{np.percentile(\n        abs(segment[\"pySLAMMER\"] - segment[\"SLAMMER\"]),\n        95):.2f}\")\n    comp[\"Slope\"].append(f\"{slope:.2f}\")\n    comp[\"Intercept\"].append(f\"{intercept:.2f}\")\n    comp[\"R_sq\"].append(f\"{r**2:.2f}\")\n    comp[\"Computation\\nMatch\"].append(match_quality[i])\n    \n\ntbl = (\n    GT(pd.DataFrame(comp))\n    .tab_spanner(\n    label=\"Linear Regression Parameters\",\n    columns=[\"Slope\",\"Intercept\",\"R_sq\"]\n    )\n    .cols_label(\n    Range=html(\"Displacement Range<br>(cm)\"),\n    Intercept=html(\"Intercept<br>(cm)\"),\n    R_sq=html(\"R<sup>2</sup>\"),\n    error_95=html(\"95<sup>th</sup> percentile error<br>(cm)\")\n\n    )\n)\ntbl\n```\n\n\n## Conclusions\n\nThe results show that pySLAMMER is performing the same rigorous analysis methods as SLAMMER.\nAcross a broad array of input parameters, the results are identical or nearly identical.\nMinor numerical differences between the output of the two programs is to be expected. However, the differences are so small as to be insignificant for engineering purposes, both in research and practice.\n","srcMarkdownNoYaml":"\n\n```{python}\n#| echo: false\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport pyslammer as slam\nimport scipy.stats.mstats as ssmstat\nfrom cycler import cycler\nfrom tests.verification_processes import import_verification_data\nfrom great_tables import GT, md, html\nplt.style.use(slam.psfigstyle)\n```\n\nPySLAMMER's rigid, decoupled, and coupled analysis methods are intended to produce sliding block analysis results that match the legacy SLAMMER results. This is an important feature for sliding block displacements, which are used as a performance index (as opposed to providing a direct prediction of actual slope displacement) in practice. Equivalence with legacy results allows new results to be interpreted with reference to historical analyses and experience.\n\n## Approach\n\nTo demonstrate pySLAMMER's equivalence to SLAMMER, we performed several sliding block analyses across a broad parametric space. The three main categories of parameters studied were ground motion, analysis method, and analysis options.\n\n### Ground motion\n\nWe used the motions from pySLAMMER's built-in sample ground motion suite at several scales to capture a reasonable breadth of the familiar key engineering ground motion characteristics (frequency, amplitude, and duration). The acceleration response spectra for the input motion suite are shown in @fig-resp. Additional details on the ground motions are provided on the [ground motion suite page](ground_motions.qmd).\n\n```{python}\n#| code-fold: true\n#| label: fig-resp\n#| fig-align: center\n#| fig-cap: \"Acceleration response spectra for input ground motions\"\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\nfolder_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"pySLAMMER_suite_resp\"\ncsv_files = list(folder_path.glob(\"*.csv\"))\n\n# Read each CSV file into a DataFrame and store them in a list\nfreq_index = 0\nresp_index = 1\nspectra = {}\nfor csv_file in csv_files:\n    data = np.loadtxt(csv_file, delimiter=\",\", skiprows=2)\n    # convert response from cm/s^2 to g's\n    data[:, resp_index] = data[:, resp_index] / 981\n    spectra[csv_file.name.strip(\".csv\")] = data\n\n# Initialize the plot\nfig, ax = plt.subplots()\nax.set_prop_cycle(cycler(color=plt.cm.tab20.colors))\nfor motion in spectra:\n    ax.plot(\n        1/spectra[motion][:, freq_index],\n        spectra[motion][:, resp_index],\n        label=motion,\n        linewidth=0.5,\n    )\n\nax.text(0.012, 2.75, \"5% damping\")\n# Add labels, legend, and grid\nax.set_xlabel(\"Period (s)\")\nax.set_ylabel(\"Spectral Acceleration (g)\")\nax.set_title(\"Response Spectra\")\nax.set_xscale(\"log\")\nax.set_ylim(0,3)\nax.set_xlim(0.01,100)\n\nax.legend(\n    loc=\"center left\", \n    bbox_to_anchor=(0.6, 0.6), \n    fontsize=\"x-small\", \n    title=\"Ground Motion\", \n    title_fontsize=\"medium\",\n    frameon=False\n)\n\nplt.show()\n```\n\n### Analysis methods\n\nThe three rigorous analysis methods that SLAMMER performs are the Rigid, Decoupled, and Coupled methods. Each of these methods, which are briefly described below, are implemented in pySLAMMER and included in this comparison.\n\nRigid Block Analysis\n\n:   Conceptualized by Whitman in 1963 and further developed by Newmark in 1965 (@marcuson1994, @newmark1965), rigid block analysis models a potential landslide mass as a rigid mass on an inclined plane base with a perfectly plastic frictional interface. The rigid block motion matches the base motion exactly until the acceleration of the base exceeds some critical value (the yield acceleration, $k_y$). Once this critical $k_y$ value is reached, the block's acceleration remains constant $k_y$, resulting in relative velocity and displacement between block and base. The relative velocity is calculated by integrating the difference between the block and base accelerations. The displacement accumulated by the block moving down the ramp is calculated by integrating the relative velocity. Sliding stops (i.e., block motion again matches base motion exactly) when the relative velocity reaches zero.\n\nDecoupled Analysis\n\n:   Landslide materials are, of course, not rigid. Except for very shallow, stiff slide masses, the rigid block model does a poor job of approximating the dynamics of a co-seismic landslide system. The decoupled method was developed to provide some way of accounting for the deformation of the slope mass due to shaking (@seed1966, @makdisi1978) . It consists of two distinct (or decoupled, if you will) calculations: *dynamic response* and *rigid sliding*. During the dynamic response phase, the possibility of sliding is ignored while the slope response to strong ground motion is calculated. The average internal acceleration of the slope mass during this first phase is then used as the base input acceleration for the second phase (rigid sliding) which is simply a rigid block analysis.\n\nCoupled Analysis\n\n:   As indicated by the name, coupled analysis takes the two separate calculations from the decoupled analysis and performs them simultaneously. @chopra1991 introduced a model for earthquake-induced sliding of concrete gravity dams that considered the dynamic response of the dam during sliding. @rathje1999 modified the procedure and applied it to earth structures. With coupled sliding, the sliding mass's dynamic response is calculated for both sliding and non-sliding conditions. Sliding stops when the relative velocity of the sliding mass reaches zero. The stop of sliding can introduce an abrupt change in acceleration applied to the sliding mass. Because the dynamic response is being calculated continually through the analysis, the approach to identifying the timing of these abrupt changes will affect potential subsequent sliding events.\n\nDynamic Response\n\n:   The Decoupled and Coupled methods both require the calculation of the slope's dynamic response. The two methods for dynamic response in SLAMMER, which have been carried over to pySLAMMER are *linear elastic* and *equivalent linear*.\n\n### Analysis options\n\nSLAMMER allows users to include a constant $k_y$ value or a variable $k_y$ that changes with accumulated sliding displacement. The $k_y$ -- displacement relationship is stepwise with a table of paired values. This feature provides a rough means of approximating post-peak residual strength. ^[pySLAMMER includes additional options for variable yield acceleration, but only stepwise variation is applicable to comparison with SLAMMER]\n\nThe dynamic response of the system (applicable to decoupled and coupled analyses) is calculated using either *linear elastic* or *equivalent linear* assumptions. The minimum input parameters needed for the linear elastic analyses are a damping ration, the slope height, and the shear wave velocity of the material above and below the slip surface. For equivalent linear analysis, a reference strain parameter is also needed. Although not explicitly documented, inspection of the SLAMMER source code uses Darendeli (2001) modulus reduction and damping curves with a curvature coefficient of 1.\n\nSeparate entries for the shear wave velocity of the material above and below the slip surface ($V_s$ and $V_b$, respectively) are used to introduce an equivalent foundation radiation damping into the viscous material damping as described by @lee2004. This happens behind the scenes in SLAMMER by default and cannot be turned off. ^[If lower total damping than the equivalent foundation radiation damping is needed for some reason (e.g., for comparison with published analyses that did not include this damping mechanism) both SLAMMER and pySLAMMER accept negative values for damping ratio, which can be used to offset the damping applied by the foundation radiation damping.]\n\n@tbl-params shows the analysis options and ranges of input values used in the group of simulations used to compare pySLAMMER to \n\n```{python}\n#| code-fold: true\n#| label: tbl-params\n#| tbl-cap: Sliding block parameters used for pySLAMMER to SLAMMER comparison analyses.\n\nkykmax = [0.05, 1.0]\ntmts = [0.1, 10.0]\nheight = [0.1, 100]\nvs =  [200, 1200]\nvsvb =  [0.1, 100]\ndamp =  [5, 25]\nref_str =  [1, 10]\n\nparams = {\n    \"param\": [\n        \"Methods\",\n        \"Dynamic Resp.\",\n        \"ky/kmax\",\n        \"Tm/Tx *\",\n        \"Slope height (m) *\",\n        \"Slope shear wave vel., Vs (m/s) *\",\n        \"Vs/Vb *\",\n        \"Damping (%) *\",\n        \"Reference strain (%) **\"\n    ],\n    \"val\": [\n        \"Rigid, Decoupled, Coupled\",\n        \"Linear elastic, Equivalent linear\",\n        f\"{kykmax[0]} to {kykmax[1]}\",\n        f\"{tmts[0]} to {tmts[1]}\",\n        f\"{height[0]} to {height[1]}\",\n        f\"{vs[0]} to {vs[1]}\",\n        f\"{vsvb[0]} to {vsvb[1]}\",\n        f\"{damp[0]} to {damp[1]}\",\n        f\"{ref_str[0]} to {ref_str[1]}\"\n    ]\n}\n\n# * only applicable to Decoupled and Coupled methods\n# ** only applicable to equivalent linear dynamic response\n\ntbl = (\n    GT(pd.DataFrame(params))\n    .cols_label(\n    param=html(\"Parameter\"),\n    val=html(\"Range / Options used\")\n    )\n    .cols_align(align=\"center\", columns=1)\n    .tab_source_note(\"* Only applies to Decouled and Coupled analyses\") \n    .tab_source_note(\"** Only applies to equivalent linear analyses\")\n)\ntbl\n```\n\n## Results\n\nThe results of the simulations across the parametric space described in @tbl-params show excellent agreement between pySLAMMER and SLAMMER.\nWhen viewed at a linear scale, the results seem to show complete agreement (see @fig-linear).\nHowever, due to minor numerical differences and orders of operations between the two codes, some non-zero numerical differences should be expected.\n\n```{python}\n#| code-fold: true\n#| label: fig-linear\n#| fig-align: center\n#| fig-cap: \"Linear scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the differences are too small to be distinguished visually.\"\n\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\ndata_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"SLAMMER_results.xlsx\"\n\ndf = import_verification_data(data_path)\ndf[\"kykmax\"] = df[\"ky (g)\"] / df[\"kmax (g)\"]\n\ndfp = df[df[\"kykmax\"] < 1.0]\n\n############\n# pySLAMMER v. SLAMMER\n############\nfig, ax = plt.subplots()\ncmap = plt.cm.viridis  \n\n# Match color values to kykmax values\ncolor_values = dfp[\"kykmax\"] \n\n# Scatter plot with color mapping\nscatter = ax.scatter(\n    dfp[\"SLAMMER\"],  # x-axis values\n    dfp[\"pySLAMMER\"],  # y-axis values\n    c=color_values,  # Numeric values for coloring\n    cmap=cmap,  # Colormap\n    alpha=0.5,  # Transparency\n    marker=\".\",\n)\n\n# Add colorbar\ncbar = plt.colorbar(scatter, ax=ax, alpha=1)\ncbar.set_label(\"Yield Ratio ($k_y/k_{max}$)\")  # Label for the colorbar\n\n\nax.set_xlim(0, 1000)\nax.set_ylim(0, 1000)\n\nplt.grid()\n\nax.set_xlabel(\"SLAMMER displacement (cm)\")\nax.set_ylabel(\"pySLAMMER displacement (cm)\")\nplt.show()\n```\nViewed on a log-log scale, the numerical differences become become visible for analyses with sub-centimeter sliding displacements (@fig-loglog).\nIn practice, sub-centimeter sliding block displacements are not typically considered significant and the error magnitudes present at this scale are beyond the level of precision that sliding block results are interpreted at.\n\n```{python}\n#| code-fold: true\n#| label: fig-loglog\n#| fig-align: center\n#| fig-cap: \"Log-log scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the small differences become visible. Nevertheless, the match between the two is excellent in the range of engineering interest.\"\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlim(1e-3, 1e3)\nax.set_ylim(1e-3, 1e3)\n\nfig\n```\nThe numerical error magnitudes that are visibile in @fig-loglog are quantified in @tbl-comparison, which summarizes the fit of pySLAMMER to SLAMMER sliding block displacement results over different ranges of predicted displacement.\nThe linear regression parameters in @tbl-comparison show how well a straigt line fit would match the data set over discrete ranges of predicted displacements.\nWithin each displacment range, the 95th percentile error ^[95 percent of all simulations in the range had errors less than this.] is also reported.\n```{python}\n#| code-fold: true\n#| label: tbl-comparison\n#| tbl-cap: Comparison of pySLAMMER-SLAMMER results agreement by order of displacement magnitude.\n\nscales = [0.001, 0.01, 0.1, 1, 10, 100 ,1000]\ninterest = [\"no\", \"no\", \"yes\", \"yes\", \"yes\", \"yes\"]\nmatch_quality = [\"moderate\", \"very good\", \"excellent\", \"excellent\", \"excellent\", \"excellent\"]\ncomp = {\n    \"Range\": [],\n    \"Engineering\\nInterest\": [],\n    \"Computation\\nMatch\": [],\n    \"error_95\": [],\n    \"Slope\": [],\n    \"Intercept\": [],\n    \"R_sq\": []\n}\n\nfor i in range(len(scales)-1):\n    segment = dfp[\n        (dfp[\"SLAMMER\"] > scales[i])\n        & (dfp[\"SLAMMER\"] < scales[i+1])\n    ]\n    slope, intercept, r, p, se = ssmstat.linregress(\n        segment[\"SLAMMER\"],\n        segment[\"pySLAMMER\"],\n    )\n    comp[\"Range\"].append(f\"{scales[i]} to {scales[i+1]}\")\n    comp[\"Engineering\\nInterest\"].append(interest[i])\n    comp[\"error_95\"].append(f\"{np.percentile(\n        abs(segment[\"pySLAMMER\"] - segment[\"SLAMMER\"]),\n        95):.2f}\")\n    comp[\"Slope\"].append(f\"{slope:.2f}\")\n    comp[\"Intercept\"].append(f\"{intercept:.2f}\")\n    comp[\"R_sq\"].append(f\"{r**2:.2f}\")\n    comp[\"Computation\\nMatch\"].append(match_quality[i])\n    \n\ntbl = (\n    GT(pd.DataFrame(comp))\n    .tab_spanner(\n    label=\"Linear Regression Parameters\",\n    columns=[\"Slope\",\"Intercept\",\"R_sq\"]\n    )\n    .cols_label(\n    Range=html(\"Displacement Range<br>(cm)\"),\n    Intercept=html(\"Intercept<br>(cm)\"),\n    R_sq=html(\"R<sup>2</sup>\"),\n    error_95=html(\"95<sup>th</sup> percentile error<br>(cm)\")\n\n    )\n)\ntbl\n```\n\n\n## Conclusions\n\nThe results show that pySLAMMER is performing the same rigorous analysis methods as SLAMMER.\nAcross a broad array of input parameters, the results are identical or nearly identical.\nMinor numerical differences between the output of the two programs is to be expected. However, the differences are so small as to be insignificant for engineering purposes, both in research and practice.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"svg","to":"html","css":["../styles.css"],"toc":true,"output-file":"comp_SLAMMER_results.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","quartodoc":{"package":"pyslammer","dir":"../api","sidebar":"../api/_sidebar.yml","sections":[{"title":"API Reference","desc":"API reference for pySLAMMER","contents":["SlidingBlockAnalysis","RigidAnalysis","Decoupled","Coupled","GroundMotion","sample_ground_motions"]}]},"theme":["cosmo"],"sidebar":"main","title":"Results comparison to SLAMMER","bibliography":["references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}