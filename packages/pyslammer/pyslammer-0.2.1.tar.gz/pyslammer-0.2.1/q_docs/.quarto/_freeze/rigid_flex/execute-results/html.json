{
  "hash": "5cd67e5ff2ed8f08d4a2bc41cb1208ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Rigid and Flexible Anlysis\n---\n\n\n\nThis notebook shows an example use case of pyslammer for running rigid, decoupled, and coupled sliding block analyses.\n\n*The next steps assume you've already installed pySLAMMER from PYPI:*\n\n``` bash\n    pip install pyslammer\n```\n\nFirst, import pySLAMMER and a couple other helpful packages\n\n\n::: {#422b3941 .cell execution_count=1}\n``` {.python .cell-code}\nimport pyslammer as slam\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nNext define the ground motion to use in the analysis. For this example, we will use one of pySLAMMER's built in ground motions from the 1995 Kobe earthquake. This creates a ground motion object with `accel` and `dt` attributes with the acceleration array and timestep, respectively.\n\n::: {#315d735e .cell execution_count=2}\n``` {.python .cell-code}\nrecord_name = \"Kobe_1995_TAK-090\"\ngm = slam.sample_ground_motions()[record_name]\n```\n:::\n\n\n## Rigid block analysis\n\nA rigid block analysis requires at least three input parameters:\n\n-   `a_in` - the input acceleration time history (in units of g)\n-   `dt` - the timestep separating the acceleration data points\n-   `ky` - the slope's yield acceleration (in units of g)\n\nThese parameters are stored in a dictionary (`rigid_inputs`) and used as kwarg input to the `RigidAnalysis` method.\n\n::: {#c65b4d91 .cell execution_count=3}\n``` {.python .cell-code}\nrigid_inputs = {\n    \"a_in\": gm.accel,\n    \"dt\": gm.dt,\n    \"ky\": 0.2\n}\nprint(rigid_inputs)\n\nrigid_result = slam.RigidAnalysis(**rigid_inputs, scale_factor=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a_in': array([ 1.36409e-04,  7.44843e-05, -2.41948e-06, ..., -3.40833e-04,\n       -3.29109e-04, -3.24053e-04], shape=(4015,)), 'dt': 0.01, 'ky': 0.2}\n```\n:::\n:::\n\n\n::: callout-note\n## Note\n\nPassing the input variables to `slam.RigidAnalysis` as a dictionary isn't necessary, it's just a convenient way to package groups of input variables. The following line would have produced the same result as the previous cell:\n\n`rigid_result = slam.RigidAnalysis(gm.accel, gm.dt, 0.2)`\n:::\n\n## Flexible sliding block analysis\n\nThe flexible block analyses (decoupled and coupled) require additional input parameters to define the stiffness of the model:\n\n-   `height` - the slope height (in meters, by default)\n-   `vs_slope` - the slope shear wave velocity (in meters per second, by default)\n-   `vs_base` - the base shear wave velocity (in meters per second, by default)\n-   `damp_ratio` - the slope damping ratio\n-   `ref_strain` - the slope reference strain\n-   `soil_model` - the dynamic analysis method used (either `linear_elastic` or `equivalent_linear`)\n\nThese parameters are stored in a dictionary (`flexible_inputs`) and used as kwargs along with those used in the rigid analysis. The decoupled and coupled analyses are run with the `Decoupled` and `Coupled` methods, respectively.\n\n::: {#fcc25aeb .cell execution_count=4}\n``` {.python .cell-code}\nflexible_inputs = {\n    \"height\": 50.0,\n    \"vs_slope\": 600.0,\n    \"vs_base\": 600.0,\n    \"damp_ratio\": 0.05,\n    \"ref_strain\": 0.0005,\n    \"soil_model\": \"equivalent_linear\"\n}\n\ndecoupled_result = slam.Decoupled(**rigid_inputs,**flexible_inputs)\ndecoupled_result._compile_attributes()\ncoupled_result = slam.Coupled(**rigid_inputs,**flexible_inputs)\ncoupled_result._compile_attributes()\n```\n:::\n\n\n## Comparison of analysis methods\n\nA simple plot comparing the block displacements with time can be generated by accessing the `.sliding_disp` attribute of each analysis result.\n\n::: {#e8e320d1 .cell execution_count=5}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 6))\n\ntime = np.arange(0, len(gm.accel) * gm.dt, gm.dt)\n\n# Plot block displacement vs time for each analysis method\nplt.plot(time, rigid_result.sliding_disp, label='Rigid Analysis')\nplt.plot(time, decoupled_result.sliding_disp, label='Decoupled Analysis')\nplt.plot(time, coupled_result.sliding_disp, label='Coupled Analysis')\n\n# Add labels and legend\nplt.xlabel('Time (s)')\nplt.ylabel('Block Displacement (m)')\nplt.title(f'Block Displacement with Different Analysis Methods\\n for {record_name}')\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](rigid_flex_files/figure-html/cell-6-output-1.png){width=812 height=541}\n:::\n:::\n\n\n::: {#9ea94fda .cell execution_count=6}\n``` {.python .cell-code}\nrigid_fig = rigid_result.sliding_block_plot()\ndecoupled_fig = decoupled_result.sliding_block_plot()\ncoupled_fig = coupled_result.sliding_block_plot()\n```\n\n::: {.cell-output .cell-output-display}\n![](rigid_flex_files/figure-html/cell-7-output-1.png){width=662 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](rigid_flex_files/figure-html/cell-7-output-2.png){width=662 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](rigid_flex_files/figure-html/cell-7-output-3.png){width=662 height=470}\n:::\n:::\n\n\n",
    "supporting": [
      "rigid_flex_files"
    ],
    "filters": [],
    "includes": {}
  }
}