[
  {
    "objectID": "technical/tech_manual.html",
    "href": "technical/tech_manual.html",
    "title": "Technical guide",
    "section": "",
    "text": "Glossary\nVerifications",
    "crumbs": [
      "Quickstart guide",
      "Technical guide"
    ]
  },
  {
    "objectID": "technical/glossary.html",
    "href": "technical/glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Note\n\n\n\nThis page is a stub and will be updated soon.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Glossary"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_perf.html",
    "href": "technical/comp_SLAMMER_perf.html",
    "title": "Comparison with SLAMMER (speed)",
    "section": "",
    "text": "Note\n\n\n\nThis page is a stub and will be updated soon.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Comparison with SLAMMER (speed)"
    ]
  },
  {
    "objectID": "api/GroundMotion.html",
    "href": "api/GroundMotion.html",
    "title": "GroundMotion",
    "section": "",
    "text": "GroundMotion(self, accel, dt, name='None')\nGround Motion Record.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naccel\nnp.ndarray or list\nGround motion acceleration record in g.\nrequired\n\n\ndt\nfloat\nTime step of the record (s).\nrequired\n\n\nname\nstr\nName of the record (default is ‘None’).\n'None'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\naccel\nnp.ndarray\nGround motion acceleration record in g.\n\n\ndt\nfloat\nTime step of the record (s).\n\n\nname\nstr\nName of the record.\n\n\npga\nfloat\nPeak ground acceleration in g.\n\n\nmean_period\nfloat\nMean period of the ground motion.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninvert\nInvert the ground motion.\n\n\nplot\nPlots desired ground motion parameters.\n\n\nscale\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\nuninvert\nUninverts the ground motion.\n\n\nunscale\nUnscales the ground motion.\n\n\n\n\n\nGroundMotion.invert()\nInvert the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.plot(acc=True, vel=True, disp=True, enable=True, called=False)\nPlots desired ground motion parameters.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nacc\nbool\nPlot acceleration.\nTrue\n\n\nvel\nbool\nPlot velocity.\nTrue\n\n\ndisp\nbool\nPlot displacement.\nTrue\n\n\nenable\nbool\nEnable plotting of ground parameters. Used if called from a RigidBlock object.\nTrue\n\n\ncalled\nbool\nTrue if called from a RigidBlock object.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nplt.figure\nFigure object if called from a RigidBlock object.\n\n\nax\nplt.axis\nAxis object if called from a RigidBlock object.\n\n\n\n\n\n\n\nGroundMotion.scale(pga=False, scale_factor=False)\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npga\nfloat\nDesired peak ground acceleration in g.\nFalse\n\n\nscale_factor\nfloat\nDesired scale factor.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.uninvert()\nUninverts the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.unscale()\nUnscales the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "API Reference",
      "GroundMotion"
    ]
  },
  {
    "objectID": "api/GroundMotion.html#parameters",
    "href": "api/GroundMotion.html#parameters",
    "title": "GroundMotion",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naccel\nnp.ndarray or list\nGround motion acceleration record in g.\nrequired\n\n\ndt\nfloat\nTime step of the record (s).\nrequired\n\n\nname\nstr\nName of the record (default is ‘None’).\n'None'",
    "crumbs": [
      "API Reference",
      "GroundMotion"
    ]
  },
  {
    "objectID": "api/GroundMotion.html#attributes",
    "href": "api/GroundMotion.html#attributes",
    "title": "GroundMotion",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\naccel\nnp.ndarray\nGround motion acceleration record in g.\n\n\ndt\nfloat\nTime step of the record (s).\n\n\nname\nstr\nName of the record.\n\n\npga\nfloat\nPeak ground acceleration in g.\n\n\nmean_period\nfloat\nMean period of the ground motion.",
    "crumbs": [
      "API Reference",
      "GroundMotion"
    ]
  },
  {
    "objectID": "api/GroundMotion.html#methods",
    "href": "api/GroundMotion.html#methods",
    "title": "GroundMotion",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninvert\nInvert the ground motion.\n\n\nplot\nPlots desired ground motion parameters.\n\n\nscale\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\nuninvert\nUninverts the ground motion.\n\n\nunscale\nUnscales the ground motion.\n\n\n\n\n\nGroundMotion.invert()\nInvert the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.plot(acc=True, vel=True, disp=True, enable=True, called=False)\nPlots desired ground motion parameters.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nacc\nbool\nPlot acceleration.\nTrue\n\n\nvel\nbool\nPlot velocity.\nTrue\n\n\ndisp\nbool\nPlot displacement.\nTrue\n\n\nenable\nbool\nEnable plotting of ground parameters. Used if called from a RigidBlock object.\nTrue\n\n\ncalled\nbool\nTrue if called from a RigidBlock object.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nplt.figure\nFigure object if called from a RigidBlock object.\n\n\nax\nplt.axis\nAxis object if called from a RigidBlock object.\n\n\n\n\n\n\n\nGroundMotion.scale(pga=False, scale_factor=False)\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npga\nfloat\nDesired peak ground acceleration in g.\nFalse\n\n\nscale_factor\nfloat\nDesired scale factor.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.uninvert()\nUninverts the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nGroundMotion.unscale()\nUnscales the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "API Reference",
      "GroundMotion"
    ]
  },
  {
    "objectID": "api/Decoupled.html",
    "href": "api/Decoupled.html",
    "title": "Decoupled",
    "section": "",
    "text": "Decoupled(\n    self,\n    ky,\n    a_in,\n    dt,\n    height,\n    vs_slope,\n    vs_base,\n    damp_ratio,\n    ref_strain,\n    scale_factor=1,\n    target_pga=None,\n    soil_model='linear_elastic',\n    si_units=True,\n    lite=False,\n)\nDecoupled analysis for sliding block and ground motion interaction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nky\nfloat or tuple[list[float], list[float]] or tuple[np.ndarray, np.ndarray] or callable\nYield acceleration function or constant.\nrequired\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration.\nrequired\n\n\nheight\nint or float\nHeight of the sliding block.\nrequired\n\n\nvs_slope\nint or float\nShear wave velocity of the slope.\nrequired\n\n\nvs_base\nint or float\nShear wave velocity of the base.\nrequired\n\n\ndamp_ratio\nfloat\nDamping ratio of the sliding block.\nrequired\n\n\nref_strain\nfloat\nReference strain for modulus reduction.\nrequired\n\n\nscale_factor\nfloat\nScale factor for the input acceleration. Default is 1.\n1\n\n\nsoil_model\nstr\nSoil model type. Default is “linear_elastic”.\n'linear_elastic'\n\n\nsi_units\nbool\nWhether to use SI units. Default is True.\nTrue\n\n\nlite\nbool\nWhether to use lite mode. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nk_y\ncallable\nYield acceleration function.\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\n\n\ndt\nfloat\nTime step of the input acceleration.\n\n\nheight\nint or float\nHeight of the sliding block.\n\n\nvs_slope\nint or float\nShear wave velocity of the slope.\n\n\nvs_base\nint or float\nShear wave velocity of the base.\n\n\ndamp_ratio\nfloat\nDamping ratio of the sliding block.\n\n\nref_strain\nfloat\nReference strain for modulus reduction.\n\n\nscale_factor\nfloat\nScale factor for the input acceleration.\n\n\nsoil_model\nstr\nSoil model type.\n\n\nsi_units\nbool\nWhether to use SI units.\n\n\nlite\nbool\nWhether to use lite mode.\n\n\nnpts\nint\nNumber of points in the input acceleration time history.\n\n\ng\nfloat\nGravitational acceleration.\n\n\nunit_weight\nfloat\nUnit weight of the sliding block.\n\n\nrho\nfloat\nDensity of the sliding block.\n\n\nmass\nfloat\nMass of the sliding block.\n\n\nmax_shear_mod\nfloat\nMaximum shear modulus of the sliding block.\n\n\nHEA\nnp.ndarray\nHorizontal earthquake acceleration.\n\n\nblock_disp\nnp.ndarray\nDisplacement of the sliding block.\n\n\nblock_vel\nnp.ndarray\nVelocity of the sliding block.\n\n\nblock_acc\nnp.ndarray\nAcceleration of the sliding block.\n\n\nx_resp\nnp.ndarray\nResponse displacement.\n\n\nv_resp\nnp.ndarray\nResponse velocity.\n\n\na_resp\nnp.ndarray\nResponse acceleration.\n\n\nmax_sliding_disp\nfloat\nMaximum sliding displacement.\n\n\nground_acc\nnp.ndarray\nGround acceleration.",
    "crumbs": [
      "API Reference",
      "Decoupled"
    ]
  },
  {
    "objectID": "api/Decoupled.html#parameters",
    "href": "api/Decoupled.html#parameters",
    "title": "Decoupled",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nky\nfloat or tuple[list[float], list[float]] or tuple[np.ndarray, np.ndarray] or callable\nYield acceleration function or constant.\nrequired\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration.\nrequired\n\n\nheight\nint or float\nHeight of the sliding block.\nrequired\n\n\nvs_slope\nint or float\nShear wave velocity of the slope.\nrequired\n\n\nvs_base\nint or float\nShear wave velocity of the base.\nrequired\n\n\ndamp_ratio\nfloat\nDamping ratio of the sliding block.\nrequired\n\n\nref_strain\nfloat\nReference strain for modulus reduction.\nrequired\n\n\nscale_factor\nfloat\nScale factor for the input acceleration. Default is 1.\n1\n\n\nsoil_model\nstr\nSoil model type. Default is “linear_elastic”.\n'linear_elastic'\n\n\nsi_units\nbool\nWhether to use SI units. Default is True.\nTrue\n\n\nlite\nbool\nWhether to use lite mode. Default is False.\nFalse",
    "crumbs": [
      "API Reference",
      "Decoupled"
    ]
  },
  {
    "objectID": "api/Decoupled.html#attributes",
    "href": "api/Decoupled.html#attributes",
    "title": "Decoupled",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nk_y\ncallable\nYield acceleration function.\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\n\n\ndt\nfloat\nTime step of the input acceleration.\n\n\nheight\nint or float\nHeight of the sliding block.\n\n\nvs_slope\nint or float\nShear wave velocity of the slope.\n\n\nvs_base\nint or float\nShear wave velocity of the base.\n\n\ndamp_ratio\nfloat\nDamping ratio of the sliding block.\n\n\nref_strain\nfloat\nReference strain for modulus reduction.\n\n\nscale_factor\nfloat\nScale factor for the input acceleration.\n\n\nsoil_model\nstr\nSoil model type.\n\n\nsi_units\nbool\nWhether to use SI units.\n\n\nlite\nbool\nWhether to use lite mode.\n\n\nnpts\nint\nNumber of points in the input acceleration time history.\n\n\ng\nfloat\nGravitational acceleration.\n\n\nunit_weight\nfloat\nUnit weight of the sliding block.\n\n\nrho\nfloat\nDensity of the sliding block.\n\n\nmass\nfloat\nMass of the sliding block.\n\n\nmax_shear_mod\nfloat\nMaximum shear modulus of the sliding block.\n\n\nHEA\nnp.ndarray\nHorizontal earthquake acceleration.\n\n\nblock_disp\nnp.ndarray\nDisplacement of the sliding block.\n\n\nblock_vel\nnp.ndarray\nVelocity of the sliding block.\n\n\nblock_acc\nnp.ndarray\nAcceleration of the sliding block.\n\n\nx_resp\nnp.ndarray\nResponse displacement.\n\n\nv_resp\nnp.ndarray\nResponse velocity.\n\n\na_resp\nnp.ndarray\nResponse acceleration.\n\n\nmax_sliding_disp\nfloat\nMaximum sliding displacement.\n\n\nground_acc\nnp.ndarray\nGround acceleration.",
    "crumbs": [
      "API Reference",
      "Decoupled"
    ]
  },
  {
    "objectID": "api/SlidingBlockAnalysis.html",
    "href": "api/SlidingBlockAnalysis.html",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "SlidingBlockAnalysis(self, ky, a_in, dt, scale_factor=1.0, target_pga=None)\nBase class for all time-domain sliding block analyses. SlidingBlockAnalysis does not perform any analysis by itself. It is meant to be subclassed by other classes that implement specific sliding block analysis methods. It performs checks on the input parameters and initializes the attributes for the analysis. The class also provides a method to plot the results of the analysis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nky\nfloat\nYield acceleration of the sliding block (in g).\nrequired\n\n\na_in\nnumpy.ndarray\nInput acceleration time series (in m/s^2).\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration time series (in seconds).\nrequired\n\n\nscale_factor\nfloat\nScaling factor for the input acceleration. Default is 1.0.\n1.0\n\n\ntarget_pga\nfloat\nTarget peak ground acceleration (in m/s^2). If provided, the input acceleration will be scaled to match this value. Cannot be used with scale_factor.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf both target_pga and scale_factor are provided.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscale_factor\nfloat\nScaling factor applied to the input acceleration.\n\n\na_in\nnumpy.ndarray\nScaled input acceleration time series.\n\n\nmethod\nstr or None\nAnalysis method used (to be defined in subclasses).\n\n\nky\nfloat or None\nYield acceleration of the sliding block (in g).\n\n\ntime\nnumpy.ndarray or None\nTime array corresponding to the input acceleration.\n\n\nground_acc\nnumpy.ndarray or None\nGround acceleration time series (in m/s^2).\n\n\nground_vel\nnumpy.ndarray or None\nGround velocity time series (in m/s).\n\n\nground_disp\nnumpy.ndarray or None\nGround displacement time series (in m).\n\n\nblock_acc\nnumpy.ndarray or None\nBlock acceleration time series (in m/s^2).\n\n\nblock_vel\nnumpy.ndarray or None\nBlock velocity time series (in m/s).\n\n\nblock_disp\nnumpy.ndarray or None\nBlock displacement time series (in m).\n\n\nsliding_vel\nnumpy.ndarray or None\nSliding velocity time series (in m/s).\n\n\nsliding_disp\nnumpy.ndarray or None\nSliding displacement time series (in m).\n\n\nmax_sliding_disp\nfloat or None\nMaximum sliding displacement (in m).\n\n\n_npts\nint or None\nNumber of points in the input acceleration time series.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nsliding_block_plot\nPlot the analysis result as a 3-by-1 array of time series figures.\n\n\n\n\n\nSlidingBlockAnalysis.sliding_block_plot(sliding_vel_mode=True, fig=None)\nPlot the analysis result as a 3-by-1 array of time series figures.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsliding_vel_mode\nbool\nIf True, the velocity figure shows the sliding (relative) velocity of the block. If False, it shows the absolute velocities of the input motion and the block. Default is True.\nTrue\n\n\nfig\nmatplotlib.figure.Figure\nExisting figure to plot on. If None, a new figure is created. Default is None.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nmatplotlib.figure.Figure\nThe figure containing the plots.",
    "crumbs": [
      "API Reference",
      "SlidingBlockAnalysis"
    ]
  },
  {
    "objectID": "api/SlidingBlockAnalysis.html#parameters",
    "href": "api/SlidingBlockAnalysis.html#parameters",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nky\nfloat\nYield acceleration of the sliding block (in g).\nrequired\n\n\na_in\nnumpy.ndarray\nInput acceleration time series (in m/s^2).\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration time series (in seconds).\nrequired\n\n\nscale_factor\nfloat\nScaling factor for the input acceleration. Default is 1.0.\n1.0\n\n\ntarget_pga\nfloat\nTarget peak ground acceleration (in m/s^2). If provided, the input acceleration will be scaled to match this value. Cannot be used with scale_factor.\nNone",
    "crumbs": [
      "API Reference",
      "SlidingBlockAnalysis"
    ]
  },
  {
    "objectID": "api/SlidingBlockAnalysis.html#raises",
    "href": "api/SlidingBlockAnalysis.html#raises",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf both target_pga and scale_factor are provided.",
    "crumbs": [
      "API Reference",
      "SlidingBlockAnalysis"
    ]
  },
  {
    "objectID": "api/SlidingBlockAnalysis.html#attributes",
    "href": "api/SlidingBlockAnalysis.html#attributes",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nscale_factor\nfloat\nScaling factor applied to the input acceleration.\n\n\na_in\nnumpy.ndarray\nScaled input acceleration time series.\n\n\nmethod\nstr or None\nAnalysis method used (to be defined in subclasses).\n\n\nky\nfloat or None\nYield acceleration of the sliding block (in g).\n\n\ntime\nnumpy.ndarray or None\nTime array corresponding to the input acceleration.\n\n\nground_acc\nnumpy.ndarray or None\nGround acceleration time series (in m/s^2).\n\n\nground_vel\nnumpy.ndarray or None\nGround velocity time series (in m/s).\n\n\nground_disp\nnumpy.ndarray or None\nGround displacement time series (in m).\n\n\nblock_acc\nnumpy.ndarray or None\nBlock acceleration time series (in m/s^2).\n\n\nblock_vel\nnumpy.ndarray or None\nBlock velocity time series (in m/s).\n\n\nblock_disp\nnumpy.ndarray or None\nBlock displacement time series (in m).\n\n\nsliding_vel\nnumpy.ndarray or None\nSliding velocity time series (in m/s).\n\n\nsliding_disp\nnumpy.ndarray or None\nSliding displacement time series (in m).\n\n\nmax_sliding_disp\nfloat or None\nMaximum sliding displacement (in m).\n\n\n_npts\nint or None\nNumber of points in the input acceleration time series.",
    "crumbs": [
      "API Reference",
      "SlidingBlockAnalysis"
    ]
  },
  {
    "objectID": "api/SlidingBlockAnalysis.html#methods",
    "href": "api/SlidingBlockAnalysis.html#methods",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsliding_block_plot\nPlot the analysis result as a 3-by-1 array of time series figures.\n\n\n\n\n\nSlidingBlockAnalysis.sliding_block_plot(sliding_vel_mode=True, fig=None)\nPlot the analysis result as a 3-by-1 array of time series figures.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsliding_vel_mode\nbool\nIf True, the velocity figure shows the sliding (relative) velocity of the block. If False, it shows the absolute velocities of the input motion and the block. Default is True.\nTrue\n\n\nfig\nmatplotlib.figure.Figure\nExisting figure to plot on. If None, a new figure is created. Default is None.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nmatplotlib.figure.Figure\nThe figure containing the plots.",
    "crumbs": [
      "API Reference",
      "SlidingBlockAnalysis"
    ]
  },
  {
    "objectID": "api/RigidAnalysis.html",
    "href": "api/RigidAnalysis.html",
    "title": "RigidAnalysis",
    "section": "",
    "text": "RigidAnalysis(\n    self,\n    ky,\n    a_in,\n    dt,\n    scale_factor=1.0,\n    target_pga=None,\n    method='jibson',\n)\nRigid Block Analysis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nky\nfloat\nCritical acceleration (in g).\nrequired\n\n\na_in\nlist\nGround acceleration time series (in g).\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration time series (in seconds).\nrequired\n\n\nscale_factor\nfloat\nScaling factor for the input acceleration. Default is 1.0.\n1.0\n\n\ntarget_pga\nfloat\nTarget peak ground acceleration (in m/s^2). If provided, the input acceleration will be scaled to match this value. Cannot be used with scale_factor.\nNone\n\n\nmethod\nstr\nAnalysis method. Options are ‘jibson’, ‘dgr’, or ‘gra’. Default is ‘jibson’.\n'jibson'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf both target_pga and scale_factor are provided.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nanalysis_methods\ndict\nDictionary mapping method names to their corresponding functions.\n\n\nground_acc\nnumpy.ndarray\nGround acceleration time series (in m/s^2).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\njibson\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\n\n\n\nRigidAnalysis.jibson()\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\nThis method iteratively calculates the block’s acceleration, velocity, and displacement based on the input ground acceleration and critical acceleration.",
    "crumbs": [
      "API Reference",
      "RigidAnalysis"
    ]
  },
  {
    "objectID": "api/RigidAnalysis.html#parameters",
    "href": "api/RigidAnalysis.html#parameters",
    "title": "RigidAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nky\nfloat\nCritical acceleration (in g).\nrequired\n\n\na_in\nlist\nGround acceleration time series (in g).\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration time series (in seconds).\nrequired\n\n\nscale_factor\nfloat\nScaling factor for the input acceleration. Default is 1.0.\n1.0\n\n\ntarget_pga\nfloat\nTarget peak ground acceleration (in m/s^2). If provided, the input acceleration will be scaled to match this value. Cannot be used with scale_factor.\nNone\n\n\nmethod\nstr\nAnalysis method. Options are ‘jibson’, ‘dgr’, or ‘gra’. Default is ‘jibson’.\n'jibson'",
    "crumbs": [
      "API Reference",
      "RigidAnalysis"
    ]
  },
  {
    "objectID": "api/RigidAnalysis.html#raises",
    "href": "api/RigidAnalysis.html#raises",
    "title": "RigidAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf both target_pga and scale_factor are provided.",
    "crumbs": [
      "API Reference",
      "RigidAnalysis"
    ]
  },
  {
    "objectID": "api/RigidAnalysis.html#attributes",
    "href": "api/RigidAnalysis.html#attributes",
    "title": "RigidAnalysis",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nanalysis_methods\ndict\nDictionary mapping method names to their corresponding functions.\n\n\nground_acc\nnumpy.ndarray\nGround acceleration time series (in m/s^2).",
    "crumbs": [
      "API Reference",
      "RigidAnalysis"
    ]
  },
  {
    "objectID": "api/RigidAnalysis.html#methods",
    "href": "api/RigidAnalysis.html#methods",
    "title": "RigidAnalysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\njibson\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\n\n\n\nRigidAnalysis.jibson()\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\nThis method iteratively calculates the block’s acceleration, velocity, and displacement based on the input ground acceleration and critical acceleration.",
    "crumbs": [
      "API Reference",
      "RigidAnalysis"
    ]
  },
  {
    "objectID": "examples/batch_simulations.html",
    "href": "examples/batch_simulations.html",
    "title": "Batch Simulations",
    "section": "",
    "text": "This notebook shows an example use case of pyslammer for running batch simulations.",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "examples/batch_simulations.html#setup",
    "href": "examples/batch_simulations.html#setup",
    "title": "Batch Simulations",
    "section": "Setup",
    "text": "Setup\nThe next steps assume you’ve already installed pySLAMMER from PYPI. See the quickstart guide for installation instructions.\nImport pyslammer using:\n\nimport pyslammer as slam\n\nAdditional Python libraries, such as matplotlib may also be useful.\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.style.use(slam.psfigstyle)\n\n\nkys = np.linspace(0.01,0.7,100)\nhistories = slam.sample_ground_motions()\noutput = {}",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "examples/batch_simulations.html#comparing-multiple-motions",
    "href": "examples/batch_simulations.html#comparing-multiple-motions",
    "title": "Batch Simulations",
    "section": "Comparing multiple motions",
    "text": "Comparing multiple motions\nThe results of the analyses can be plotted to show trends in total accumulated displacement with \\(k_y\\) for each ground motion in the sample ground motion suite.\n\nplt.close('all')\nfig, ax = plt.subplots()  \nfor key, grp in df.groupby(['motion']):\n    ax.scatter(grp[\"ky\"]/grp[\"k_max\"], grp[\"d_max\"], label=key[0], alpha=0.5)\nax.legend(loc='upper left', bbox_to_anchor=(1, 1))\nax.set_xlim(0,1)\nax.set_yscale('log')\nax.set_ylim(1e-3,1e1)\nax.set_xlabel('$k_y / k_{max}$')\nax.set_ylabel('Maximum Displacement (m)')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure 1: Variation in final displacement with \\(k_y\\) for the sample ground motion suite.",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "examples/batch_simulations.html#variation-in-a-single-motions-time-history",
    "href": "examples/batch_simulations.html#variation-in-a-single-motions-time-history",
    "title": "Batch Simulations",
    "section": "Variation in a single motion’s time history",
    "text": "Variation in a single motion’s time history\nAlternatively, for any given motion, the displacement time histories for different values of \\(k_y\\) could be of interest. In Figure 2, the results from all the simulations with the Imperial_Valley_1979_BCR-230 motion are shown. Although a different dimension of the data are being shown, the figure is simply pulling from the the results dataframe used in Figure 1.\n\n\nCode\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LogNorm\n\nmotion = \"Imperial_Valley_1979_BCR-230\"\n\nplt.close('all')\n\n# Create a figure and axes\nfig, ax = plt.subplots(figsize=(6, 4))\n\n# Create a color map\ncmap = plt.colormaps['Spectral']#cm.get_cmap('viridis')\nnorm = LogNorm(df['ky'].min(), df['ky'].max())\n\ndt = df[df[\"motion\"]==motion].iloc[0]['dt']\nnpts = df[df[\"motion\"]==motion].iloc[0]['disp'].shape[0]\ntime = np.linspace(0, dt*npts, npts)\n\nfor index, row in df[df[\"motion\"]==motion].iterrows():\n    color = cmap(norm(row['ky']))\n    ax.plot(time, row['disp'], color=color)\n\n# Add a color bar\nsm = cm.ScalarMappable(cmap=cmap, norm=norm)\nsm.set_array([])\ncbar = fig.colorbar(sm, ax=ax, label='ky')\n\n# Set the colorbar ticks and labels\nticks = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]\ncbar.set_ticks(ticks)\ncbar.set_ticklabels([f'{tick:.2f}' for tick in ticks]) \n\n# Set the x-axis and y-axis labels\nax.set_xlabel('Time')\nax.set_ylabel('Displacement')\nax.set_title(motion)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Variation in cumulative displacement with \\(k_y\\) for the Imperial Valley motion.",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pySLAMMER",
    "section": "",
    "text": "pySLAMMER (Python package for Seismic Landslide Movement Modeled using Earthquake Records) is tool for estimating the co-seismic displacements of landslides with rigid and flexible sliding-block analyses. The package name and code are based on the USGS tool SLAMMER by Jibson et al. (2013).\npySLAMMER includes the same sliding block analysis methods as SLAMMER:",
    "crumbs": [
      "Quickstart guide",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#site-contents",
    "href": "index.html#site-contents",
    "title": "pySLAMMER",
    "section": "Site Contents",
    "text": "Site Contents",
    "crumbs": [
      "Quickstart guide",
      "Welcome"
    ]
  },
  {
    "objectID": "about/roadmap.html",
    "href": "about/roadmap.html",
    "title": "Roadmap",
    "section": "",
    "text": "Note\n\n\n\nThis page is a stub and will be updated soon.\n\n\nWhere are we taking pySLAMMER?\n\ncomprehensive unit tests\nSpeed improvements\nMemory improvements\nAdditional models\nWeb app",
    "crumbs": [
      "Quickstart guide",
      "About",
      "Roadmap"
    ]
  },
  {
    "objectID": "about/motivation.html",
    "href": "about/motivation.html",
    "title": "Motivation",
    "section": "",
    "text": "Note\n\n\n\nThis page is a stub and will be updated soon.\n\n\nWhy did we make pySLAMMER?\n\nSliding block analyses are common\nThe code used isn’t always transparent\nSLAMMER is clunky\nThere are a lot of additions to traditional sliding block analyses that have been introduced here and there, but they’re not all in one place.\nReduced duplication of effort\nMore eyes looking for errors",
    "crumbs": [
      "About",
      "Motivation"
    ]
  },
  {
    "objectID": "about/develop.html",
    "href": "about/develop.html",
    "title": "Develop",
    "section": "",
    "text": "Thank you for your interest in contributing to pySLAMMER! We welcome contributions from the community to improve and expand the package.\n\n\n\nClone the Repository:\ngit clone https://github.com/lornearnold/pyslammer.git\ncd pyslammer\nInstall Dependencies: Ensure you have Python installed (preferably version 3.8 or higher). Install the required dependencies:\npip install -r requirements.txt\nSet Up a Development Environment: Optionally, create a virtual environment to isolate your development setup:\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\n\n\n\n\n\nCreate a New Branch: Always create a new branch for your changes:\ngit checkout -b feature/your-feature-name\nFollow Coding Standards:\n\nWrite clean, readable, and well-documented code.\nFollow PEP 8 guidelines for Python code.\n\nAdd Tests: Ensure your changes are covered by tests. Add new tests in the tests/ directory if necessary.\n\n\n\n\n\n\n\nWarning\n\n\n\nThe base tests for pySLAMMER are still being developed.\n\n\n\n\n\nRun the test suite to ensure everything works as expected:\npytest tests/\n\n\n\n\nCommit Your Changes: Write clear and concise commit messages:\ngit add .\ngit commit -m \"Add a brief description of your changes\"\nPush Your Branch:\ngit push origin feature/your-feature-name\nCreate a Pull Request: Go to the GitHub repository and create a pull request. Provide a detailed description of your changes.\n\n\n\n\n\nBe respectful and collaborative.\nEnsure your code passes all tests and adheres to the coding standards.\nProvide clear documentation for any new features or changes.\n\nThank you for contributing to pySLAMMER!",
    "crumbs": [
      "About",
      "Develop"
    ]
  },
  {
    "objectID": "about/develop.html#contributing-to-pyslammer",
    "href": "about/develop.html#contributing-to-pyslammer",
    "title": "Develop",
    "section": "",
    "text": "Thank you for your interest in contributing to pySLAMMER! We welcome contributions from the community to improve and expand the package.\n\n\n\nClone the Repository:\ngit clone https://github.com/lornearnold/pyslammer.git\ncd pyslammer\nInstall Dependencies: Ensure you have Python installed (preferably version 3.8 or higher). Install the required dependencies:\npip install -r requirements.txt\nSet Up a Development Environment: Optionally, create a virtual environment to isolate your development setup:\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\n\n\n\n\n\nCreate a New Branch: Always create a new branch for your changes:\ngit checkout -b feature/your-feature-name\nFollow Coding Standards:\n\nWrite clean, readable, and well-documented code.\nFollow PEP 8 guidelines for Python code.\n\nAdd Tests: Ensure your changes are covered by tests. Add new tests in the tests/ directory if necessary.\n\n\n\n\n\n\n\nWarning\n\n\n\nThe base tests for pySLAMMER are still being developed.\n\n\n\n\n\nRun the test suite to ensure everything works as expected:\npytest tests/\n\n\n\n\nCommit Your Changes: Write clear and concise commit messages:\ngit add .\ngit commit -m \"Add a brief description of your changes\"\nPush Your Branch:\ngit push origin feature/your-feature-name\nCreate a Pull Request: Go to the GitHub repository and create a pull request. Provide a detailed description of your changes.\n\n\n\n\n\nBe respectful and collaborative.\nEnsure your code passes all tests and adheres to the coding standards.\nProvide clear documentation for any new features or changes.\n\nThank you for contributing to pySLAMMER!",
    "crumbs": [
      "About",
      "Develop"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "Running Rigid, Decoupled, and Coupled analyses\nBatch simulations",
    "crumbs": [
      "Quickstart guide",
      "Examples"
    ]
  },
  {
    "objectID": "examples/rigid_flex.html",
    "href": "examples/rigid_flex.html",
    "title": "Rigid and Flexible Anlysis",
    "section": "",
    "text": "This notebook shows an example use case of pyslammer for running rigid, decoupled, and coupled sliding block analyses.\nThe next steps assume you’ve already installed pySLAMMER from PYPI. See the quickstart guide for installation instructions.\nFirst, import pySLAMMER and a couple other helpful packages\nimport pyslammer as slam\nimport numpy as np\nimport matplotlib.pyplot as plt\nNext define the ground motion to use in the analysis. For this example, we will use one of pySLAMMER’s built in ground motions from the 1995 Kobe earthquake. This creates a ground motion object with accel and dt attributes with the acceleration array and timestep, respectively.\nrecord_name = \"Kobe_1995_TAK-090\"\ngm = slam.sample_ground_motions()[record_name]",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "examples/rigid_flex.html#rigid-block-analysis",
    "href": "examples/rigid_flex.html#rigid-block-analysis",
    "title": "Rigid and Flexible Anlysis",
    "section": "Rigid block analysis",
    "text": "Rigid block analysis\nA rigid block analysis requires at least three input parameters:\n\na_in - the input acceleration time history (in units of g)\ndt - the timestep separating the acceleration data points\nky - the slope’s yield acceleration (in units of g)\n\nThese parameters are stored in a dictionary (rigid_inputs) and used as kwarg input to the RigidAnalysis method.\n\nrigid_inputs = {\n    \"a_in\": gm.accel,\n    \"dt\": gm.dt,\n    \"ky\": 0.2\n}\n\nrigid_result = slam.RigidAnalysis(**rigid_inputs, scale_factor=2)\n\n\n\n\n\n\n\nNote\n\n\n\nPassing the input variables to slam.RigidAnalysis as a dictionary isn’t necessary, it’s just a convenient way to package groups of input variables. The following line would have produced the same result as the previous cell:\nrigid_result = slam.RigidAnalysis(gm.accel, gm.dt, 0.2)",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "examples/rigid_flex.html#flexible-sliding-block-analysis",
    "href": "examples/rigid_flex.html#flexible-sliding-block-analysis",
    "title": "Rigid and Flexible Anlysis",
    "section": "Flexible sliding block analysis",
    "text": "Flexible sliding block analysis\nThe flexible block analyses (decoupled and coupled) require additional input parameters to define the stiffness of the model:\n\nheight - the slope height (in meters, by default)\nvs_slope - the slope shear wave velocity (in meters per second, by default)\nvs_base - the base shear wave velocity (in meters per second, by default)\ndamp_ratio - the slope damping ratio\nref_strain - the slope reference strain\nsoil_model - the dynamic analysis method used (either linear_elastic or equivalent_linear)\n\nThese parameters are stored in a dictionary (flexible_inputs) and used as kwargs along with those used in the rigid analysis. The decoupled and coupled analyses are run with the Decoupled and Coupled methods, respectively.\n\nflexible_inputs = {\n    \"height\": 50.0,\n    \"vs_slope\": 600.0,\n    \"vs_base\": 600.0,\n    \"damp_ratio\": 0.05,\n    \"ref_strain\": 0.0005,\n    \"soil_model\": \"equivalent_linear\"\n}\n\ndecoupled_result = slam.Decoupled(**rigid_inputs,**flexible_inputs)\ndecoupled_result._compile_attributes()\ncoupled_result = slam.Coupled(**rigid_inputs,**flexible_inputs)\ncoupled_result._compile_attributes()",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "examples/rigid_flex.html#comparison-of-analysis-methods",
    "href": "examples/rigid_flex.html#comparison-of-analysis-methods",
    "title": "Rigid and Flexible Anlysis",
    "section": "Comparison of analysis methods",
    "text": "Comparison of analysis methods\nA simple plot comparing the block displacements with time can be generated by accessing the .sliding_disp attribute of each analysis result.\n\nplt.figure(figsize=(10, 6))\n\ntime = np.arange(0, len(gm.accel) * gm.dt, gm.dt)\n\n# Plot block displacement vs time for each analysis method\nplt.plot(time, rigid_result.sliding_disp, label='Rigid Analysis')\nplt.plot(time, decoupled_result.sliding_disp, label='Decoupled Analysis')\nplt.plot(time, coupled_result.sliding_disp, label='Coupled Analysis')\n\n# Add labels and legend\nplt.xlabel('Time (s)')\nplt.ylabel('Block Displacement (m)')\nplt.title(f'Block Displacement with Different Analysis Methods\\n for {record_name}')\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nOr each analysis can be plotted on its own using the sliding_block_plot method (inherited from the parent SlidingBlockAnalysis class).\n\nrigid_fig = rigid_result.sliding_block_plot()\ndecoupled_fig = decoupled_result.sliding_block_plot()\ncoupled_fig = coupled_result.sliding_block_plot()",
    "crumbs": [
      "Quickstart guide",
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "api/Coupled.html",
    "href": "api/Coupled.html",
    "title": "Coupled",
    "section": "",
    "text": "Coupled(\n    self,\n    ky,\n    a_in,\n    dt,\n    height,\n    vs_slope,\n    vs_base,\n    damp_ratio,\n    ref_strain,\n    scale_factor=1,\n    target_pga=None,\n    soil_model='linear_elastic',\n    si_units=True,\n    lite=False,\n)\nCoupled analysis for sliding block and ground motion interaction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nky\nfloat or tuple[list[float], list[float]] or tuple[np.ndarray, np.ndarray] or callable\nYield acceleration or function defining yield acceleration.\nrequired\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration.\nrequired\n\n\nheight\nint or float\nHeight of the sliding block.\nrequired\n\n\nvs_slope\nint or float\nShear wave velocity slope.\nrequired\n\n\nvs_base\nint or float\nBase shear wave velocity.\nrequired\n\n\ndamp_ratio\nfloat\nDamping ratio.\nrequired\n\n\nref_strain\nfloat\nReference strain.\nrequired\n\n\nscale_factor\nfloat\nScale factor for input acceleration, by default 1.\n1\n\n\nsoil_model\nstr\nSoil model type, by default “linear_elastic”.\n'linear_elastic'\n\n\nsi_units\nbool\nUse SI units, by default True.\nTrue\n\n\nlite\nbool\nLite mode, by default False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nHEA\nnp.ndarray\nHorizontal equivalent acceleration time history from dynamic response.\n\n\ngamma\nfloat\nIntegration parameter gamma.\n\n\nblock_acc\nnp.ndarray\nBlock acceleration time history.\n\n\nground_acc\nnp.ndarray\nGround acceleration time history.\n\n\nmax_sliding_disp\nfloat\nMaximum sliding displacement.",
    "crumbs": [
      "API Reference",
      "Coupled"
    ]
  },
  {
    "objectID": "api/Coupled.html#parameters",
    "href": "api/Coupled.html#parameters",
    "title": "Coupled",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nky\nfloat or tuple[list[float], list[float]] or tuple[np.ndarray, np.ndarray] or callable\nYield acceleration or function defining yield acceleration.\nrequired\n\n\na_in\nlist[float] or np.ndarray\nInput acceleration time history.\nrequired\n\n\ndt\nfloat\nTime step of the input acceleration.\nrequired\n\n\nheight\nint or float\nHeight of the sliding block.\nrequired\n\n\nvs_slope\nint or float\nShear wave velocity slope.\nrequired\n\n\nvs_base\nint or float\nBase shear wave velocity.\nrequired\n\n\ndamp_ratio\nfloat\nDamping ratio.\nrequired\n\n\nref_strain\nfloat\nReference strain.\nrequired\n\n\nscale_factor\nfloat\nScale factor for input acceleration, by default 1.\n1\n\n\nsoil_model\nstr\nSoil model type, by default “linear_elastic”.\n'linear_elastic'\n\n\nsi_units\nbool\nUse SI units, by default True.\nTrue\n\n\nlite\nbool\nLite mode, by default False.\nFalse",
    "crumbs": [
      "API Reference",
      "Coupled"
    ]
  },
  {
    "objectID": "api/Coupled.html#attributes",
    "href": "api/Coupled.html#attributes",
    "title": "Coupled",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nHEA\nnp.ndarray\nHorizontal equivalent acceleration time history from dynamic response.\n\n\ngamma\nfloat\nIntegration parameter gamma.\n\n\nblock_acc\nnp.ndarray\nBlock acceleration time history.\n\n\nground_acc\nnp.ndarray\nGround acceleration time history.\n\n\nmax_sliding_disp\nfloat\nMaximum sliding displacement.",
    "crumbs": [
      "API Reference",
      "Coupled"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "API reference for pySLAMMER\n\n\n\nSlidingBlockAnalysis\nBase class for all time-domain sliding block analyses. SlidingBlockAnalysis does not\n\n\nRigidAnalysis\nRigid Block Analysis.\n\n\nDecoupled\nDecoupled analysis for sliding block and ground motion interaction.\n\n\nCoupled\nCoupled analysis for sliding block and ground motion interaction.\n\n\nGroundMotion\nGround Motion Record.\n\n\nsample_ground_motions\nLoad sample ground motions from the sample_ground_motions folder.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#api-reference",
    "href": "api/index.html#api-reference",
    "title": "Function reference",
    "section": "",
    "text": "API reference for pySLAMMER\n\n\n\nSlidingBlockAnalysis\nBase class for all time-domain sliding block analyses. SlidingBlockAnalysis does not\n\n\nRigidAnalysis\nRigid Block Analysis.\n\n\nDecoupled\nDecoupled analysis for sliding block and ground motion interaction.\n\n\nCoupled\nCoupled analysis for sliding block and ground motion interaction.\n\n\nGroundMotion\nGround Motion Record.\n\n\nsample_ground_motions\nLoad sample ground motions from the sample_ground_motions folder.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/sample_ground_motions.html",
    "href": "api/sample_ground_motions.html",
    "title": "sample_ground_motions",
    "section": "",
    "text": "sample_ground_motions()\nLoad sample ground motions from the sample_ground_motions folder.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nA dictionary where keys are motion names (str) and values are GroundMotion objects containing the time history data and metadata.\n\n\n\n\n\n\nThis function reads all CSV files in the sample_ground_motions folder and creates GroundMotion objects for each file. The file name (without extension) is used as the key in the returned dictionary.",
    "crumbs": [
      "API Reference",
      "sample_ground_motions"
    ]
  },
  {
    "objectID": "api/sample_ground_motions.html#returns",
    "href": "api/sample_ground_motions.html#returns",
    "title": "sample_ground_motions",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ndict\nA dictionary where keys are motion names (str) and values are GroundMotion objects containing the time history data and metadata.",
    "crumbs": [
      "API Reference",
      "sample_ground_motions"
    ]
  },
  {
    "objectID": "api/sample_ground_motions.html#notes",
    "href": "api/sample_ground_motions.html#notes",
    "title": "sample_ground_motions",
    "section": "",
    "text": "This function reads all CSV files in the sample_ground_motions folder and creates GroundMotion objects for each file. The file name (without extension) is used as the key in the returned dictionary.",
    "crumbs": [
      "API Reference",
      "sample_ground_motions"
    ]
  },
  {
    "objectID": "quickstart.html",
    "href": "quickstart.html",
    "title": "Quickstart guide",
    "section": "",
    "text": "The pyslammer package is built on Python 3.12. Earlier versions of Python 3 may work, but have not been tested."
  },
  {
    "objectID": "quickstart.html#requirements",
    "href": "quickstart.html#requirements",
    "title": "Quickstart guide",
    "section": "",
    "text": "The pyslammer package is built on Python 3.12. Earlier versions of Python 3 may work, but have not been tested."
  },
  {
    "objectID": "quickstart.html#installation-using-pip",
    "href": "quickstart.html#installation-using-pip",
    "title": "Quickstart guide",
    "section": "Installation using pip",
    "text": "Installation using pip\n \nInstall pyslammer using pip from the Python Package Index (PyPI):\npip install pyslammer"
  },
  {
    "objectID": "quickstart.html#basic-usage",
    "href": "quickstart.html#basic-usage",
    "title": "Quickstart guide",
    "section": "Basic Usage",
    "text": "Basic Usage\nWith pyslammer installed, basic usage involves the following steps: 1. Import the pyslammer module 2. Import a ground motion 3. Perform a rigid sliding block analysis 4. View results\n\nImport the pyslammer module\nThe recommended ailas for pyslammer is slam:\n\nimport pyslammer as slam \n\nThis allows use of pyslammer features within your code with the short prefix slam.\nThe primary object type within pyslammer is the SlidingBlockAnalysis object. At a minimum any SlidingBlockAnalysis requires a yield acceleration for the slope (\\(k_y\\)) and an input ground motion. As basic example, consider a rigid sliding block analysis on a slope with a yield acceleration of \\(0.2\\) g.\n\n\nImport a ground motion\nA small number of sample ground motion records are included with pyslammer. We will use one of the sample ground motion records, but we expect most users will import their ground motions from external sources. To use any signal for a ground motion, pyslammer needs a 1-D array of acceleration in units of \\(g\\) and the signal timestep (in seconds). See The available sample ground motions can be viewed with:\n\nmotions = slam.sample_ground_motions() # Load all sample ground motions\nfor motion in motions:\n    print(motion)\n\nMorgan_Hill_1984_CYC-285\nNisqually_2001_UNR-058\nImperial_Valley_1979_BCR-230\nNorthridge_1994_PAC-175\nChi-Chi_1999_TCU068-090\nCape_Mendocino_1992_PET-090\nCoalinga_1983_PVB-045\nMammoth_Lakes-2_1980_CVK-090\nKocaeli_1999_ATS-090\nNahanni_1985_NS1-280\nMammoth_Lakes-1_1980_CVK-090\nDuzce_1999_375-090\nLoma_Prieta_1989_HSP-000\nLanders_1992_LCN-345\nN_Palm_Springs_1986_WWT-180\nKobe_1995_TAK-090\nCoyote_Lake_1979_G02-050\nNorthridge_1994_VSP-360\n\n\nFor this example, we will use theImperial_Valley_1979_BCR-230 motion.\n\ngm = motions[\"Imperial_Valley_1979_BCR-230\"]\n\nThe timestep and acceleration signal for the imported ground motion are gm.dt and gm.accel, respectively.\n\n\nPerform a rigid sliding block analysis\nWith the imported ground motion, gm, and the assumed value of \\(k_y\\), we can perform a rigid sliding block analysis with pySLAMMER’s RigidAnalysis object. This simultaneously creates an instance of RigidAnalysis and performs the analysis, which is stored as result. The inputs for RigidAnalysis are the input acceleration signal, time step, and the yield acceleration.\nA note admonition! Not for anyting in particular, though...\n\nky = 0.2 # yield acceleration in g\nresult = slam.RigidAnalysis(ky, gm.accel, gm.dt)\n\n\n\nView results\nThe primary output of the sliding block analysis is the final displacement (SlidingBlockAnalysis.max_sliding_disp). By default, all lengths in pySLAMMER are in meters. The cell below shows the displacement induced by the sample ground motion in the example:\n\nprint(f\"Slope yield acc: {ky:.2f} g \\nGround motion: {gm.name}; PGA: {gm.pga:.2f} g \\nSliding displacement: {result.max_sliding_disp:.3f} m\")\n\nSlope yield acc: 0.20 g \nGround motion: Imperial_Valley_1979_BCR-230; PGA: 0.77 g \nSliding displacement: 0.213 m\n\n\nA built-in plotting function presents an at-a-glance picture of the analysis result in terms of the input motion and block accelerations, sliding velocity, and sliding displacement:\n\nfig = result.sliding_block_plot()\n\n\n\n\nRigid sliding block analysis results\n\n\n\n\nIn addition to the final displacement, the displacement, velocity, and acceleration time histories of the block are returned as numpy arrays. See the documentation for the SlidingBlockAnalysis class for a detailed description of all the results."
  },
  {
    "objectID": "technical/verification.html",
    "href": "technical/verification.html",
    "title": "Verifications",
    "section": "",
    "text": "The following sections compare pySLAMMER’s results to the legacy SLAMMER program results for a suite of recorded ground motions as well as analytical results for harmonic ground motions. For equivalent linear options for coupled analysis, the computational performance of pySLAMMER and SLAMMER are also compared.\n\nComparison of pySLAMMER’s results to SLAMMER’s\nComparison of pySLAMMER’s speed to SLAMMER’s\nComparison of pySLAMMER’s results to an analytical solution",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html",
    "href": "technical/comp_SLAMMER_results.html",
    "title": "Results comparison to SLAMMER",
    "section": "",
    "text": "PySLAMMER’s rigid, decoupled, and coupled analysis methods are intended to produce sliding block analysis results that match the legacy SLAMMER results. This is an important feature for sliding block displacements, which are used as a performance index (as opposed to providing a direct prediction of actual slope displacement) in practice. Equivalence with legacy results allows new results to be interpreted with reference to historical analyses and experience.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html#approach",
    "href": "technical/comp_SLAMMER_results.html#approach",
    "title": "Results comparison to SLAMMER",
    "section": "Approach",
    "text": "Approach\nTo demonstrate pySLAMMER’s equivalence to SLAMMER, we performed several sliding block analyses across a broad parametric space. The three main categories of parameters studied were ground motion, analysis method, and analysis options.\n\nGround motion\nWe used the motions from pySLAMMER’s built-in sample ground motion suite at several scales to capture a reasonable breadth of the familiar key engineering ground motion characteristics (frequency, amplitude, and duration). The acceleration response spectra for the input motion suite are shown in Figure 1. Additional details on the ground motions are provided on the ground motion suite page.\n\n\nCode\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\nfolder_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"pySLAMMER_suite_resp\"\ncsv_files = list(folder_path.glob(\"*.csv\"))\n\n# Read each CSV file into a DataFrame and store them in a list\nfreq_index = 0\nresp_index = 1\nspectra = {}\nfor csv_file in csv_files:\n    data = np.loadtxt(csv_file, delimiter=\",\", skiprows=2)\n    # convert response from cm/s^2 to g's\n    data[:, resp_index] = data[:, resp_index] / 981\n    spectra[csv_file.name.strip(\".csv\")] = data\n\n# Initialize the plot\nfig, ax = plt.subplots()\nax.set_prop_cycle(cycler(color=plt.cm.tab20.colors))\nfor motion in spectra:\n    ax.plot(\n        1/spectra[motion][:, freq_index],\n        spectra[motion][:, resp_index],\n        label=motion,\n        linewidth=0.5,\n    )\n\nax.text(0.012, 2.75, \"5% damping\")\n# Add labels, legend, and grid\nax.set_xlabel(\"Period (s)\")\nax.set_ylabel(\"Spectral Acceleration (g)\")\nax.set_title(\"Response Spectra\")\nax.set_xscale(\"log\")\nax.set_ylim(0,3)\nax.set_xlim(0.01,100)\n\nax.legend(\n    loc=\"center left\", \n    bbox_to_anchor=(0.6, 0.6), \n    fontsize=\"x-small\", \n    title=\"Ground Motion\", \n    title_fontsize=\"medium\",\n    frameon=False\n)\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Acceleration response spectra for input ground motions\n\n\n\n\n\n\n\nAnalysis methods\nThe three rigorous analysis methods that SLAMMER performs are the Rigid, Decoupled, and Coupled methods. Each of these methods, which are briefly described below, are implemented in pySLAMMER and included in this comparison.\n\nRigid Block Analysis\n\nConceptualized by Whitman in 1963 and further developed by Newmark in 1965 (Marcuson (1994), Newmark (1965)), rigid block analysis models a potential landslide mass as a rigid mass on an inclined plane base with a perfectly plastic frictional interface. The rigid block motion matches the base motion exactly until the acceleration of the base exceeds some critical value (the yield acceleration, \\(k_y\\)). Once this critical \\(k_y\\) value is reached, the block’s acceleration remains constant \\(k_y\\), resulting in relative velocity and displacement between block and base. The relative velocity is calculated by integrating the difference between the block and base accelerations. The displacement accumulated by the block moving down the ramp is calculated by integrating the relative velocity. Sliding stops (i.e., block motion again matches base motion exactly) when the relative velocity reaches zero.\n\nDecoupled Analysis\n\nLandslide materials are, of course, not rigid. Except for very shallow, stiff slide masses, the rigid block model does a poor job of approximating the dynamics of a co-seismic landslide system. The decoupled method was developed to provide some way of accounting for the deformation of the slope mass due to shaking (Seed and Martin (1966), Makdisi and Seed (1978)) . It consists of two distinct (or decoupled, if you will) calculations: dynamic response and rigid sliding. During the dynamic response phase, the possibility of sliding is ignored while the slope response to strong ground motion is calculated. The average internal acceleration of the slope mass during this first phase is then used as the base input acceleration for the second phase (rigid sliding) which is simply a rigid block analysis.\n\nCoupled Analysis\n\nAs indicated by the name, coupled analysis takes the two separate calculations from the decoupled analysis and performs them simultaneously. Chopra and Zhang (1991) introduced a model for earthquake-induced sliding of concrete gravity dams that considered the dynamic response of the dam during sliding. Rathje and Bray (1999) modified the procedure and applied it to earth structures. With coupled sliding, the sliding mass’s dynamic response is calculated for both sliding and non-sliding conditions. Sliding stops when the relative velocity of the sliding mass reaches zero. The stop of sliding can introduce an abrupt change in acceleration applied to the sliding mass. Because the dynamic response is being calculated continually through the analysis, the approach to identifying the timing of these abrupt changes will affect potential subsequent sliding events.\n\nDynamic Response\n\nThe Decoupled and Coupled methods both require the calculation of the slope’s dynamic response. The two methods for dynamic response in SLAMMER, which have been carried over to pySLAMMER are linear elastic and equivalent linear.\n\n\n\n\nAnalysis options\nSLAMMER allows users to include a constant \\(k_y\\) value or a variable \\(k_y\\) that changes with accumulated sliding displacement. The \\(k_y\\) – displacement relationship is stepwise with a table of paired values. This feature provides a rough means of approximating post-peak residual strength. 1\nThe dynamic response of the system (applicable to decoupled and coupled analyses) is calculated using either linear elastic or equivalent linear assumptions. The minimum input parameters needed for the linear elastic analyses are a damping ration, the slope height, and the shear wave velocity of the material above and below the slip surface. For equivalent linear analysis, a reference strain parameter is also needed. Although not explicitly documented, inspection of the SLAMMER source code uses Darendeli (2001) modulus reduction and damping curves with a curvature coefficient of 1.\nSeparate entries for the shear wave velocity of the material above and below the slip surface (\\(V_s\\) and \\(V_b\\), respectively) are used to introduce an equivalent foundation radiation damping into the viscous material damping as described by Lee (2004). This happens behind the scenes in SLAMMER by default and cannot be turned off. 2\nTable 1 shows the analysis options and ranges of input values used in the group of simulations used to compare pySLAMMER to\n\n\nCode\nkykmax = [0.05, 1.0]\ntmts = [0.1, 10.0]\nheight = [0.1, 100]\nvs =  [200, 1200]\nvsvb =  [0.1, 100]\ndamp =  [5, 25]\nref_str =  [1, 10]\n\nparams = {\n    \"param\": [\n        \"Methods\",\n        \"Dynamic Resp.\",\n        \"ky/kmax\",\n        \"Tm/Tx *\",\n        \"Slope height (m) *\",\n        \"Slope shear wave vel., Vs (m/s) *\",\n        \"Vs/Vb *\",\n        \"Damping (%) *\",\n        \"Reference strain (%) **\"\n    ],\n    \"val\": [\n        \"Rigid, Decoupled, Coupled\",\n        \"Linear elastic, Equivalent linear\",\n        f\"{kykmax[0]} to {kykmax[1]}\",\n        f\"{tmts[0]} to {tmts[1]}\",\n        f\"{height[0]} to {height[1]}\",\n        f\"{vs[0]} to {vs[1]}\",\n        f\"{vsvb[0]} to {vsvb[1]}\",\n        f\"{damp[0]} to {damp[1]}\",\n        f\"{ref_str[0]} to {ref_str[1]}\"\n    ]\n}\n\n# * only applicable to Decoupled and Coupled methods\n# ** only applicable to equivalent linear dynamic response\n\ntbl = (\n    GT(pd.DataFrame(params))\n    .cols_label(\n    param=html(\"Parameter\"),\n    val=html(\"Range / Options used\")\n    )\n    .cols_align(align=\"center\", columns=1)\n    .tab_source_note(\"* Only applies to Decouled and Coupled analyses\") \n    .tab_source_note(\"** Only applies to equivalent linear analyses\")\n)\ntbl\n\n\n\n\nTable 1: Sliding block parameters used for pySLAMMER to SLAMMER comparison analyses.\n\n\n\n\n\n\n\n\n\nParameter\nRange / Options used\n\n\n\n\nMethods\nRigid, Decoupled, Coupled\n\n\nDynamic Resp.\nLinear elastic, Equivalent linear\n\n\nky/kmax\n0.05 to 1.0\n\n\nTm/Tx *\n0.1 to 10.0\n\n\nSlope height (m) *\n0.1 to 100\n\n\nSlope shear wave vel., Vs (m/s) *\n200 to 1200\n\n\nVs/Vb *\n0.1 to 100\n\n\nDamping (%) *\n5 to 25\n\n\nReference strain (%) **\n1 to 10\n\n\n\n* Only applies to Decouled and Coupled analyses\n\n\n** Only applies to equivalent linear analyses",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html#results",
    "href": "technical/comp_SLAMMER_results.html#results",
    "title": "Results comparison to SLAMMER",
    "section": "Results",
    "text": "Results\nThe results of the simulations across the parametric space described in Table 1 show excellent agreement between pySLAMMER and SLAMMER. When viewed at a linear scale, the results seem to show complete agreement (see Figure 2). However, due to minor numerical differences and orders of operations between the two codes, some non-zero numerical differences should be expected.\n\n\nCode\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\ndata_path = Path(current_dir).resolve().parents[1] / \"tests\" / \"SLAMMER_results.xlsx\"\n\ndf = import_verification_data(data_path)\ndf[\"kykmax\"] = df[\"ky (g)\"] / df[\"kmax (g)\"]\n\ndfp = df[df[\"kykmax\"] &lt; 1.0]\n\n############\n# pySLAMMER v. SLAMMER\n############\nfig, ax = plt.subplots()\ncmap = plt.cm.viridis  \n\n# Match color values to kykmax values\ncolor_values = dfp[\"kykmax\"] \n\n# Scatter plot with color mapping\nscatter = ax.scatter(\n    dfp[\"SLAMMER\"],  # x-axis values\n    dfp[\"pySLAMMER\"],  # y-axis values\n    c=color_values,  # Numeric values for coloring\n    cmap=cmap,  # Colormap\n    alpha=0.5,  # Transparency\n    marker=\".\",\n)\n\n# Add colorbar\ncbar = plt.colorbar(scatter, ax=ax, alpha=1)\ncbar.set_label(\"Yield Ratio ($k_y/k_{max}$)\")  # Label for the colorbar\n\n\nax.set_xlim(0, 1000)\nax.set_ylim(0, 1000)\n\nplt.grid()\n\nax.set_xlabel(\"SLAMMER displacement (cm)\")\nax.set_ylabel(\"pySLAMMER displacement (cm)\")\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Linear scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the differences are too small to be distinguished visually.\n\n\n\n\n\nViewed on a log-log scale, the numerical differences become become visible for analyses with sub-centimeter sliding displacements (Figure 3). In practice, sub-centimeter sliding block displacements are not typically considered significant and the error magnitudes present at this scale are beyond the level of precision that sliding block results are interpreted at.\n\n\nCode\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlim(1e-3, 1e3)\nax.set_ylim(1e-3, 1e3)\n\nfig\n\n\n\n\n\n\n\n\nFigure 3: Log-log scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the small differences become visible. Nevertheless, the match between the two is excellent in the range of engineering interest.\n\n\n\n\n\nThe numerical error magnitudes that are visibile in Figure 3 are quantified in Table 2, which summarizes the fit of pySLAMMER to SLAMMER sliding block displacement results over different ranges of predicted displacement. The linear regression parameters in Table 2 show how well a straigt line fit would match the data set over discrete ranges of predicted displacements. Within each displacment range, the 95th percentile error 3 is also reported.\n\n\nCode\nscales = [0.001, 0.01, 0.1, 1, 10, 100 ,1000]\ninterest = [\"no\", \"no\", \"yes\", \"yes\", \"yes\", \"yes\"]\nmatch_quality = [\"moderate\", \"very good\", \"excellent\", \"excellent\", \"excellent\", \"excellent\"]\ncomp = {\n    \"Range\": [],\n    \"Engineering\\nInterest\": [],\n    \"Computation\\nMatch\": [],\n    \"error_95\": [],\n    \"Slope\": [],\n    \"Intercept\": [],\n    \"R_sq\": []\n}\n\nfor i in range(len(scales)-1):\n    segment = dfp[\n        (dfp[\"SLAMMER\"] &gt; scales[i])\n        & (dfp[\"SLAMMER\"] &lt; scales[i+1])\n    ]\n    slope, intercept, r, p, se = ssmstat.linregress(\n        segment[\"SLAMMER\"],\n        segment[\"pySLAMMER\"],\n    )\n    comp[\"Range\"].append(f\"{scales[i]} to {scales[i+1]}\")\n    comp[\"Engineering\\nInterest\"].append(interest[i])\n    comp[\"error_95\"].append(f\"{np.percentile(\n        abs(segment[\"pySLAMMER\"] - segment[\"SLAMMER\"]),\n        95):.2f}\")\n    comp[\"Slope\"].append(f\"{slope:.2f}\")\n    comp[\"Intercept\"].append(f\"{intercept:.2f}\")\n    comp[\"R_sq\"].append(f\"{r**2:.2f}\")\n    comp[\"Computation\\nMatch\"].append(match_quality[i])\n    \n\ntbl = (\n    GT(pd.DataFrame(comp))\n    .tab_spanner(\n    label=\"Linear Regression Parameters\",\n    columns=[\"Slope\",\"Intercept\",\"R_sq\"]\n    )\n    .cols_label(\n    Range=html(\"Displacement Range&lt;br&gt;(cm)\"),\n    Intercept=html(\"Intercept&lt;br&gt;(cm)\"),\n    R_sq=html(\"R&lt;sup&gt;2&lt;/sup&gt;\"),\n    error_95=html(\"95&lt;sup&gt;th&lt;/sup&gt; percentile error&lt;br&gt;(cm)\")\n\n    )\n)\ntbl\n\n\n\n\nTable 2: Comparison of pySLAMMER-SLAMMER results agreement by order of displacement magnitude.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisplacement Range\n(cm)\nEngineering Interest\nComputation Match\n95th percentile error\n(cm)\nLinear Regression Parameters\n\n\nSlope\nIntercept\n(cm)\nR2\n\n\n\n\n0.001 to 0.01\nno\nmoderate\n0.01\n1.06\n0.00\n0.54\n\n\n0.01 to 0.1\nno\nvery good\n0.01\n1.00\n0.00\n0.99\n\n\n0.1 to 1\nyes\nexcellent\n0.02\n1.00\n0.00\n1.00\n\n\n1 to 10\nyes\nexcellent\n0.07\n1.00\n0.00\n1.00\n\n\n10 to 100\nyes\nexcellent\n0.27\n1.00\n0.00\n1.00\n\n\n100 to 1000\nyes\nexcellent\n0.67\n1.00\n0.18\n1.00",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html#discussion",
    "href": "technical/comp_SLAMMER_results.html#discussion",
    "title": "Results comparison to SLAMMER",
    "section": "Discussion",
    "text": "Discussion\nSome differences should be expected.\nTo the extent the pySLAMMER code is doing the same calculations, the differences should be very small.\nThe differences should not accumulate with displacement magnitude.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html#conclusions",
    "href": "technical/comp_SLAMMER_results.html#conclusions",
    "title": "Results comparison to SLAMMER",
    "section": "Conclusions",
    "text": "Conclusions\n\nPySLAMMER is performing the same analysis as SLAMMER.\nNumerical differences are insignificant for engineering purposes, both in research and practice.\nTo the extent historical SLAMMER results are well documented, comparison with pySLAMMER results is appropriate.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_SLAMMER_results.html#footnotes",
    "href": "technical/comp_SLAMMER_results.html#footnotes",
    "title": "Results comparison to SLAMMER",
    "section": "Footnotes",
    "text": "Footnotes\n\n\npySLAMMER includes additional options for variable yield acceleration, but only stepwise variation is applicable to comparison with SLAMMER↩︎\nIf lower total damping than the equivalent foundation radiation damping is needed for some reason (e.g., for comparison with published analyses that did not include this damping mechanism) both SLAMMER and pySLAMMER accept negative values for damping ratio, which can be used to offset the damping applied by the foundation radiation damping.↩︎\n95 percent of all simulations in the range had errors less than this.↩︎",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Results comparison to SLAMMER"
    ]
  },
  {
    "objectID": "technical/comp_analytical.html",
    "href": "technical/comp_analytical.html",
    "title": "pySLAMMER",
    "section": "",
    "text": "In addition to comparing to the legacy results from SLAMMER, it is also worth comparing pySLAMMER’s results to analytical solutions to sliding block problems. In this section, we compare pySLAMMER’s calculated sliding displacements for rigid sliding blocks for single cycle harmonic motions of frequencies ranging from 0.5 to 10 Hz to an analytical solution.\nWhile analytical solutions to sliding block analyses are not possible for complex ground motions, they can be developed for simple harmonic motions and pulses @conte1989.\n\n\n\n\n\n\nNote\n\n\n\nThis page is a stub and will be updated soon.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Comparison with analytical solution"
    ]
  },
  {
    "objectID": "technical/comp_analytical.html#comparison-with-analytical-solution",
    "href": "technical/comp_analytical.html#comparison-with-analytical-solution",
    "title": "pySLAMMER",
    "section": "",
    "text": "In addition to comparing to the legacy results from SLAMMER, it is also worth comparing pySLAMMER’s results to analytical solutions to sliding block problems. In this section, we compare pySLAMMER’s calculated sliding displacements for rigid sliding blocks for single cycle harmonic motions of frequencies ranging from 0.5 to 10 Hz to an analytical solution.\nWhile analytical solutions to sliding block analyses are not possible for complex ground motions, they can be developed for simple harmonic motions and pulses @conte1989.\n\n\n\n\n\n\nNote\n\n\n\nThis page is a stub and will be updated soon.",
    "crumbs": [
      "Quickstart guide",
      "Technical guide",
      "Verifications",
      "Comparison with analytical solution"
    ]
  }
]