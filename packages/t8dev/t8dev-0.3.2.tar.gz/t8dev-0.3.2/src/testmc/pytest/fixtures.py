''' The following fixtures are part of the framework for unit testing
    assembly language code in projects using t8dev. Typically these will
    be added to the project by creating a src/conftest.py file containing:

       from testmc.pytest import *
'''

#   This is tested by testmc/*/tmc/bioscode.pt.

import  pytest
from    t8dev  import path

@pytest.fixture
def m(request):
    ''' A simulated machine with the object file loaded.

        The caller must define in its module a global variable ``Machine``
        which is the class of the CPU/machine simulator to instantiate.
        This is usually imported from one of the `testmc` submodules.

        If the module global ``object_files`` is defined, it will be read
        as a path (if `str`) or sequence of paths from which to load
        machine code via `Machine.load()`. Relative paths will be relative
        to `path.obj()`. Symbol values from later loads take preference
        over earlier ones.

        After the check/load of ``object_files``, if the module global
        ``test_rig`` is defined it's assumed that a binary was built with
        ``t8dev asltest`` and it will be found and loaded based on the path
        from which the test module was loaded, using the portion relative
        to `T8_PROJDIR` under `path.ptobj()`. Symbol values from this load
        will be preferred over those previously loaded via
        ``object_files``.
    '''
    Machine = getattr(request.module, 'Machine')
    m = Machine()

    if hasattr(request.module, 'object_files'):
        objfiles = getattr(request.module, 'object_files')
        if isinstance(objfiles, str):   # because forgetting the comma is such
            objfiles = (objfiles,)      # an easy mistake for devs to make
        for f in objfiles:
            m.load(path.obj(f), mergestyle='prefnew', setPC=False)

    if hasattr(request.module, 'test_rig'):
        relmodpath = path.relproj(request.module.__file__)
        object_file = path.ptobj(relmodpath).with_suffix('.p')
        m.load(object_file, mergestyle='prefnew')

    return m

#   These rely on pytest running the m() fixture only once per test, even
#   though both these fixtures and the test itself use it. I'm not sure if
#   this behaviour is documented, but it makes sense given that pytest
#   maintains careful control over the scope (test/module/etc.) in which a
#   fixture is used.

@pytest.fixture
def S(m):
    ''' The `Machine.symtab` attribute of the machine object produced by
        the `m` fixture.
    '''
    return m.symtab

@pytest.fixture
def R(m):
    ''' The `Machine.registers` attribute of the machine object produced by
        the `m` fixture.
    '''
    return m.Registers

@pytest.fixture
def loadbios(m, S):
    ''' Return a function that loads a unit test BIOS and connects input
        and output streams.

        All parameters are optional, and must be specified by name if used.

        The `biosname` parameter specifies the name of the BIOS; if `None`
        the `Machine` subclass's `biosname()` will be used. (Normally this
        never need be specified.) The BIOS is the object output of
        assembling ``testmc/BIOSNAME/tmc/bioscode.asm``. This assumes that
        the BIOS will define ``charinport`` and ``charoutport`` symbols,
        both set to the same value, that define the address in the memory
        map to set up to read and write for I/O to the streams below. (Note
        that this does not work for a separate I/O address space, if the
        CPU has one. This should be fixed to allow this somehow.)

        `input`, `output` and the return values all are passed to and come
        from `testmc.generic.iomem.setiostreams()`, which is used to to
        create I/O streams for the console read and write functions of the
        BIOS. See that function's documentation for full details.

        If provided, `input` is typically a `bytes` to be read, but it may
        be anything with a `read(1)` method. `output` is typically left
        unset to have the framework provide a stream from which you can
        read the output generated by the code under test. A pair of
        ``istream, ostream`` (with ``istream`` usually ignored) is returned
        for the test to query.

        Sample usage::

            _, ostream = loadbios('mc6800', b'some input\n')
            ...
            assert b'Hello, world!' == ostream.getvalue()
    '''
    def loadbios(*, input=None, output=None, biosname=None):
        biosname = biosname or m.biosname()
        bioscode = path.obj('testmc/', biosname, 'tmc/bioscode.p')
        m.load(bioscode, mergestyle='prefcur', setPC=False)
        assert S['charinport'] == S['charoutport']
        #   XXX Doesn't work for I/O address spaces.
        return m.setiostreams(S.charinport, input, output)
    return loadbios

