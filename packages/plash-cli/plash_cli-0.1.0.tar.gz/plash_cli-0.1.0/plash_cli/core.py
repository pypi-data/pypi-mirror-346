"""The Plash CLI tool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['PLASH_CONFIG_HOME', 'PLASH_DOMAIN', 'pat', 'stop', 'start', 'log_modes', 'get_client', 'mk_auth_req', 'get_app_id',
           'endpoint', 'is_included', 'poll_cookies', 'login', 'PlashError', 'validate_app', 'create_tar_archive',
           'deploy', 'view', 'delete', 'endpoint_func', 'logs', 'download']

# %% ../nbs/00_core.ipynb 2
from fastcore.all import *
from fastcore.xdg import *
import secrets, webbrowser, json, httpx, io, tarfile
from pathlib import Path
from uuid import uuid4
from time import time, sleep

import io, os, re, tarfile, tomllib

# %% ../nbs/00_core.ipynb 5
PLASH_CONFIG_HOME = xdg_config_home() / 'plash_config.json'
PLASH_DOMAIN = os.getenv("PLASH_DOMAIN","pla.sh")  # pla.sh plash-dev.answer.ai localhost:5002

# %% ../nbs/00_core.ipynb 6
def get_client(cookie_file):
    client = httpx.Client()
    if not cookie_file.exists():
        raise FileNotFoundError("Plash config not found. Please run plash_login and try again.")
    cookies = Path(cookie_file).read_json()
    client.cookies.update(cookies)
    client.headers.update({'X-PLASH': 'true'})
    return client

# %% ../nbs/00_core.ipynb 7
def mk_auth_req(url:str, method:str='get', **kwargs): return getattr(get_client(PLASH_CONFIG_HOME), method)(url, **kwargs)

# %% ../nbs/00_core.ipynb 8
def get_app_id(path:Path):
    plash_app = Path(path) / '.plash'
    if not plash_app.exists(): raise FileNotFoundError(f"File not found: {plash_app=}")
    return parse_env(fn=plash_app)['PLASH_APP_ID']

# %% ../nbs/00_core.ipynb 9
def endpoint(sub='', rt=''):
    p = "http" if "localhost" in PLASH_DOMAIN else "https"
    return f"{p}://{sub}{'.' if sub else ''}{PLASH_DOMAIN}{rt}"

# %% ../nbs/00_core.ipynb 10
def is_included(path):
    "Returns True if path should be included in deployment"
    if path.name.startswith('.'): return False
    if path.suffix == '.pyc': return False
    excludes = {'.git', '__pycache__', '.gitignore', '.env', 
                '.pytest_cache', '.venv', 'venv', '.ipynb_checkpoints',
                '.vscode', '.idea', '.sesskey'}
    return not any(p in excludes for p in path.parts)

# %% ../nbs/00_core.ipynb 12
def poll_cookies(paircode, interval=1, timeout=180):
    "Poll server for token until received or timeout"
    start = time()
    client = httpx.Client()
    url = endpoint(rt=f"/cli_token?paircode={paircode}")
    while time()-start < timeout:
        resp = client.get(url).raise_for_status()
        if resp.text.strip(): return dict(client.cookies)
        sleep(interval)
        
@call_parse
def login():
    "Authenticate CLI with server and save config"
    paircode = secrets.token_urlsafe(16)
    login_url = httpx.get(endpoint(rt=f"/cli_login?paircode={paircode}")).text
    print(f"Opening browser for authentication:\n{login_url}\n")
    webbrowser.open(login_url)
    
    cookies = poll_cookies(paircode)
    if cookies:
        Path(PLASH_CONFIG_HOME).write_text(json.dumps(cookies))
        print(f"Authentication successful! Config saved to {PLASH_CONFIG_HOME}")
    else: print("Authentication timed out.")

# %% ../nbs/00_core.ipynb 15
pat = r'(?m)^# /// (?P<type>[a-zA-Z0-9-]+)$\s(?P<content>(^#(| .*)$\s)+)^# ///$'

def _deps(script: bytes | str) -> dict | None:
    'Get the dependencies from the script. From: https://peps.python.org/pep-0723/'
    name = 'script'
    if isinstance(script, bytes): script = script.decode('utf-8')
    matches = L(re.finditer(pat, script)).filter(lambda m: m.group('type') == name)
    if len(matches) > 1: raise ValueError(f'Multiple {name} blocks found')
    elif len(matches) == 1:
        content = ''.join(line[2:] if line.startswith('# ') else line[1:]
                          for line in matches[0].group('content').splitlines(keepends=True))
        return '\n'.join(tomllib.loads(content)['dependencies'])
    else: return None

# %% ../nbs/00_core.ipynb 18
class PlashError(Exception): pass

def validate_app(path):
    "Validates that the app in the directory or script `path` is deployable as a Plash app"
    if not (path / 'main.py').exists():
        raise PlashError('A Plash app requires a main.py file.')
    deps = _deps((path / 'main.py').read_text())
    if  deps and (path/"requirements.txt").exists(): 
        raise PlashError('A Plash app should not contain both a requirements.txt file and inline dependencies (see PEP723).')

# %% ../nbs/00_core.ipynb 23
def create_tar_archive(path:Path) -> tuple[io.BytesIO, int]:
    "Creates a tar archive of a directory, excluding files based on is_included"
    tarz = io.BytesIO()
    files = L(path if path.is_file() else Path(path).iterdir()).filter(is_included)
    with tarfile.open(fileobj=tarz, mode='w:gz') as tar:
        for f in files: tar.add(f, arcname=f.name)
        if deps:=_deps((path / 'main.py').read_bytes()):
            info = tarfile.TarInfo('requirements.txt')
            info.size = len(deps)
            tar.addfile(info, io.BytesIO(deps.encode('utf-8')))
    tarz.seek(0)
    return tarz, len(files)

# %% ../nbs/00_core.ipynb 24
@call_parse
def deploy(
    path:Path=Path('.'), # Path to project
    app_id:str=None):    # App ID that will be used as the subdomain in plash
    'ðŸš€ Ship your app to production'
    print('Initializing deployment...')
    if app_id == '': print('Error: App ID cannot be an empty string'); return
    if not path.is_dir(): print("Error: Path should point to the project directory"); return
    try: validate_app(path)
    except PlashAppError as e: print(f"Error: {str(e)}\nInvalid path: {path}"); return
    
    plash_app = path / '.plash'
    if not app_id and not plash_app.exists():
        plash_app.write_text(f'export PLASH_APP_ID=fasthtml-app-{str(uuid4())[:8]}')
    aid = app_id or parse_env(fn=plash_app)['PLASH_APP_ID']
    
    tarz, _ = create_tar_archive(path)
    resp = mk_auth_req(endpoint(rt="/upload"), "post", files={'file': tarz}, timeout=300.0, data={'aid': aid})
    if resp.status_code == 200:
        print('âœ… Upload complete! Your app is currently being built.')
        print(f'It will be live at {endpoint(sub=aid)}')
    else: print(f'Failure: {resp.status_code}\n{resp.text}')

# %% ../nbs/00_core.ipynb 26
@call_parse
def view(
    path:Path=Path('.'), # Path to project
):
    url=endpoint(sub=get_app_id(path))
    print(f"Opening browser to view app :\n{url}\n")
    webbrowser.open(url)

# %% ../nbs/00_core.ipynb 28
@call_parse
def delete(
    path:Path=Path('.'), # Path to project
    force:bool=False):   # Skip confirmation prompt
    'Delete your deployed app'
    aid = get_app_id(path)
    if not force:
        confirm = input(f"Are you sure you want to delete app '{aid}'? This action cannot be undone. [y/N]: ")
        if confirm.lower() not in ['y', 'yes']:
            print("Deletion cancelled.")
            return
    
    print(f"Deleting app '{aid}'...")
    r = mk_auth_req(endpoint(rt=f"/delete?aid={aid}"), "delete")
    return r.text

# %% ../nbs/00_core.ipynb 30
def endpoint_func(endpoint_name):
    'Creates a function for a specific API endpoint'
    @call_parse
    def func(
        path:Path=Path('.'), # Path to project
    ):
        aid = get_app_id(path)
        r = mk_auth_req(endpoint(rt=f"{endpoint_name}?aid={aid}"))
        return r.text
    
    # Set the function name and docstring
    func.__name__ = endpoint_name
    func.__doc__ = f"Access the '{endpoint_name}' endpoint for your app"
    
    return func

# Create endpoint-specific functions
stop = endpoint_func('/stop')
start = endpoint_func('/start')

# %% ../nbs/00_core.ipynb 32
log_modes = str_enum('log_modes', 'build', 'app')

# %% ../nbs/00_core.ipynb 33
@call_parse
def logs(
    path:Path=Path('.'),    # Path to project
    mode:log_modes='build', # Choose between build or app logs
    tail:bool=False):       # Tail the logs
    'Prints the logs for your deployed app'
    aid = get_app_id(path)
    if tail:
        text = ''
        while True:
            try:
                r = mk_auth_req(endpoint(rt=f"/logs?aid={aid}&mode={mode}"))
                if r.status_code == 200:
                    print(r.text[len(text):], end='') # Only print updates
                    text = r.text
                    sleep(1)
                else:
                    print(f"Error: {r.status_code}")
            except KeyboardInterrupt:
                return "\nExiting"
    r = mk_auth_req(endpoint(rt=f"/logs?aid={aid}&mode={mode}"))
    return r.text

# %% ../nbs/00_core.ipynb 35
@call_parse
def download(
    path:Path=Path('.'),                 # Path to project
    save_path:Path=Path("./download/")): # Save path (optional)
    'Download your deployed app.'
    aid = get_app_id(path)
    try: save_path.mkdir(exist_ok=False)
    except: print(f"ERROR: Save path ({save_path}) already exists. Please rename or delete this folder to avoid accidental overwrites.")
    else:
        response = mk_auth_req(endpoint(rt=f'/download?aid={aid}')).raise_for_status()
        file_bytes = io.BytesIO(response.content)
        with tarfile.open(fileobj=file_bytes, mode="r:gz") as tar: tar.extractall(path=save_path)
        print(f"Downloaded your app to: {save_path}")
