from __future__ import annotations

import warnings
from typing import TYPE_CHECKING

from tab_err._utils import check_error_rate, get_column

from ._error_mechanism import ErrorMechanism

if TYPE_CHECKING:
    import pandas as pd


class ENAR(ErrorMechanism):
    """`ErrorMechanism` subclass implementing the `Erroneous Not At Random` error mechanism.

    Description:
        Errors are assumed to depend on either other variables, the incorrect data itself, or both.
    """

    def _sample(self: ENAR, data: pd.DataFrame, column: str | int, error_rate: float, error_mask: pd.DataFrame) -> pd.DataFrame:
        """Creates an error mask according to the `Erroneous Not At Random` error mechanism.

        Description:
            A random index is chosen using a random number generator to create a range of indices.
            The error free data is then sorted by value and the error mask is generated by selecting a contiguous block of sorted entries,
                thereby having similar values, and marking these entries true in the mask.
            This ensures that occurrence of errors is related to the value of the variable.


        Args:
            data (pd.DataFrame): DataFrame containing the column to add errors to
            column (str | int): The column of `data` to create an error mask for
            error_rate (float): Proportion of rows to be affected by errors; in range [0,1]
            error_mask (pd.DataFrame): A Pandas `DataFrame` with the same index & columns as `data` that will be modified and returned

        Raises:
            ValueError: If there are insufficient entries to add errors to with respect to the error rate, `a` ValueError will be returned

        Returns:
            pd.DataFrame: A Pandas DataFrame with `True` values at entries where an error should be introduced, `False` otherwise
        """
        check_error_rate(error_rate)
        se_data = get_column(data, column)
        se_mask = get_column(error_mask, column)

        if self.condition_to_column is not None:
            warnings.warn("'condition_to_column' is set but will be ignored by ENAR.", stacklevel=1)

        n_errors = int(len(se_data) * error_rate)

        # if mid-level or high-level API call ENAR, the error_mask already contains errors. Below we make sure that we only sample rows that do not
        # already contain errors.
        se_data_error_free = se_data[~se_mask]

        if len(se_data_error_free) < n_errors:
            msg = f"The error rate of {error_rate} requires {n_errors} error-free cells. "
            msg += f"However, only {len(se_data_error_free)} error-free cells are available."
            raise ValueError(msg)

        # TODO(anyone): ensure that the implementation is consistent between the ear and enar implementations of _sample -- upper_bound_variable?
        lower_error_index = self._random_generator.integers(0, len(se_data_error_free) - n_errors) if len(se_data_error_free) != n_errors else 0
        error_index_range = range(lower_error_index, lower_error_index + n_errors)
        selected_rows = se_data_error_free.sort_values().iloc[error_index_range]  # Introduce errors to locations of sorted values

        se_mask.loc[selected_rows.index] = True

        return error_mask
