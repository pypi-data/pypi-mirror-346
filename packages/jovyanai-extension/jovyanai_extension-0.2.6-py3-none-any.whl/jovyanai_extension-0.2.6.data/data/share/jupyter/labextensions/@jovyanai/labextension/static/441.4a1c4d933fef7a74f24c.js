"use strict";(self.webpackChunk_jovyanai_labextension=self.webpackChunk_jovyanai_labextension||[]).push([[441],{1441:(e,t,s)=>{s.r(t),s.d(t,{JovyanClient:()=>i});var n=null;"undefined"!=typeof WebSocket?n=WebSocket:"undefined"!=typeof MozWebSocket?n=MozWebSocket:void 0!==s.g?n=s.g.WebSocket||s.g.MozWebSocket:"undefined"!=typeof window?n=window.WebSocket||window.MozWebSocket:"undefined"!=typeof self&&(n=self.WebSocket||self.MozWebSocket);var r=n,o=class{debug(e,...t){console.debug(`[DEBUG] ${e}`,...t)}info(e,...t){console.info(`[INFO] ${e}`,...t)}warn(e,...t){console.warn(`[WARN] ${e}`,...t)}error(e,...t){console.error(`[ERROR] ${e}`,...t)}},a=class{toolExecutions;executors;constructor(e=new Map){this.toolExecutions=new Map,this.executors=e}handleError(e,t,s){console.error(t),s({type:"agent:tool_use_result",payload:{toolCall:{result:t,toolCallId:e}}})}handleMessage(e,t){const s=e.payload.toolCall.toolCallId;if(this.toolExecutions.has(s)){const n=this.toolExecutions.get(s);if(!n)return void this.handleError(s,`Tool call ID ${s} not found in toolExecutions map.`,t);n.handleMessage(e,t)}else{if("agent:tool_use_complete"==e.type){const e=`Tool call ID ${s} not found in toolExecutions map but received complete message.`;return void this.handleError(s,e,t)}const n=e.payload.toolCall.toolName,r=this.executors.get(n);r?(this.toolExecutions.set(s,r),r.handleMessage(e,t)):this.handleError(s,`Tool executor for tool name ${n} not found.`,t)}}registerToolExecutor(e,t){this.executors.set(e,t)}},i=(new a,class{constructor(e,t,s,n){this.url=e,this.jwtToken=t,this.userId=s,this.logger=n||new o,this.currentToken=t}ws=null;sessionId=null;currentChatId=null;messageHandlers=new Map;chatHandlers=new Map;messageQueue=[];_isConnected=!1;_isAuthenticated=!1;currentToken=null;logger;get isConnected(){return this._isConnected}get isAuthenticated(){return this._isAuthenticated}async connect(){return new Promise(((e,t)=>{try{this.ws=new r(this.url),this.ws.onopen=async()=>{this.logger.info("Connected to Jovyan AI server"),this._isConnected=!0;try{await this.authenticate(),this.processMessageQueue(),e()}catch(e){this.logger.error("Authentication failed:",e),t(e)}},this.ws.onerror=e=>{this.logger.error("WebSocket error:",e),this._isConnected=!1,t(new Error("Connection failed"))},this.ws.onclose=()=>{this._isConnected=!1,this._isAuthenticated=!1},this.setupMessageHandler()}catch(e){t(e)}}))}setupMessageHandler(){this.ws&&(this.ws.onmessage=e=>{try{const t=JSON.parse(e.data.toString());if(t.action&&this.chatHandlers.has(t.action)){const e=this.chatHandlers.get(t.action);return void(e&&e(t))}const s=t,n=this.messageHandlers.get(s.type);n&&n(s)}catch(e){this.logger.error("Error handling message:",e)}})}async authenticate(){return new Promise(((e,t)=>{if(!this._isConnected||!this.ws)return void t(new Error("Not connected to server"));this.messageHandlers.set("auth:success",(t=>{if("auth:success"===t.type){const s=t;this._isAuthenticated=!0,this.userId=s.payload.userId,e()}})),this.messageHandlers.set("error",(e=>{"error"===e.type&&t(new Error(e.payload.message))}));const s={type:"auth",payload:{token:this.currentToken}};this.ws.send(JSON.stringify(s))}))}processMessageQueue(){for(;this.messageQueue.length>0&&this._isConnected&&this._isAuthenticated;){const e=this.messageQueue.shift();e&&this.send(e)}}send(e){this._isConnected&&this._isAuthenticated?this.ws&&this.ws.send(JSON.stringify(e)):this.messageQueue.push(e)}async startSession(){return new Promise(((e,t)=>{if(!this._isConnected||!this._isAuthenticated)return void t(new Error("Not connected or not authenticated"));const s={type:"session:start",payload:{userId:this.userId}};this.messageHandlers.set("session:started",(s=>{"session:started"===s.type&&(this.sessionId=s.payload.sessionId,this.sessionId?e(this.sessionId):t(new Error("Session ID is null")))})),this.send(s)}))}async generateCode(e){return console.warn("Warning: generateCode() is deprecated. Please use generateCodeStream() instead."),new Promise(((t,s)=>{if(!this._isConnected)return void s(new Error("Not connected to server"));const n={type:"cell:generate_code",payload:e};this.messageHandlers.set("cell:generated_code",(e=>{"cell:generated_code"===e.type&&t(e.payload.generatedCode)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&s(new Error(e.payload.message))})),this.send(n)}))}async generateCodeStream(e,t){if(!this._isConnected)try{await this.connect()}catch(e){return Promise.reject(e)}return new Promise(((s,n)=>{const r={type:"cell:generate_code",payload:{...e,stream:!0}};let o="";this.messageHandlers.set("cell:generated_code_chunk",(e=>{if("cell:generated_code_chunk"===e.type){const s=e.payload.content;o+=s,t(s)}})),this.messageHandlers.set("cell:generated_code_complete",(e=>{"cell:generated_code_complete"===e.type&&s()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(r)}))}async suggestNextAction(e){return new Promise(((t,s)=>{if(!this._isConnected)return void s(new Error("Not connected to server"));const n={type:"cell:next_action_suggestion",payload:e};this.messageHandlers.set("cell:next_action_response",(e=>{"cell:next_action_response"===e.type&&t(e.payload.nextAction)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&s(new Error(e.payload.message))})),this.send(n)}))}async sendUserMessage(e,t){return console.warn("Warning: sendUserMessage() is deprecated. Please use sendUserMessageStream() instead."),new Promise(((s,n)=>{if(!this._isConnected)return void n(new Error("Not connected to server"));const r={type:"agent:user_message",payload:{message:e,context:t}};this.messageHandlers.set("agent:agent_message",(e=>{"agent:agent_message"===e.type&&s(e.payload.message)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(r)}))}async sendUserMessageStream(e,t,s){return this._isConnected?new Promise(((n,r)=>{const o={type:"agent:user_message",payload:{message:e,context:t,stream:!0}};let i="";t.tools||(t.tools=[]);const c=new a;t.tools.forEach((e=>{c.registerToolExecutor(e.name,e)})),this.messageHandlers.set("agent:agent_message_chunk",(e=>{if("agent:agent_message_chunk"===e.type){const t=e.payload.content;i+=t,s(t)}})),this.messageHandlers.set("agent:agent_message_complete",(e=>{"agent:agent_message_complete"===e.type&&n()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&r(new Error(e.payload.message))})),this.messageHandlers.set("agent:tool_use_chunk",(e=>{"agent:tool_use_chunk"===e.type&&c.handleMessage(e,this.send.bind(this))})),this.messageHandlers.set("agent:tool_use_complete",(e=>{"agent:tool_use_complete"===e.type&&c.handleMessage(e,this.send.bind(this))})),this.send(o)})):Promise.reject(new Error("Not connected to server"))}async close(){if(this.ws)return new Promise((e=>{this.ws.onclose=()=>{this.ws=null,this._isConnected=!1,this._isAuthenticated=!1,this.messageHandlers.clear(),this.messageQueue=[],e()},this.ws.close()}))}_setConnected(e){this._isConnected=e}async createChat(e){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((t,s)=>{this.messageHandlers.set("chat:created",(e=>{const s=e.payload.chat;this.currentChatId=s.id,t(s)})),this.messageHandlers.set("chat:error",(e=>{s(new Error(e.payload.error))})),this.send({type:"chat:create",payload:{user_id:this.userId,title:e}})}))}async setCurrentChatId(e){this.currentChatId=e}async getMessages(e,t=100,s=0){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((n,r)=>{this.messageHandlers.set("chat:messages",(e=>{const t=e.payload;n(t.messages)})),this.messageHandlers.set("chat:error",(e=>{r(new Error(e.payload.error))})),this.send({type:"chat:get_messages",payload:{chat_id:e,limit:t,offset:s}})}))}async getChats(){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((e,t)=>{this.messageHandlers.set("chat:chats",(t=>{const s=t.payload;e(s.chats)})),this.messageHandlers.set("chat:error",(e=>{t(new Error(e.payload.error))})),this.send({type:"chat:get_chats",payload:{user_id:this.userId}})}))}async sendChatUserMessageStream(e,t,s){if(!this._isConnected)return Promise.reject(new Error("Not connected to server"));if(!this.currentChatId)return Promise.reject(new Error("No active chat"));const n=this.currentChatId;return new Promise(((r,o)=>{this.send({type:"chat:user_message",payload:{content:e,chat_id:n,role:"user",context:{currentNotebook:t.currentNotebook,selectedCells:t.selectedCells,tools:t.tools},stream:!0}}),this.messageHandlers.set("chat:started",(()=>{})),this.messageHandlers.set("chat:chunk",(e=>{const t=e.payload.content;s(t)})),this.messageHandlers.set("chat:completed",(()=>{r()})),this.messageHandlers.set("chat:error",(e=>{o(new Error(e.payload.error))}))}))}async generateChatTitle(e){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");const t=this.currentChatId;if(!t)throw new Error("No active chat selected to generate title for");return new Promise(((s,n)=>{this.messageHandlers.set("chat:title_generated",(e=>{if("chat:title_generated"===e.type){const t=e;this.messageHandlers.delete("chat:title_generated"),this.messageHandlers.delete("chat:error"),s(t.payload.title)}})),this.messageHandlers.set("chat:error",(e=>{"error"===e.type&&(this.messageHandlers.delete("chat:title_generated"),this.messageHandlers.delete("chat:error"),n(new Error(e.payload.error)))}));const r={type:"chat:generate_title",payload:{message:e,chat_id:t}};this.send(r)}))}})}}]);