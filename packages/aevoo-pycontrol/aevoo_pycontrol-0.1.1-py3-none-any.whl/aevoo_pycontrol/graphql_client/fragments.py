# Generated by ariadne-codegen
# Source: ./_concatened.gql

from pydantic import Field
from typing import Any, List, Optional

from .base_model import BaseModel


class NodeDetails(BaseModel):
    attributes: List["NodeDetailsAttributes"]
    cid: str
    properties: List["NodeDetailsProperties"]
    services: List[str]


class NodeDetailsAttributes(BaseModel):
    cid: Optional[str]
    type: str


class NodeDetailsProperties(BaseModel):
    cid: Optional[str]
    entry_schema: Optional["NodeDetailsPropertiesEntrySchema"] = Field(
        alias="entrySchema"
    )
    required: Optional[bool]
    type: str


class NodeDetailsPropertiesEntrySchema(BaseModel):
    type: str


class Catalog(BaseModel):
    nodes_details: List["CatalogNodesDetails"] = Field(alias="nodesDetails")


class CatalogNodesDetails(NodeDetails):
    pass


class CredentialFields(BaseModel):
    cid: str
    disabled: bool
    email: str
    owner: Optional[List[str]]
    profile: Optional[str]
    read_only: bool = Field(alias="readOnly")


class NodeGet(BaseModel):
    attributes: Optional[Any]
    cid: str
    context_loaded: bool = Field(alias="contextLoaded")
    deleted: bool
    disabled: bool
    dst: Optional[str]
    errors: Optional[List[str]]
    initial: bool
    properties: Optional[Any]
    status: Optional[str]
    stopped: bool
    type: str
    uuid: Optional[str]


class NodeListList(NodeGet):
    pass


class NodeList(BaseModel):
    list: List["NodeListList"]


class InstanceDetails(NodeList):
    cid: str
    context_loaded: bool = Field(alias="contextLoaded")
    depends_loaded: bool = Field(alias="dependsLoaded")
    deleted: bool
    deleting: bool
    disabled: Optional[bool]
    domain_dn: str = Field(alias="domainDn")
    ephemeral: Optional[bool]
    inputs: Any
    is_read_only: bool = Field(alias="isReadOnly")
    mapping_id: str = Field(alias="mappingId")
    next_release: Optional[str] = Field(alias="nextRelease")
    outputs: Optional[Any]
    owner: Optional[str]
    piid: Optional[str]
    pmid: Optional[str]
    secrets: Optional[Any]
    status: str
    stop: bool
    stopped: bool
    topology: str
    topo_ns: str = Field(alias="topoNs")
    uuid: Optional[str]
    version: str


class InstancesList(BaseModel):
    list: List["InstancesListList"]


class InstancesListList(InstanceDetails):
    pass


class WsMappingInfo(BaseModel):
    cid: str
    fqdn: str
    infos: Optional["WsMappingInfoInfos"]
    is_consumer: bool = Field(alias="isConsumer")
    is_provider: bool = Field(alias="isProvider")
    is_saas: bool = Field(alias="isSaas")
    ready: bool


class WsMappingInfoInfos(BaseModel):
    direct_access: bool = Field(alias="directAccess")


class MappingsList(BaseModel):
    list: List["MappingsListList"]


class MappingsListList(BaseModel):
    cid: str
    name: str
    ws_list: List["MappingsListListWsList"] = Field(alias="wsList")


class MappingsListListWsList(WsMappingInfo):
    services_available: List["MappingsListListWsListServicesAvailable"] = Field(
        alias="servicesAvailable"
    )


class MappingsListListWsListServicesAvailable(BaseModel):
    cid: str
    list: List["MappingsListListWsListServicesAvailableList"]
    dev: Optional[str]
    stable: Optional[str]


class MappingsListListWsListServicesAvailableList(BaseModel):
    capabilities: Optional[Any]
    cid: str
    version: str


class MeFields(BaseModel):
    email: Optional[str]
    domain_dn: str = Field(alias="domainDn")
    exp: Optional[int]
    flag: Optional[str]
    profile: Optional[str]
    read_only: bool = Field(alias="readOnly")
    ws_cid: str = Field(alias="wsCid")


class NodeTopoMetaFields(BaseModel):
    cid: str
    depends_on: List[str] = Field(alias="dependsOn")
    depends_on_sub_level: List[str] = Field(alias="dependsOnSubLevel")
    min_depends_on: List[str] = Field(alias="minDependsOn")
    required_by: List[str] = Field(alias="requiredBy")
    required_by_sub_level: List[str] = Field(alias="requiredBySubLevel")
    select: bool
    substitute: bool


class Person(BaseModel):
    address: Optional[str]
    city: Optional[str]
    is_company: Optional[bool] = Field(alias="isCompany")
    country: Optional[str]
    mandate_status: str = Field(alias="mandateStatus")
    name: Optional[str]
    zip: Optional[str]


class ResourceDetails(BaseModel):
    cid: str
    disabled: Optional[bool]
    inputs: Any
    outputs: Optional[Any]
    status: str
    topology: str
    version: str


class ServiceDetailsFragment(BaseModel):
    capabilities: Optional[Any]
    cid: str
    ephemeral: bool
    inputs: Optional[Any]
    outputs: Optional[Any]
    price: Optional["ServiceDetailsFragmentPrice"]
    substitution_filter_properties: Optional[Any] = Field(
        alias="substitutionFilterProperties"
    )
    version: str


class ServiceDetailsFragmentPrice(BaseModel):
    per_hour: Optional[float] = Field(alias="perHour")
    per_month: Optional[float] = Field(alias="perMonth")


class ServicesList(BaseModel):
    list: List["ServicesListList"]


class ServicesListList(BaseModel):
    cid: str


class TopologyFields(BaseModel):
    cid: str
    dev: Optional[str]
    instances_count: int = Field(alias="instancesCount")
    list: List[str]
    namespace: str
    published: Optional[bool]
    stable: Optional[str]


class TopologiesDetails(BaseModel):
    namespaces: List["TopologiesDetailsNamespaces"]


class TopologiesDetailsNamespaces(BaseModel):
    cid: str
    list: List["TopologiesDetailsNamespacesList"]


class TopologiesDetailsNamespacesList(TopologyFields):
    pass


class TopologyVersionFields(BaseModel):
    cid: str
    name: str
    nodes_topo_meta: List["TopologyVersionFieldsNodesTopoMeta"] = Field(
        alias="nodesTopoMeta"
    )
    template: Any


class TopologyVersionFieldsNodesTopoMeta(NodeTopoMetaFields):
    pass


class Transaction(BaseModel):
    cid: str
    inputs: Optional[Any]
    is_saas: bool = Field(alias="isSaas")
    model: str
    name: str
    fqdn: str
    ref: str
    time_end: Optional[int] = Field(alias="timeEnd")
    time_start: Optional[int] = Field(alias="timeStart")
    version: Optional[str]


class TransactionDetails(Transaction):
    infos: Optional["TransactionDetailsInfos"]


class TransactionDetailsInfos(BaseModel):
    errors: List[str]
    secrets: Any
    status: str
    outputs: Optional[Any]


class WsMappingDetails(WsMappingInfo):
    instances: Optional["WsMappingDetailsInstances"]
    resources: List["WsMappingDetailsResources"]


class WsMappingDetailsInstances(InstancesList):
    pass


class WsMappingDetailsResources(ResourceDetails):
    pass


NodeDetails.model_rebuild()
Catalog.model_rebuild()
CredentialFields.model_rebuild()
NodeGet.model_rebuild()
NodeList.model_rebuild()
InstanceDetails.model_rebuild()
InstancesList.model_rebuild()
WsMappingInfo.model_rebuild()
MappingsList.model_rebuild()
MeFields.model_rebuild()
NodeTopoMetaFields.model_rebuild()
Person.model_rebuild()
ResourceDetails.model_rebuild()
ServiceDetailsFragment.model_rebuild()
ServicesList.model_rebuild()
TopologyFields.model_rebuild()
TopologiesDetails.model_rebuild()
TopologyVersionFields.model_rebuild()
Transaction.model_rebuild()
TransactionDetails.model_rebuild()
WsMappingDetails.model_rebuild()
