import sympy
import numpy as np
from sympy import symbols, diff
import sympy as sp
import matplotlib.pyplot as plt
from typing import List, Tuple

def lagrange_multiplier(x_vals: List, y_vals: List, graph: bool = False, x_range: Tuple = (-10, 10)):
    """
    ีีฟีกีถีธึีด ีง ิผีกีฃึีกีถีชีซ ีดีซีปีกึีฏีพีธีฒ ีขีกีฆีดีกีถีคีดีกีจ

    :param x_vals: x ีกึีชีฅึีถีฅึีซ ึีธึึีกีฏ (ีฏีฅีฟีฅึ)ึ
    :param y_vals: ึีธึีถีฏึีซีกีตีซ ีกึีชีฅึีถีฅึีซ ึีธึึีกีฏ ีฟึีพีกีฎ ีฏีฅีฟีฅึีธึีดึ
    :param graph: ีีธึึีกีคึีฅีฌ ึีธึีถีฏึีซีกีตีซ ีฃึีกึีซีฏีจ:
    :param x_range: ีีธึึีกีคึีดีกีถ ีดีซีปีกีฏีกีตึีจึ
    :return: ิผีกีฃึีกีถีปีซ ีซีถีฟีฅึีบีธีฌีกึีซีธีถ ีขีกีฆีดีกีถีคีกีดีจี ีธึีบีฅีฝ sympy.Expr ีฟีซีบีซ ึีขีตีฅีฏีฟึ
    """

    # ีีซีดีพีธีฌีซ ีฝีกีฐีดีกีถีธึีด
    x = sp.symbols('x')
    n = len(x_vals)

    Pn = 0

    for i in range(n):
        L_i = 1
        for j in range(n):
            if j != i:
                L_i *= (x - x_vals[j]) / (x_vals[i] - x_vals[j])

        Pn += y_vals[i] * L_i
    Pn = sp.expand(Pn)

    if graph:
        # ีีฅีฒีกึีธีญีธึีด ีฅีถึ sympy.Expr-ีจ numpy ึีธึีถีฏึีซีกีตีซ
        f_lambdified = sp.lambdify('x', Pn, "numpy")

        # ีีฟีฅีฒีฎีธึีด ีฅีถึ x-ีถีฅึีซ ีกึีชีฅึีถีฅึีจ
        x_values_for_graph = np.linspace(x_range[0], x_range[1], 400)
        y_values_for_graph = f_lambdified(x_values_for_graph)

        # ิณีฎีธึีด ีฅีถึ ีฃึีกึีซีฏีจ
        plt.plot(x_values_for_graph, y_values_for_graph, label=f'{str(Pn)}', color='b')

        # ิณีฎีธึีด ีฅีถึ ีฝีฏีฆีขีถีกีฏีกีถ ีฏีฅีฟีฅึีจ
        plt.scatter(x_vals, y_vals, color='r', label="ีึีพีกีฎ ีฏีฅีฟีฅึ", zorder=5)  # ิฟีกึีดีซึ ีฏีฅีฟีฅึ

        plt.xlabel('x')
        plt.ylabel('y')
        plt.title(f'ิณึีกึีซีฏ {str(Pn)}')
        plt.grid(True)
        plt.legend()
        plt.show()

    return Pn

def newton_interpolation(X, F, graph=False, x_range=(-10, 10)):
    """
    ีีกีทีพีกึีฏีธึีด ีง ีีตีธึีฟีธีถีซ ีซีถีฟีฅึีบีธีฌีกึีซีธีถ ีขีกีฆีดีกีถีคีกีดีจ ีฟึีพีกีฎ X ึ F ีฏีฅีฟีฅึีซ ีฐีกีดีกึ:

    :param X: x ีกึีชีฅึีถีฅึีซ ึีธึึีกีฏ (ีฏีฅีฟีฅึ)ึ
    :param F: ึีธึีถีฏึีซีกีตีซ ีกึีชีฅึีถีฅึีซ ึีธึึีกีฏ ีฟึีพีกีฎ ีฏีฅีฟีฅึีธึีดึ
    :param graph: ีีธึึีกีคึีฅีฌ ึีธึีถีฏึีซีกีตีซ ีฃึีกึีซีฏีจ:
    :param x_range: ีีธึึีกีคึีดีกีถ ีดีซีปีกีฏีกีตึีจึ
    :return: ีีตีธึีฟีธีถีซ ีซีถีฟีฅึีบีธีฌีกึีซีธีถ ีขีกีฆีดีกีถีคีกีดีจี ีธึีบีฅีฝ sympy.Expr ีฟีซีบีซ ึีขีตีฅีฏีฟึ
    """

    # Harmarutyun ึีธึีถีฏึีซีก (ีฐีกีดีกึีฏีดีกีถ ีฟีกึีขีฅึีกีฏ)
    def harmarutyun(*args):
        if len(args) == 1:
            return args[0][1]
        else:
            x, f_x = zip(*args)
            return (harmarutyun(*args[1:]) - harmarutyun(*args[:-1])) / (x[-1] - x[0])

    # ีีตีธึีฟีธีถีซ ีขีกีฆีดีกีถีคีกีดีซ ีฐีกีทีพีกึีฏ
    x = sp.symbols('x')
    N = F[0]
    X_F = [(X[i], F[i]) for i in range(len(X))]

    for i in range(1, len(X)):
        k = 1
        for j in range(i):
            k *= (x - X[j])
        k *= harmarutyun(*X_F[:i + 1])
        N += k

    # ีีตีธึีฟีธีถีซ ีขีกีฆีดีกีถีคีกีดีจ ีบีกึีฆีฅึีถีฅีฌ
    N = sp.simplify(N)

    if graph:
        # ีีฅีฒีกึีธีญีธึีด ีฅีถึ sympy.Expr-ีจ numpy ึีธึีถีฏึีซีกีตีซ
        f_lambdified = sp.lambdify('x', N, "numpy")

        # ีีฟีฅีฒีฎีธึีด ีฅีถึ x-ีถีฅึีซ ีกึีชีฅึีถีฅึีจ
        x_values_for_graph = np.linspace(x_range[0], x_range[1], 400)
        y_values_for_graph = f_lambdified(x_values_for_graph)

        # ิณีฎีธึีด ีฅีถึ ีฃึีกึีซีฏีจ
        plt.plot(x_values_for_graph, y_values_for_graph, label=f'N: {str(N)}', color='b')

        # ิณีฎีธึีด ีฅีถึ ีฝีฏีฆีขีถีกีฏีกีถ ีฏีฅีฟีฅึีจ
        plt.scatter(X, F, color='r', label="Original points", zorder=5)  # ิฟีกึีดีซึ ีฏีฅีฟีฅึ

        plt.xlabel('x')
        plt.ylabel('y')
        plt.title(f'Graph of {str(N)}')
        plt.grid(True)
        plt.legend()
        plt.show()

    return N

def rectangular_method(f_str, a, b, n):
    """
    ีึีฒีฒีกีถีฏีตีธึีถีถีฅึีซ ีดีฅีฉีธีคีจ ีธึีธีทีตีกีฌ ีซีถีฟีฅีฃึีกีฌีซ ีฐีกีดีกึ, ีธึีฟีฅีฒ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ

    :param f_str: ิปีถีฟีฅีฃึีพีธีฒ ึีธึีถีฏึีซีกีถ ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ
    :param a: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีถีฅึึึีซ ีฝีกีฐีดีกีถึ
    :param b: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีพีฅึึีซ ีฝีกีฐีดีกีถึ
    :param n: ีีซีปีกีฏีกีตึีจ ีขีกีชีกีถีธีฒ ีฐีกีฟีพีกีฎีถีฅึีซ ึีกีถีกีฏีจึ
    :return: ิปีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึ ีกึีชีฅึีจึ
    """

    x = sp.symbols('x')

    f_expr = sp.sympify(f_str)

    h = (b - a) / n

    integral_approx = 0
    for i in range(n):
        x_i = a + i * h
        integral_approx += f_expr.subs(x, x_i)

    integral_approx *= h

    return integral_approx

def trapezoidal_method(f_str, a, b, n) -> float:
    """
    ีีฅีฒีกีถีถีฅึีซ ีดีฅีฉีธีคีจ ีธึีธีทีตีกีฌ ีซีถีฟีฅีฃึีกีฌีซ ีฐีกีดีกึ, ีธึีฟีฅีฒ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ

    :param f_str: ิปีถีฟีฅีฃึีพีธีฒ ึีธึีถีฏึีซีกีถ ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ
    :param a: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีถีฅึึึีซ ีฝีกีฐีดีกีถึ
    :param b: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีพีฅึึีซ ีฝีกีฐีดีกีถึ
    :param n: ีีซีปีกีฏีกีตึีจ ีขีกีชีกีถีธีฒ ีฐีกีฟีพีกีฎีถีฅึีซ ึีกีถีกีฏีจึ
    :return: ิปีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึ ีกึีชีฅึีจึ
    """

    # ีีฟีฅีฒีฎีธึีด ีฅีถึ sympy ึีธึีธีญีกีฏีกีถีจ
    x = sp.symbols('x')

    # ีีกึีกีคีธึีฝ ีง, ีธึ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃ, ีธึีฝีฟีซ ีกีตีถ ีบีฅีฟึ ีง ึีธีญีกีฏีฅึีบีฅีฌ sympy-ีซ ีกึีฟีกีฐีกีตีฟีธึีฉีตีกีถ
    f_expr = sp.sympify(f_str)

    # ีีกึีกีขีฅึีกีฏึีธึีฉีตีธึีถ (ีฐีกีถีคีซีบีดีกีถ ีฌีกีตีถีธึีฉีตีธึีถ)
    h = (b - a) / n

    # ีีกีทีพีธึีด ีฅีถึ ีฝีฅีฒีกีถีถีฅึีซ ีดีฅีฉีธีคีซ ึีฃีฟีกีฃีธึีฎีดีกีดีข ีซีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึีธึีฉีตีธึีถีจ
    integral_approx = (f_expr.subs(x, a) + f_expr.subs(x, b)) / 2

    for i in range(1, n):
        x_i = a + i * h
        integral_approx += f_expr.subs(x, x_i)

    # ีีฅึีปีถีกีฏีกีถ ีกึีคีตีธึีถึีจ
    integral_approx *= h
    return float(integral_approx)

def parabola_method(f_str, a, b, n):
    """
    ีีกึีกีขีธีฌีถีฅึีซ ีดีฅีฉีธีคีจ ีธึีธีทีตีกีฌ ีซีถีฟีฅีฃึีกีฌีซ ีฐีกีดีกึ, ีธึีฟีฅีฒ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ

    :param f_str: ิปีถีฟีฅีฃึีพีธีฒ ึีธึีถีฏึีซีกีถ ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ
    :param a: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีถีฅึึึีซ ีฝีกีฐีดีกีถึ
    :param b: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีพีฅึึีซ ีฝีกีฐีดีกีถึ
    :param n: ีีซีปีกีฏีกีตึีจ ีขีกีชีกีถีธีฒ ีฐีกีฟีพีกีฎีถีฅึีซ ึีกีถีกีฏีจ (ีบีฅีฟึ ีง ีฌีซีถีซ ีฆีธึีตีฃ ีฉีซีพ)ึ
    :return: ิปีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึ ีกึีชีฅึีจึ
    """

    if n % 2 != 0:
        raise ValueError("n ีบีฅีฟึ ีง ีฌีซีถีซ ีฆีธึีตีฃ ีฉีซีพ")

    # ีีฟีฅีฒีฎีธึีด ีฅีถึ sympy ึีธึีธีญีกีฏีกีถีจ
    x = sp.symbols('x')

    # ีีกึีกีคีธึีฝ ีง, ีธึ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃ, ีธึีฝีฟีซ ีกีตีถ ีบีฅีฟึ ีง ึีธีญีกีฏีฅึีบีฅีฌ sympy-ีซ ีกึีฟีกีฐีกีตีฟีธึีฉีตีกีถ
    f_expr = sp.sympify(f_str)

    # ีีกึีกีขีฅึีกีฏึีธึีฉีตีธึีถ (ีฐีกีถีคีซีบีดีกีถ ีฌีกีตีถีธึีฉีตีธึีถ)
    h = (b - a) / n

    # ีีกีทีพีธึีด ีฅีถึ ีบีกึีกีขีธีฌีถีฅึีซ ีดีฅีฉีธีคีซ ึีฃีฟีกีฃีธึีฎีดีกีดีข ีซีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึีธึีฉีตีธึีถีจ
    integral_approx = f_expr.subs(x, a) + f_expr.subs(x, b)

    # ิถีธึีตีฃ ึ ีฏีฅีถีฟ ีฏีฅีฟีฅึีจ ีฐีกีทีพีฅีฌีธึ ีฐีกีดีกึ
    for i in range(1, n, 2):  # odd indices (4 * f(x_i))
        x_i = a + i * h
        integral_approx += 4 * f_expr.subs(x, x_i)

    for i in range(2, n, 2):  # even indices (2 * f(x_i))
        x_i = a + i * h
        integral_approx += 2 * f_expr.subs(x, x_i)

    # ีีฅึีปีถีกีฏีกีถ ีกึีคีตีธึีถึีจ
    integral_approx *= h / 3
    return float(integral_approx)

def romberg_method(f_str, a, b, n, graph=False):
    """
    ีีธีดีขีฅึีฃีซ ีดีฅีฉีธีคีจ ีธึีธีทีตีกีฌ ีซีถีฟีฅีฃึีกีฌีซ ีฐีกีดีกึ, ีธึีฟีฅีฒ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ

    :param f_str: ิปีถีฟีฅีฃึีพีธีฒ ึีธึีถีฏึีซีกีถ ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ
    :param a: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีถีฅึึึีซ ีฝีกีฐีดีกีถึ
    :param b: ิปีถีฟีฅีฃึีกีฌีจ ีฐีกีทีพีกึีฏีฅีฌีธึ ีพีฅึึีซ ีฝีกีฐีดีกีถึ
    :param n: ีีกีฏีกึีคีกีฏีถีฅึีซ ึีกีถีกีฏีจึ
    :param graph: ิตีฉีฅ True ีง, ีฃึีกึีซีฏีจ ีฏึีธึึีกีคึีพีซ, ีฅีฉีฅ Falseี ีธีนึ
    :return: ิปีถีฟีฅีฃึีกีฌีซ ีดีธีฟีกีพีธึ ีกึีชีฅึีจึ
    """

    # ีีฟีฅีฒีฎีธึีด ีฅีถึ sympy ึีธึีธีญีกีฏีกีถีจ
    x = sp.symbols('x')

    # ีีธึีถีฏึีซีกีตีซ ีกึีฟีกีฐีกีตีฟีธึีฉีตีธึีถีจ ีฝีฟีกีถีกีฌีธึ ีฐีกีดีกึ
    f_expr = sp.sympify(f_str)

    # ีีธีดีขีฅึีฃีซ ีฝีฅีฒีกีถีซ ีกีผีกีปีซีถ ีดีกีฏีกึีคีกีฏ
    h = b - a
    R = [[(f_expr.subs(x, a) + f_expr.subs(x, b)) * h / 2]]  # ิฑีผีกีปีซีถ ีดีกีฏีกึีคีกีฏ

    results = [R[0][0]]  # ีีกีฐีบีกีถีฅีฌีธึ ีฅีถึ ีกีดีฅีถ ีดีกีฏีกึีคีกีฏีซ ีกึีคีตีธึีถึีจ

    # ีีธีดีขีฅึีฃีซ ีดีฅีฉีธีคีจ ีฐีฅีฟีกีฃีก ีดีกีฏีกึีคีกีฏีถีฅึีธีพ
    for k in range(1, n):
        h /= 2
        # ิฝีดีขีกีพีธึีฅีฌ ีฝีฅีฒีกีถีซ ีกึีชีฅึีถีฅึีจ
        temp_sum = sum(f_expr.subs(x, a + i * h) for i in range(1, 2 ** k, 2))
        R.append([None] * (k + 1))  # ิฑีพีฅีฌีกึีถีธึีด ีฅีถึ ีถีธึ ีทีกึึีจ, ีธึีบีฅีฝีฆีซ ีฝีฅีฒีกีถีจ ีณีซีทีฟ ีนีกึีฝีซ ีฌีซีถีซ
        R[k][0] = (R[k - 1][0] / 2) + h * temp_sum
        results.append(R[k][0])  # ีีกีฐีบีกีถีฅีฌ ีกีผีกีปีซีถ ีฝีตีธึีถีจ (ีดีธีฟีกีพีธึีธึีฉีตีธึีถีจ)

        # ีีทีฃึีฟีดีกีถ ีฐีกีทีพีกึีฏ
        for j in range(1, k + 1):
            R[k][j] = (4 ** j * R[k][j - 1] - R[k - 1][j - 1]) / (4 ** j - 1)

    # ีีฅึีปีถีกีฏีกีถ ีกึีคีตีธึีถึีจ
    result = float(R[-1][-1])

    # ิณึีกึีซีฏีซ ีฏีกีผีธึึีธึีด, ีฅีฉีฅ graph=True ีง
    if graph:
        # ีีทีฃึีซีฟ ีกึีชีฅึีจ (ีฐีกีทีพีกีฎ ีง ีซีดีกีฝีฟีธีพ)
        exact_result = (b ** 3 - a ** 3) / 3

        # ิณึีกึีซีฏีซ ีฏีกีผีธึึีธึีด
        plt.plot(range(1, n + 1), results, label="ีีธีดีขีฅึีฃีซ ีดีธีฟีฅึีธึีดีถีฅึ")
        plt.axhline(exact_result, color='red', linestyle='--', label="ีีทีฃึีซีฟ ีกึีชีฅึ")
        plt.xlabel('ีีกีฏีกึีคีกีฏ')
        plt.ylabel('ีีธีฟีกีพีธึ ีกึีชีฅึ')
        plt.title(f"ีีธีดีขีฅึีฃีซ ีดีฅีฉีธีคีซ ีดีธีฟีฅึีธึีดีถีฅึ ึีธึีถีฏึีซีกีตีซ '{f_str}' ีฐีกีดีกึ")
        plt.legend()
        plt.grid(True)
        plt.show()

    return result

def euler_method_with_string(f_str, t0, y0, h, n):
    """
        ิทีตีฌีฅึีซ ีดีฅีฉีธีคีจ ีคีซึีฅึีฅีถึีซีกีฌ ีฐีกีพีกีฝีกึีดีกีถ ีฐีกีดีกึ, ีธึีฟีฅีฒ ีกีป ีฏีธีฒีดีซ ึีธึีถีฏึีซีกีถ ีฟึีพีธึีด ีง ีธึีบีฅีฝ ีฝีฉึีซีถีฃึ

        :param f_str: ฮ๐ฆ/ฮ๐ก ึีธึีถีฏึีซีกีถ ีธึีบีฅีฝ ีฝีฉึีซีถีฃ, ีฏีกีญีพีกีฎ t ึ y ึีธึีธีญีกีฏีกีถีถีฅึีซึึ
        :param t0: ีีฏีฆีขีถีกีฏีกีถ ีกึีชีฅึีจ t-ีซ ีฐีกีดีกึึ
        :param y0: ีีฏีฆีขีถีกีฏีกีถ ีกึีชีฅึีจ y-ีซ ีฐีกีดีกึึ
        :param h: ีีกีตีฌีซ ีฅึีฏีกึีธึีฉีตีธึีถีจึ
        :param n: ีีกีตีฌีฅึีซ ึีกีถีกีฏีจึ
        :return: ิตึีฏีธึ ึีธึึีกีฏี t-ีซ ีกึีชีฅึีถีฅึีจ ึ ีฐีกีดีกีบีกีฟีกีฝีญีกีถ y-ีซ ีกึีชีฅึีถีฅึีจึ
    """
    # Symbolic ึีธึีธีญีกีฏีกีถีถีฅึีซ ีฝีกีฐีดีกีถีธึีด
    t, y = sp.symbols('t y')
    # String-ีจ ึีธีญีกึีฏีธึีด ีฅีถึ Sympy ีกึีฟีกีฐีกีตีฟีธึีฉีตีกีถ
    f_expr = sp.sympify(f_str)
    # ีีฟีฅีฒีฎีธึีด ีฅีถึ ีฉีพีกีตีซีถ ึีธึีถีฏึีซีกี ีฐีกีทีพีฅีฌีธึ ีฐีกีดีกึ
    f_numeric = sp.lambdify((t, y), f_expr, "numpy")

    t_values = [t0]
    y_values = [y0]

    t_curr, y_curr = t0, y0
    for _ in range(n):
        y_curr = y_curr + h * f_numeric(t_curr, y_curr)
        t_curr = t_curr + h
        t_values.append(t_curr)
        y_values.append(y_curr)

    return t_values, y_values

def gauss_elimination(A, b):
    """
    ิณีกีธึีฝีซ ีดีฅีฉีธีคีธีพ ีฃีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ ีฌีธึีฎีธึีดึ

    :param A: ิณีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีดีกีฟึีซึึ
    :param b: ิฑีป ีฏีธีฒีดีซ ีพีฅีฏีฟีธึึ
    :return: ิณีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ ีฌีธึีฎีธึีดีจึ
    """

    n = len(b)
    # ีีฟีฅีฒีฎีธึีด ีฅีถึ ีจีถีคีฌีกีตีถีพีกีฎ ีดีกีฟึีซึีจ
    augmented_matrix = np.hstack((A, b.reshape(-1, 1)))

    # Forward elimination (ีฅีผีกีถีฏีตีธึีถีกีฑึ ีดีกีฟึีซึีซ ีฝีฟีกึีธึีด)
    for i in range(n):
        # Pivotingี ีฅีฉีฅ ีฐีซีดีถีกีฏีกีถ ีฟีกึึีจ ีฆึีธ ีง, ึีธีญีฅีฌ ีฟีธีฒีฅึีจ
        if augmented_matrix[i, i] == 0:
            for k in range(i + 1, n):
                if augmented_matrix[k, i] != 0:
                    augmented_matrix[[i, k]] = augmented_matrix[[k, i]]
                    break

        # ิฟีกึีฃีกีขีฅึีธึีด ีฐีซีดีถีกีฏีกีถ ีฟีธีฒีซ ีฟีกึึีฅึีจ
        for j in range(i + 1, n):
            ratio = augmented_matrix[j, i] / augmented_matrix[i, i]
            augmented_matrix[j, i:] -= ratio * augmented_matrix[i, i:]

    # Back substitution (ีฐีฅีฟีกีคีกึีฑ ึีกีตีฌ)
    x = np.zeros(n)
    for i in range(n - 1, -1, -1):
        x[i] = (augmented_matrix[i, -1] - np.dot(augmented_matrix[i, i + 1:n], x[i + 1:])) / augmented_matrix[i, i]

    return x

def gauss_jordan(A, b):
    """
    ิณีกีธึีฝ-ิบีธึีคีกีถีซ ีดีฅีฉีธีคีธีพ ีฃีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ ีฌีธึีฎีธึีดึ

    :param A: ิณีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีดีกีฟึีซึึ
    :param b: ิฑีป ีฏีธีฒีดีซ ีพีฅีฏีฟีธึึ
    :return: ิณีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ ีฌีธึีฎีธึีดีจึ
    """

    n = len(b)
    # ีีฟีฅีฒีฎีธึีด ีฅีถึ ีจีถีคีฌีกีตีถีพีกีฎ ีดีกีฟึีซึีจ
    augmented_matrix = np.hstack((A, b.reshape(-1, 1)))

    # ิณีธึีฎีจีถีฉีกึีจ
    for i in range(n):
        # Pivoting (ีกีบีกีฐีธีพีธึีด ีฅีถึ, ีธึ ีฐีซีดีถีกีฏีกีถ ีฟีกึึีจ 0 ีนีง)
        if augmented_matrix[i, i] == 0:
            for k in range(i + 1, n):
                if augmented_matrix[k, i] != 0:
                    augmented_matrix[[i, k]] = augmented_matrix[[k, i]]
                    break

        # Normalize row by the pivot element
        augmented_matrix[i] = augmented_matrix[i] / augmented_matrix[i, i]

        # ิถึีธีตีกึีถีธึีด ีฅีถึ ีขีธีฌีธึ ีฟีกึึีฅึีจ ีฐีซีดีถีกีฏีกีถ ีฟีกึึีซ ีพีฅึึีธึีด ึ ีถีฅึึึีธึีด
        for j in range(n):
            if j != i:
                augmented_matrix[j] -= augmented_matrix[j, i] * augmented_matrix[i]

    # ีีฅึีกีคีกึีฑีถีธึีด ีฅีถึ ีฌีธึีฎีธึีดีถีฅึีจ (ีพีฅึีปีซีถ ีฝีตีธึีถีจี x)
    return augmented_matrix[:, -1]

def simple_iteration(A, b, x0, tol=1e-6):
    """
    ีีกีฝีกึีกีฏ ีซีฟีฅึีกึีซีกีถีฅึีซ ีดีฅีฉีธีคึ

    :param A: numpy.ndarray, ีฐีกีดีกีฏีกึีฃีซ ีดีกีฟึีซึึ
    :param b: numpy.ndarray, ีกีฆีกีฟ ีกีถีคีกีดีถีฅึีซ ีพีฅีฏีฟีธึึ
    :param x0: numpy.ndarray, ีฝีฏีฆีขีถีกีฏีกีถ ีดีธีฟีกึีฏีธึีดึ
    :param tol: float, ีฝีญีกีฌีซ ีฉีธึีตีฌีกีฟึีฅีฌีซ ีทีฅีด (ีถีกีญีถีกีฏีกีถ ีกึีชีฅึีจี 1e-6)ึ
    :return: ิผีธึีฎีดีกีถ ีพีฅีฏีฟีธึ ึ ีซีฟีฅึีกึีซีกีถีฅึีซ ึีกีถีกีฏีจึ
    """

    M = np.diag(np.diag(A))  # ิฑึีฟีกีฐีกีถีธึีด ีฅีถึ A-ีซ ีกีถีฏีตีธึีถีกีฃีฎีกีตีซีถ ีดีกีฝีจ
    N = A - M  # ีีถีกึีกีฎ ีดีกีฝีจ

    M_inv = np.linalg.inv(M)  # M-ีซ ีฐีกีฏีกีคีกึีฑ ีดีกีฟึีซึีจ

    x = x0.copy()
    iteration = 0
    while True:
        x_new = M_inv @ (b - N @ x)
        iteration += 1
        if np.linalg.norm(x_new - x, ord=np.inf) < tol:  # ีีญีกีฌีซ ีฝีฟีธึีฃีธึีด
            return x_new
        x = x_new

def gauss_seidel_with_dvu(A, b, x0=None, tol=1e-10):
    """
        ิถีฅีตีคีฅีฌีซ ีดีฅีฉีธีค, ีฐีซีดีถีพีกีฎ ีดีกีฟึีซึีถีฅึีซ (A = D + V + U) ีขีกีชีกีถีดีกีถ ีพึีกึ

        :param A: ndarray, ิณีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ (n times n) ีดีกีฟึีซึีจึ
        :param b: ndarray, ิฑีป ีดีกีฝีซ ีพีฅีฏีฟีธึีจึ
        :param x0: ndarray, ีีฏีฆีขีถีกีฏีกีถ ีดีธีฟีกึีฏีธึีดีจ (ีฅีฉีฅ None, ีกีบีก ีฆึีธีถีฅึีธีพ ีพีฅีฏีฟีธึ)ึ
        :param tol: float, ีีทีฃึีฟีธึีฉีตีกีถ ีทีฅีดีจ ีฏีธีถีพีฅึีฃีดีกีถ ีฐีกีดีกึึ
        :return: x (ndarray), ีีฅึีปีถีกีฏีกีถ ีฌีธึีฎีธึีดีจึ
        :return: iter_count (int), ิฟีกีฟีกึีพีกีฎ ีซีฟีฅึีกึีซีกีถีฅึีซ ึีกีถีกีฏีจึ
    """

    n = len(b)
    x = np.zeros(n) if x0 is None else x0.copy()

    # ีีกีฟึีซึีถีฅึีซ ีขีกีชีกีถีธึีด A = D + V + U
    D = np.diag(np.diag(A))  # ิณีฌีญีกีพีธึ ีกีถีฏีตีธึีถีกีฃีฎีกีตีซีถ ีดีกีฟึีซึ
    V = np.tril(A, k=-1)  # ีีฟีธึีซีถ ีฅีผีกีถีฏีตีธึีถ (ีกีผีกีถึ ีกีถีฏีตีธึีถีกีฃีฎีซ)
    U = np.triu(A, k=1)  # ีีฅึีซีถ ีฅีผีกีถีฏีตีธึีถ (ีกีผีกีถึ ีกีถีฏีตีธึีถีกีฃีฎีซ)

    # ีีกีญีกีฐีกีทีพีกึีฏ D^-1
    D_inv = np.linalg.inv(D)

    iter_count = 0

    while True:
        iter_count += 1

        x_new = -np.dot(D_inv, np.dot(V + U, x)) + np.dot(D_inv, b)

        # ิฟีธีถีพีฅึีฃีดีกีถ ีฝีฟีธึีฃีธึีด (โ-ีถีธึีดีก)
        if np.linalg.norm(x_new - x, ord=np.inf) < tol:
            return x_new
        x = x_new

def leverrier_characteristic_polynomial(matrix):
    """
    ีีกีทีพีธึีด ีง ีดีกีฟึีซึีซ ีฝีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีจ ิผึีฅึีฅีตีซ ีดีฅีฉีธีคีธีพึ

    :param matrix: numpy.ndarray, ึีกีผีกีฏีธึีฝีซ ีดีกีฟึีซึ (n x n)ึ
    :return: list, ีฝีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีซ ีฃีธึีฎีกีฏีซึีถีฅึีจ [c_n, c_{n-1}, ..., c_0]ึ
    """

    n = matrix.shape[0]
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError("ีีกีฟึีซึีจ ีบีฅีฟึ ีง ีฌีซีถีซ ึีกีผีกีฏีธึีฝีซ:")

    # ีีฏีฆีขีถีกีฏีกีถ ีบีกีตีดีกีถีถีฅึ
    coefficients = [0] * (n + 1)  # ีีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีซ ีฃีธึีฎีกีฏีซึีถีฅึีจ
    coefficients[-1] = 1  # c_n = 1
    B = np.eye(n)  # ีีฏีฝีธึีด ีฅีถึ ีดีซีกีพีธึีกีตีซีถ ีดีกีฟึีซึีซึ

    # ีีฅีฏีธึึีฝีซีก
    for k in range(1, n + 1):
        # ีีกีทีพีธึีด ีฅีถึ S_k = trace(A * B)
        S_k = np.trace(matrix @ B)
        coefficients[-k - 1] = -S_k / k  # ิณีธึีฎีกีฏีซึีจ

        # ินีกึีดีกึีถีธึีด ีฅีถึ B-ีถ
        B = matrix @ B + coefficients[-k - 1] * np.eye(n)

    return coefficients

def faddeev_method(matrix):
    """
    ีีกีทีพีธึีด ีง ีดีกีฟึีซึีซ ีฝีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีจ ีีกีคึีซ ีดีฅีฉีธีคีธีพึ

    :param matrix: numpy.ndarray, ึีกีผีกีฏีธึีฝีซ ีดีกีฟึีซึ (n x n)ึ
    :return: list, ีฝีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีซ ีฃีธึีฎีกีฏีซึีถีฅึีจ [c_n, c_{n-1}, ..., c_0]ึ
    """

    n = matrix.shape[0]
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError("ีีกีฟึีซึีจ ีบีฅีฟึ ีง ีฌีซีถีซ ึีกีผีกีฏีธึีฝีซ:")

    # ีีฏีฆีขีถีกีฏีกีถ ีบีกีตีดีกีถีถีฅึ
    coefficients = [0] * (n + 1)  # ีีฅึีกีฏีกีถ ีขีกีฆีดีกีถีคีกีดีซ ีฃีธึีฎีกีฏีซึีถีฅึีจ
    coefficients[-1] = 1  # c_n = 1
    B = np.eye(n)  # ีีฏีฝีธึีด ีฅีถึ ีดีซีกีพีธึีกีตีซีถ ีดีกีฟึีซึีซึ

    # ีีฅีฏีธึึีฝีซีก
    for k in range(1, n + 1):
        # ีีกีทีพีธึีด ีฅีถึ trace(A * B)
        trace_value = np.trace(matrix @ B)
        coefficients[-k - 1] = trace_value / k  # ิณีธึีฎีกีฏีซึีจ

        # ินีกึีดีกึีถีธึีด ีฅีถึ B-ีถ
        B = matrix @ B - coefficients[-k - 1] * np.eye(n)
        print(B, )

    return coefficients

def von_mises_method(matrix, tol=1e-6, max_iter=1000):
    """
    ีีกีทีพีธึีด ีง ีดีกีฟึีซึีซ ีดีธีคีธึีฌีธีพ ีกีดีฅีถีกีดีฅีฎ ีฝีฅึีกีฏีกีถ ีกึีชีฅึีจ ึ ีฐีกีดีกีบีกีฟีกีฝีญีกีถ ีฝีฅึีกีฏีกีถ ีพีฅีฏีฟีธึีจ
    ีีธีถ ีีซีฆีฅีฝีซ ีดีฅีฉีธีคีธีพ:

    :param matrix: numpy.ndarray, ึีกีผีกีฏีธึีฝีซ ีดีกีฟึีซึ (n x n)
    :param tol: float, ีจีถีคีธึีถีฅีฌีซ ีทีฅีฒีดีกีถ ีฝีกีฐีดีกีถ (ีฝีฟีธึีฃีธึีด ีง ีฆีธึีฃีธึีคีธึีดีจ)
    :param max_iter: int, ีกีผีกีพีฅีฌีกีฃีธึีตีถ ีฏึีฏีถีธึีฉีตีธึีถีถีฅึีซ ีฉีซีพ
    :return: tuple, (ีดีธีคีธึีฌีธีพ ีกีดีฅีถีกีดีฅีฎ ีฝีฅึีกีฏีกีถ ีกึีชีฅึีจ, ีฐีกีดีกีบีกีฟีกีฝีญีกีถ ีฝีฅึีกีฏีกีถ ีพีฅีฏีฟีธึีจ)
    """
    n = matrix.shape[0]
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError("ีีกีฟึีซึีจ ีบีฅีฟึ ีง ีฌีซีถีซ ึีกีผีกีฏีธึีฝีซ:")

    # ีีฏีฆีขีถีกีฏีกีถ ีบีกีฟีกีฐีกีฏีกีถ ีธีน ีฆึีธีตีกีฏีกีถ ีพีฅีฏีฟีธึ
    b_k = np.random.rand(n)
    b_k = b_k / np.linalg.norm(b_k)  # ีีธึีดีกีพีธึีธึีด

    lambda_old = 0  # ีีกีญีถีกีฏีกีถ ีดีธีฟีกีพีธึีธึีด

    for _ in range(max_iter):
        # ีีกีทีพีธึีด ีง ีถีธึ ีพีฅีฏีฟีธึีจ
        b_k1 = np.dot(matrix, b_k)
        b_k1_norm = np.linalg.norm(b_k1)
        b_k = b_k1 / b_k1_norm  # ีีธึีดีกีพีธึีธึีด

        # ิณีถีกีฐีกีฟีธึีด ีฅีถึ ีฝีฅึีกีฏีกีถ ีกึีชีฅึีจ
        lambda_new = np.dot(b_k.T, np.dot(matrix, b_k))

        # ีีฟีธึีฃีธึีด ีฅีถึ ีฆีธึีฃีธึีคีธึีดีจ
        if np.abs(lambda_new - lambda_old) < tol:
            break
        lambda_old = lambda_new

    return lambda_new, b_k

def newton_method_sympy(f_str, x0, tol=1e-3, max_iter=100):
    """
    ีีตีธึีฟีธีถีซ ีดีฅีฉีธีคีธีพ ีฌีธึีฎีธึีด ีง ีธีน ีฃีฎีกีตีซีถ ีฐีกีพีกีฝีกึีธึีดีจ f(x) = 0 `sympy`-ีซ ีดีซีปีธึีธีพ, ีธึีฟีฅีฒ f(x) ีกึีฟีกีฐีกีตีฟีธึีฉีตีธึีถีถ ีกีผีกีปีกีถีธึีด ีง ีธึีบีฅีฝ string:

    :param f_str: ึีธึีถีฏึีซีกีถ f(x) ีธึีบีฅีฝ string (ึึีซีถีกีฏี 'x**2 - 2')
    :param x0: ีฝีฏีฆีขีถีกีฏีกีถ ีดีธีฟีกีพีธึีธึีฉีตีธึีถ
    :param tol: ีฝีญีกีฌีซ ีฉีธึีตีฌีกีฟึีฅีฌีซ ีนีกึีจ
    :param max_iter: ีกีผีกีพีฅีฌีกีฃีธึีตีถ ีพีฅึีกีคีกึีฑีธึีดีถีฅึีซ ึีกีถีกีฏ
    :return: ีกึีดีกีฟีจ
    """
    x = sp.symbols('x')
    f = sp.sympify(f_str)  # ิฝีดีขีกีฃึีธึีด ีฅีถึ string-ีจ ีธึีบีฅีฝ sympy ีกึีฟีกีฐีกีตีฟีธึีฉีตีธึีถ
    f_prime = sp.diff(f, x)  # ึีธึีถีฏึีซีกีตีซ ีกีผีกีปีซีถ ีขีกีทีญีธึีดีจ

    x_n = x0
    for i in range(max_iter):
        fx = f.subs(x, x_n)
        dfx = f_prime.subs(x, x_n)
        if abs(fx) < tol:
            return float(x_n)  # ิตีฉีฅ ีฝีญีกีฌีจ ึีธึึ ีง ีฉีธึีตีฌีกีฟึีฅีฌีซ ีนีกึีซึ, ีพีฅึีกีคีกึีฑีถีธึีด ีฅีถึ ีกึีคีตีธึีถึีจ

        if dfx == 0:
            raise ValueError("ีีธึีถีฏึีซีกีตีซ ีกีผีกีปีซีถ ีขีกีทีญีธึีดีจ ีฐีกีพีกีฝีกึ ีง ีฆึีธีตีซีถ, ีธึีจ ีฉีธึีตีฌีกีฟึีพีกีฎ ีนีง")

        x_n = x_n - fx / dfx  # ีีตีธึีฟีธีถีซ ีฐีกีถีฐีกีฝีฅึีธึีฉีตีธึีถีจ

    raise ValueError("ีีตีธึีฟีธีถีซ ีดีฅีฉีธีคีจ ีนีซ ีฃีฟีฅีฌ ีกึีดีกีฟีจ ีดีซีถีนึ ีกีผีกีพีฅีฌีกีฃีธึีตีถ ีทึีปีกีคีกึีฑีซ ึีกีถีกีฏีจ")

def newton_method_system(equations: list[str], variables: list[str], initial_guess: list,
                         iterations=10, show_iteration_results=False):
    """
    ิผีธึีฎีธึีด ีง ีฐีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃ ีีตีธึีฟีธีถีซ ีดีฅีฉีธีคีธีพึ

    :param show_iteration_results: ีีธึึีกีคึีธึีด ีง ีตีธึึีกึีกีถีนีตีธึึ ีซีฟีฅึีกึีซีกีตีธึีด ึีธึีธีญีกีฏีกีถีถีฅึีซ ีจีถีฉีกึีซีฏ ีกึีชีฅึีจ:
    :param equations: ีีกีพีกีฝีกึีธึีดีถีฅึีซ ีฐีกีดีกีฏีกึีฃีซ ีฝีตีธึีถีกีฏ-ีพีฅีฏีฟีธึ (ีขีธีฌีธึ ีฟีธีฒีฅึีจ ีฝีฉึีซีถีฃ ีฅีถ)ึ
    :param variables: ีีธึีธีญีกีฏีกีถีถีฅึีซ ีกีถีธึีถีถีฅึีซ ึีธึึีกีฏ (ีฝีฉึีซีถีฃีฅึีซ ึีธึึีกีฏ)ึ
    :param initial_guess: ีีฏีฆีขีถีกีฏีกีถ ีฏีฅีฟีจ (ึีธึึีกีฏ)ึ
    :param iterations: ิปีฟีฅึีกึีซีกีถีฅึีซ ีฉีซีพีจึ
    :return: ีีฟีกึีพีกีฎ ีกึีดีกีฟีถีฅึีซ ึีธึึีกีฏึ
    """

    # ีีธึีธีญีกีฏีกีถีถีฅึีซ ีฝีฟีฅีฒีฎีธึีด
    variables = symbols(variables)

    # ีีกีพีกีฝีกึีธึีดีถีฅึีซ ึีธึึีกีฏีซ ีฝีฟีฅีฒีฎีธึีด
    equations = [sympy.sympify(eq_str) for eq_str in equations]

    # ีีฏีฆีขีถีกีฏีกีถ ีฏีฅีฟีซ numpy array
    x_current = np.array(initial_guess, dtype=float).reshape(-1, 1)

    # ีีกีทีพีธึีด ีฅีถึ ีกีดีฅีถ ีฏึีฏีถีธีฒีธึีฉีตีกีถ ีฐีกีดีกึ
    for _ in range(iterations):
        # ิณีฟีถีธึีด ีฅีถึ ึีธึีถีฏึีซีกีถีฅึีซ ีกึีชีฅึีถีฅึีจ
        f_values = np.array([
            [float(eq.subs({var: x_current[i][0] for i, var in enumerate(variables)}))]
            for eq in equations
        ])
        print(f_values)

        # ีีกีทีพีธึีด ีง ีีกีฏีธีขีซ ีดีกีฟึีซึีจ
        jacobian = np.array([
            [
                float(diff(eq, var).subs({v: x_current[i][0] for i, v in enumerate(variables)}))
                for var in variables
            ]
            for eq in equations
        ])

        # ิณีฟีถีธึีด ีฅีถึ ีีกีฏีธีขีซ ีดีกีฟึีซึีซ ีฐีกีฏีกีคีกึีฑีจ
        jacobian_inv = np.linalg.inv(jacobian)

        # ินีกึีดีกึีถีธึีด ีฅีถึ x_current-ีจ
        x_current = x_current - np.matmul(jacobian_inv, f_values)
        if show_iteration_results:
            for i in range(len(variables)):
                for j in range(len(variables)):
                    print(f"{i + 1}-ึีค ีซีฟีฅึีกึีซีกีตีธึีด {variables[j]} = {x_current[j]}")
                print()

    result = [float(x_current[i]) for i in range(len(x_current))]

    return result
